<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Machinery Book</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Welcome</a></li><li class="chapter-item expanded "><a href="what_is_the_machinery.html"><strong aria-hidden="true">2.</strong> What is The Machinery</a></li><li class="chapter-item expanded "><a href="licenses.html"><strong aria-hidden="true">3.</strong> Licenses</a></li><li class="chapter-item expanded "><a href="getting_started/index.html"><strong aria-hidden="true">4.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting_started/what_is_in_the_package.html"><strong aria-hidden="true">4.1.</strong> What is in this package</a></li><li class="chapter-item expanded "><a href="getting_started/logging_in.html"><strong aria-hidden="true">4.2.</strong> Sign In</a></li><li class="chapter-item expanded "><a href="getting_started/new_project.html"><strong aria-hidden="true">4.3.</strong> New Project</a></li><li class="chapter-item expanded "><a href="getting_started/first_gameplay_project.html"><strong aria-hidden="true">4.4.</strong> First Gameplay Project</a></li><li class="chapter-item expanded "><a href="getting_started/sample-projects.html"><strong aria-hidden="true">4.5.</strong> Sample Projects</a></li><li class="chapter-item expanded "><a href="getting_started/troubleshooting.html"><strong aria-hidden="true">4.6.</strong> Troubleshooting</a></li><li class="chapter-item expanded "><a href="getting_started/migration_from_unity.html"><strong aria-hidden="true">4.7.</strong> The Machinery for Unity Dev's</a></li><li class="chapter-item expanded "><a href="getting_started/migration_from_unreal.html"><strong aria-hidden="true">4.8.</strong> The Machinery for Unreal 4 Dev's</a></li></ol></li><li class="chapter-item expanded "><a href="the_editor/index.html"><strong aria-hidden="true">5.</strong> The Editor</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="the_editor/tabs.html"><strong aria-hidden="true">5.1.</strong> About Tabs</a></li><li class="chapter-item expanded "><a href="the_editor/entity_tree_tab.html"><strong aria-hidden="true">5.2.</strong> Entity Tree Tab</a></li><li class="chapter-item expanded "><a href="the_editor/scene_tab.html"><strong aria-hidden="true">5.3.</strong> Scene Tab</a></li><li class="chapter-item expanded "><a href="the_editor/properties_tab.html"><strong aria-hidden="true">5.4.</strong> Properties Tab</a></li><li class="chapter-item expanded "><a href="the_editor/asset_browser.html"><strong aria-hidden="true">5.5.</strong> Asset Browser</a></li><li class="chapter-item expanded "><a href="the_editor/simulate_tab.html"><strong aria-hidden="true">5.6.</strong> Simulate Tab</a></li><li class="chapter-item expanded "><a href="the_editor/preview_tab.html"><strong aria-hidden="true">5.7.</strong> Preview Tab</a></li></ol></li><li class="chapter-item expanded "><a href="editing_workflows/index.html"><strong aria-hidden="true">6.</strong> Editing Workflows</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="editing_workflows/entities.html"><strong aria-hidden="true">6.1.</strong> Entities</a></li><li class="chapter-item expanded "><a href="editing_workflows/creation_graphs_asset_pipeline.html"><strong aria-hidden="true">6.2.</strong> Creation graphs and asset pipeline</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="editing_workflows/import_assets.html"><strong aria-hidden="true">6.2.1.</strong> Import Assets</a></li><li class="chapter-item expanded "><a href="editing_workflows/import_projects.html"><strong aria-hidden="true">6.2.2.</strong> Import Projects</a></li><li class="chapter-item expanded "><a href="creation_graphs/concept.html"><strong aria-hidden="true">6.2.3.</strong> Meshes / Materials / Shaders</a></li></ol></li><li class="chapter-item expanded "><a href="editing_workflows/prototypes.html"><strong aria-hidden="true">6.3.</strong> Prototypes</a></li><li class="chapter-item expanded "><a href="editing_workflows/simulation.html"><strong aria-hidden="true">6.4.</strong> Simulation</a></li><li class="chapter-item expanded "><a href="editing_workflows/visual-scripting.html"><strong aria-hidden="true">6.5.</strong> Visual Scripting: Entity Graphs</a></li><li class="chapter-item expanded "><a href="editing_workflows/physics.html"><strong aria-hidden="true">6.6.</strong> Physics</a></li><li class="chapter-item expanded "><a href="editing_workflows/animation/index.html"><strong aria-hidden="true">6.7.</strong> Animation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="editing_workflows/animation/animation-state-machine.html"><strong aria-hidden="true">6.7.1.</strong> Animation State Machines</a></li><li class="chapter-item expanded "><a href="editing_workflows/animation/animation-compression.html"><strong aria-hidden="true">6.7.2.</strong> Animation Compression</a></li></ol></li><li class="chapter-item expanded "><a href="editing_workflows/sound.html"><strong aria-hidden="true">6.8.</strong> Sound</a></li><li class="chapter-item expanded "><a href="editing_workflows/publish.html"><strong aria-hidden="true">6.9.</strong> Publish</a></li><li class="chapter-item expanded "><a href="editing_workflows/sculpting.html"><strong aria-hidden="true">6.10.</strong> Sculpt Tool / White boxing</a></li></ol></li><li class="chapter-item expanded "><a href="the_truth/index.html"><strong aria-hidden="true">7.</strong> The Truth</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="the_truth/access_values.html"><strong aria-hidden="true">7.1.</strong> Access values</a></li><li class="chapter-item expanded "><a href="the_truth/create_an_object.html"><strong aria-hidden="true">7.2.</strong> Create an object</a></li><li class="chapter-item expanded "><a href="the_truth/modify_an_object.html"><strong aria-hidden="true">7.3.</strong> Modify an object</a></li><li class="chapter-item expanded "><a href="the_truth/common_types.html"><strong aria-hidden="true">7.4.</strong> Common Types</a></li><li class="chapter-item expanded "><a href="the_truth/aspects.html"><strong aria-hidden="true">7.5.</strong> Aspects</a></li><li class="chapter-item expanded "><a href="the_truth/custom_truth_type.html"><strong aria-hidden="true">7.6.</strong> Create a Truth Type</a></li></ol></li><li class="chapter-item expanded "><a href="creation_graphs/concept.html"><strong aria-hidden="true">8.</strong> Creation Graphs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="creation_graphs/intro_unity.html"><strong aria-hidden="true">8.1.</strong> Creation Graphs for Untiy Dev's</a></li><li class="chapter-item expanded "><a href="creation_graphs/intro_unreal.html"><strong aria-hidden="true">8.2.</strong> Creation Graphs for Unreal 4 Dev's</a></li><li class="chapter-item expanded "><a href="creation_graphs/node_types.html"><strong aria-hidden="true">8.3.</strong> Node Types</a></li><li class="chapter-item expanded "><a href="creation_graphs/shader_system.html"><strong aria-hidden="true">8.4.</strong> Shader System Interaction</a></li></ol></li><li class="chapter-item expanded "><a href="extending_the_machinery/index.html"><strong aria-hidden="true">9.</strong> Extending The Machinery</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="extending_the_machinery/the_plugin_system.html"><strong aria-hidden="true">9.1.</strong> The Plugin System</a></li><li class="chapter-item expanded "><a href="extending_the_machinery/hot-reloading.html"><strong aria-hidden="true">9.2.</strong> Hot-reloading</a></li><li class="chapter-item expanded "><a href="extending_the_machinery/write-a-plugin.html"><strong aria-hidden="true">9.3.</strong> Write a plugin</a></li><li class="chapter-item expanded "><a href="extending_the_machinery/write-a-tab.html"><strong aria-hidden="true">9.4.</strong> Write a tab</a></li><li class="chapter-item expanded "><a href="extending_the_machinery/plugin-assets.html"><strong aria-hidden="true">9.5.</strong> Plugin assets</a></li></ol></li><li class="chapter-item expanded "><a href="gameplay_coding/index.html"><strong aria-hidden="true">10.</strong> Gameplay coding</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="gameplay_coding/simulate_entry.html"><strong aria-hidden="true">10.1.</strong> Simulate Entry in C</a></li><li class="chapter-item expanded "><a href="gameplay_coding/extend_the_visual_scripting_language.html"><strong aria-hidden="true">10.2.</strong> Extending the visual scripting language</a></li><li class="chapter-item expanded "><a href="gameplay_coding/ecs/index.html"><strong aria-hidden="true">10.3.</strong> Entity Component System</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="gameplay_coding/ecs/write_a_custom_component.html"><strong aria-hidden="true">10.3.1.</strong> Write a custom component</a></li><li class="chapter-item expanded "><a href="gameplay_coding/ecs/how_entites_can_interact.html"><strong aria-hidden="true">10.3.2.</strong> How can Entities Interact?</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="gameplay_coding/ecs/how_to_design_system_or_engine.html"><strong aria-hidden="true">10.3.2.1.</strong> How to design a System or an Engine?</a></li><li class="chapter-item expanded "><a href="gameplay_coding/ecs/how_to_define_a_engine_system.html"><strong aria-hidden="true">10.3.2.2.</strong> How to define a System or an Engine?</a></li><li class="chapter-item expanded "><a href="gameplay_coding/ecs/how_to_register_a_system_or_engine.html"><strong aria-hidden="true">10.3.2.3.</strong> How to register a System or an Engine?</a></li><li class="chapter-item expanded "><a href="gameplay_coding/ecs/tagging_entities.html"><strong aria-hidden="true">10.3.2.4.</strong> Tagging Entities</a></li><li class="chapter-item expanded "><a href="gameplay_coding/ecs/filtering_entities.html"><strong aria-hidden="true">10.3.2.5.</strong> Filtering Entities</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="helper_tools/tmbuild.html"><strong aria-hidden="true">10.4.</strong> How to build my plugin</a></li></ol></li><li class="chapter-item expanded "><a href="collaboration.html"><strong aria-hidden="true">11.</strong> Collaboration</a></li><li class="chapter-item expanded "><a href="qa_pipeline/index.html"><strong aria-hidden="true">12.</strong> QA Pipeline</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="qa_pipeline/logging.html"><strong aria-hidden="true">12.1.</strong> Logging</a></li><li class="chapter-item expanded "><a href="qa_pipeline/how_to_write_unit_tests.html"><strong aria-hidden="true">12.2.</strong> Write your own unit tests</a></li><li class="chapter-item expanded "><a href="qa_pipeline/how_to_write_integration_tests.html"><strong aria-hidden="true">12.3.</strong> Write your own integration tests</a></li></ol></li><li class="chapter-item expanded "><a href="helper_tools/index.html"><strong aria-hidden="true">13.</strong> Helper Tools</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="helper_tools/tmbuild.html"><strong aria-hidden="true">13.1.</strong> How to use tmbuild</a></li><li class="chapter-item expanded "><a href="helper_tools/hash.html"><strong aria-hidden="true">13.2.</strong> How to use hash</a></li><li class="chapter-item expanded "><a href="helper_tools/tmbuild_package_reference.html"><strong aria-hidden="true">13.3.</strong> tmbuild package reference</a></li></ol></li><li class="chapter-item expanded "><a href="writing_an_executable.html"><strong aria-hidden="true">14.</strong> Writing an executable</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">The Machinery Book</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/OurMachinery/themachinery-books" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>Hi,</p>
<p>Thanks for using <em>The Machinery</em>. We’re excited to share with the
world what we have cooked up and happy to have you among the people that are trying out the engine.
This book is here to give you a little bit of background and information about what you’re looking at.</p>
<p>Besides this book we have several other resources which might be good to checkout:</p>
<ul>
<li><a href="https://ourmachinery.com/apidoc/apidoc.html">Our API Documentation</a></li>
<li><a href="https://ourmachinery.com/post/">Our Blog</a></li>
<li><a href="https://anchor.fm/ourmachinery">Our Podcast</a></li>
<li><a href="https://discord.gg/SHHSZaH">Our Discord</a></li>
<li><a href="https://github.com/OurMachinery/themachinery-public/discussions">Our Github Discussion Board</a></li>
<li><a href="https://ourmachinery.github.io/themachinery-books/tutorials/">Tutorials and Workflow Book</a></li>
</ul>
<p>Enjoy!</p>
<p><em>The Machinery Team</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-the-machinery"><a class="header" href="#what-is-the-machinery">What is The Machinery?</a></h1>
<p><em>The Machinery</em> is a framework for building different kinds of 3D software: editors, tools, pipeline components, games, visualizations, simulations, toys, experiments, etc. You can think of it as a <em>game engine</em>, but it’s intended use stretches beyond games, covering a wide range of applications. What makes <em>The Machinery</em> special is that it is <em>lightweight</em> and completely <em>plugin-based.</em> That means that you are not limited to a single editor and runtime. Rather, you can mix and match components as you need (or write your own) to create your own unique experience. <em>The Machinery</em> can also be stripped down and run embedded, as part of a larger application.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="license"><a class="header" href="#license">License</a></h2>
<p>There are three different licenses that you can use for The Machinery:</p>
<ul>
<li>
<p>The <strong>Indie Free</strong> license is completely free for indie developers and includes all of The
Machinery, except for the source code.</p>
</li>
<li>
<p>The <strong>Indie Pro</strong> license is exactly the same, but also includes the full source code of the
engine and all associated tools. For this version we charge <del>$100</del> <strong>$50</strong> / user / year.</p>
</li>
<li>
<p>The <strong>Business</strong> version is aimed towards professional users. It includes the same stuff as the
Indie Pro version except your support tickets will be prioritized. It sells at <del>$900</del> <strong>$450</strong> /
user / year.</p>
</li>
</ul>
<p>We define as an “indie”, any company who’s yearly revenue or funding is less than $100K/year. Until the end of the year 2021, we're offering all the paid licenses at 50 % off. If you buy a paid license now, you will keep this low price for the next five years.</p>
<p>All of the licenses allow for full royalty-free use of The Machinery. You can build and sell commercial games, tools, applications, and plugins. For more details, see our <a href="http://www.ourmachinery.com/pricing.html">pricing page</a>.</p>
<p>When you download The Machinery, you will be on the Indie Free license. If you do not fall in the &quot;indie&quot; category, you can still use this license to evaluate The Machinery, but you need to buy a business license to put it into production.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h1>
<p>To run The Machinery you need:</p>
<ul>
<li>A 64-bit Windows 10 machine with the latest Vulkan drivers</li>
<li><strong>Or</strong> a 64-bit Ubuntu 20.04 Linux machine with the latest Vulkan drivers (ArchLinux should also work, no guarantees are made for other distros)</li>
<li><strong>And</strong> an <a href="https://ourmachinery.com/">ourmachinery.com</a> account. <a href="https://ourmachinery.com/sign-up.html">Sign up here!</a></li>
</ul>
<p>On Linux, you also need to install the following packages for the runtime:</p>
<pre><code class="language-bash">sudo apt-get install libxcb-ewmh2 libxcb-cursor0 libxcb-xrm0 unzip
</code></pre>
<p><em>This does not work on your distro</em>? No problem, visit our <a href="https://github.com/OurMachinery/themachinery-public/discussions/616">Linux installation process across distributions guide</a>.</p>
<h2 id="getting-up-and-running"><a class="header" href="#getting-up-and-running">Getting up and running</a></h2>
<p>Quick steps to get up and running:</p>
<ol>
<li>
<p>Download The Machinery at <a href="https://ourmachinery.com/download.html">https://ourmachinery.com/download.html</a>.</p>
</li>
<li>
<p>Sign up for an <a href="https://ourmachinery.com/">ourmachinery.com</a> account <a href="https://ourmachinery.com/sign-up.html">here</a>. (It's free!)</p>
</li>
<li>
<p>Unzip the downloaded zip file to a location of your choosing.</p>
</li>
<li>
<p>Run <code>bin/the-machinery.exe</code> in the downloaded folder to start The Machinery.</p>
</li>
<li>
<p>Login with your <a href="https://ourmachinery.com/">ourmachinery.com</a> account at the login screen and approve the EULA.</p>
</li>
<li>
<p>To find some samples to play with go to <strong>Help &gt; Download Sample Projects</strong> in the main menu.</p>
</li>
<li>
<p>Pick one of the sample projects (for example <strong>Physics</strong>), click <strong>Get</strong> and then <strong>Open</strong>.</p>
</li>
<li>
<p>Play around with it, try some other samples and read the rest of this document to find out what
else you can do with The Machinery.</p>
</li>
</ol>
<p>If you get errors that mention Vulkan or if you see weird rendering glitches, make sure to update
your GPU drivers to the latest version. If that doesn't work, post an issue with our <a href="https://github.com/OurMachinery/themachinery-public/issues">issue
tracker</a> or ping us on
<a href="https://discord.gg/uJtkbVr">Discord</a> and we will help you.</p>
<p>Here is an introduction video showing these steps:</p>
<p><a href="https://www.youtube.com/watch?v=oQGghpCqBhI&amp;list=PLjhMvDI5f-Iox5sKvVFGWKB9DdCiei-8L">Introduction to The Machinery.</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-in-this-package"><a class="header" href="#what-is-in-this-package">What is in this package?</a></h1>
<p>In the distribution package you will find this:</p>
<table><thead><tr><th>Folder</th><th>Content</th></tr></thead><tbody>
<tr><td><strong>headers/</strong><br></td><td></td></tr>
<tr><td><strong>lib/</strong><br></td><td></td></tr>
<tr><td><strong>bin/</strong></td><td>The headers, libraries, and DLLs that make up <em>The Machinery</em> SDK.</td></tr>
<tr><td><strong>bin/the‑machinery.exe</strong></td><td>The Machinery's main editor.</td></tr>
<tr><td><strong>doc/</strong></td><td>SDK  documentation.</td></tr>
<tr><td><strong>samples/</strong></td><td>Sample code that shows how to extend the editor and SDK with plugins, as well as how to build new executables on top of <em>The Machinery.</em></td></tr>
<tr><td><strong>code/</strong></td><td>For reference: code for our utility programs.</td></tr>
<tr><td><strong>bin/simple‑draw.exe</strong></td><td>A simple drawing program built on top of the SDK.</td></tr>
<tr><td><strong>bin/simple-3d.exe</strong></td><td>A simple 3D viewport built on top of the SDK.</td></tr>
<tr><td><strong>bin/tmbuild.exe</strong></td><td>Our build tool, that can be used to build samples and plugins.</td></tr>
<tr><td><strong>bin/docgen.exe</strong></td><td>Our tool for generating documentation.</td></tr>
<tr><td><strong>bin/hash.exe</strong></td><td>Our tool for generating static hash strings.</td></tr>
<tr><td><strong>bin/localize.exe</strong></td><td>Our tool for generating localization data.</td></tr>
<tr><td><strong>bin/runner.exe</strong></td><td>An executable than can load a The Machinery project and do what Simulate Tab does, but stand-alone. It is copied whenever you Publish a project from within The Machinery.</td></tr>
<tr><td><strong>utils/.clang-format</strong></td><td>The clang-format settings we use to format our code.</td></tr>
<tr><td><strong>utils/pre-commit</strong></td><td>The pre-commit hook we use in our git repository to auto-format the code.</td></tr>
<tr><td><strong>utils/enable-full-dumps.reg</strong></td><td>A registry file that enables full crash dumps (see below).</td></tr>
</tbody></table>
<p>You can use the <em>Download</em> tab inside The Machinery to download sample projects for the engine.</p>
<p>Here's a list of the sample projects that are available:</p>
<table><thead><tr><th>Project</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>Animation</strong></td><td>A sample project that features an animated character.</td></tr>
<tr><td><strong>Creation Graphs</strong></td><td>Sample use of creation graphs.</td></tr>
<tr><td><strong>Gameplay First Person</strong></td><td>A sample first-person game.</td></tr>
<tr><td><strong>Gameplay Interaction System</strong></td><td>A sample first-person game with intractable entities.</td></tr>
<tr><td><strong>Gameplay Third Person</strong></td><td>A sample third-person game.</td></tr>
<tr><td><strong>Modular Dungeon Kit</strong></td><td>A sample modular project that lets you compose dungeon scenes out of modular components.</td></tr>
<tr><td><strong>Physics</strong></td><td>A sample project that demonstrates the use of physics.</td></tr>
<tr><td><strong>Pong</strong></td><td>A sample visual scripting and gameplay project.</td></tr>
<tr><td><strong>Ray Tracing: Hello Triangle</strong></td><td>A sample project showing how to use the ray tracing APIs.</td></tr>
<tr><td><strong>Sound</strong></td><td>A sample project demonstrating sound playback.</td></tr>
<tr><td><strong>All Sample Projects</strong></td><td>A zip containing all sample projects.</td></tr>
</tbody></table>
<p>The <code>All Sample Projects</code> download contains all these projects, and also some sample engine plugins
that can get you started with extending the engine.</p>
<p>Note that some of the content in these projects was created by other people and licensed under
Creative Common or other licenses. See the <code>*-license.txt</code> files in the projects for attribution and
license information.</p>
<p>The editor that is included allows you to:</p>
<ul>
<li>Import various types of DCC assets (FBX, GLTF, etc).</li>
<li>Create simple entities/scenes by placing and arranging assets.</li>
<li>Add scripted behaviors to entities using the visual scripting language in the <em>Entity Graphs</em>.</li>
<li>Add physics collision to objects and modify their physical properties.</li>
<li>Import animations and create advanced animation setups as an <em>Animation State Machine</em>.</li>
<li>Import WAV files and play them or place them on entities.</li>
<li>Run and simulate these behaviors using the <em>Simulate</em> tab.</li>
<li>Extend the engine and the editor with your own plugins that implement new editor tabs, entity components, gameplay code, etc.</li>
<li>Write your own applications, using <em>The Machinery</em> as an SDK.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="logging-in"><a class="header" href="#logging-in">Logging in</a></h2>
<p>When you first run <code>the-machinery.exe</code>, you will encounter a login screen:</p>
<p><img src="https://www.dropbox.com/s/07rcwx7b1pggnxe/sign-in.png?dl=1" alt="Login screen." /></p>
<p>To use the editor, you must log in with an Our Machinery account. If you haven't done so already, press the <em>Sign Up</em> button to create an account, or go directly to https://ourmachinery.com/sign-up.html.</p>
<p>In addition, you also need to agree to our <a href="https://www.ourmachinery.com/eula.html">EULA</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started-with-a-new-project"><a class="header" href="#getting-started-with-a-new-project">Getting Started with a New Project</a></h1>
<p>This walkthrough shows how to create a new project. It will also show you what comes by default with the Engine.</p>
<p>This part will cover the following topics:</p>
<ul>
<li>Project Pipeline
<ul>
<li>What is the difference between a directory project and a database project?</li>
<li>What is a Scene in The Machinery?</li>
<li>What comes by default with a project?</li>
</ul>
</li>
</ul>
<p>Related videos to these topics are:</p>
<iframe frameborder="0" scrolling="no" marginheight="0" marginwidth="0"width="788.54" height="443" type="text/html" src="https://www.youtube.com/embed/oQGghpCqBhI?autoplay=0&fs=0&iv_load_policy=3&showinfo=0&rel=0&cc_load_policy=0&start=0&end=0&origin=http://ourmachinery.com"></iframe>
<p><strong>Table of Content</strong></p>
<ul>
<li><a href="getting_started/new_project.html#about-projects">About Projects</a></li>
<li><a href="getting_started/new_project.html#about-scenes">About Scenes</a></li>
<li><a href="getting_started/new_project.html#new-project">New Project</a>
<ul>
<li><a href="getting_started/new_project.html#the-core">The Core</a></li>
<li><a href="getting_started/new_project.html#how-to-add-some-life-to-your-project">How to add some life to your project</a></li>
<li><a href="getting_started/new_project.html#project-structure-recommendation">Project Structure Recommendation</a></li>
</ul>
</li>
</ul>
<h1 id="about-projects"><a class="header" href="#about-projects">About Projects</a></h1>
<p>Let us talk about the concept behind projects first. In The Machinery, we have two kinds of projects: A database project and a directory project. The difference between both is that a database project results in one file rather than multiple files. It has the file ending <code>.the_machinery_db</code>. This database will contain all your assets. In contrast, a directory project saves all your assets, etc., in a specified project folder. It is possible to save a database project as a directory project and vise versa. </p>
<blockquote>
<p><strong>Note:</strong> If resaving a Database project as a Directory project or vice versa, be aware that these are two different projects. Hence changes to one will not apply to the other.</p>
</blockquote>
<p><strong>Can I directly add Assets to my project from the File Explorer of my OS?</strong></p>
<p><strong>No</strong>, the editor will not import assets directly added to the project folder via your OS File Explorer. However you can modify The Machinery files (in a directory project) during runtime or before. If you do this the Engine will warn you.</p>
<blockquote>
<p>Changes to the project on disk where detected: [Import] [Ignore]</p>
</blockquote>
<p>More information of this topic <a href="https://github.com/OurMachinery/themachinery-public/issues/435">here</a>.</p>
<p>You handle the main project management steps through the <strong>File Menu.</strong> Such as Create and Save. By default, The Machinery will save your project as a directory project.</p>
<h1 id="about-scenes"><a class="header" href="#about-scenes">About Scenes</a></h1>
<p>In The Machinery, we do not have a concept of scenes in the traditional sense. All we have are Entities. Therefore any Entity can function as a scene. All you need is to add child entities to a parent Entity. The Editor will remember the last opened Entity. 
When publishing a Game, the Engine will ask you to select your &quot;world&quot; entity. You can decide to choose any of your entities as &quot;world&quot; Entity.</p>
<blockquote>
<p>For more information on publishing, check <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/editing_workflows/publish.html">here</a>.</p>
</blockquote>
<h1 id="new-project"><a class="header" href="#new-project">New Project</a></h1>
<p>After the Machinery has been launched for the first time and the login was successful, the Engine will automatically show you a new empty project. If you do not have an account, you can create an account for free <a href="https://ourmachinery.com/sign-up.html">here</a>, or if you had any trouble, don't hesitate to get in touch with us <a href="mailto:ping@ourmachinery.com">here</a>. </p>
<p>At any other point in time, you can create a new project via <strong>Files → New Project.</strong></p>
<p>A new project is not empty. It comes with the so-called &quot;<strong>Core</strong>,&quot; a collection of valuable assets. They allow you to start your project quickly. Besides the <em>Core</em>, the project will also contain a default World Entity, functioning as your current scene. By default, the world entity includes 2 child entities: <em>light and post_process</em>. Those child entities are instances of prototypes. </p>
<blockquote>
<p>A prototype in The Machinery is an entity that has been saved as an Asset. Prototypes are indicated by yellow text in the Entity Tree View. </p>
<p>For more information about Prototypes, click <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/editing_workflows/prototypes.html">here</a>.</p>
</blockquote>
<p><img src="https://paper-attachments.dropbox.com/s_09462F237550F87F4C86951FAA779F713337E632E917FE6E6B8E3406BD58F125_1615455893513_image.png" alt="the content of the world entity" /></p>
<h3 id="the-core"><a class="header" href="#the-core">The Core</a></h3>
<p>Let us discuss the Core a bit. As mentioned before, the Core contains a couple of useful utilities. They are illustrating the core concepts of the Engine, and they are a great starting point. They can be found in the Asset browser under the core folder:</p>
<p><img src="https://paper-attachments.dropbox.com/s_09462F237550F87F4C86951FAA779F713337E632E917FE6E6B8E3406BD58F125_1615456601483_image.png" alt="" /></p>
<p>A content overview of the core folder and its subfolders may looks like this:</p>
<ul>
<li>
<p>A light entity</p>
</li>
<li>
<p>A camera entity</p>
</li>
<li>
<p>A post-processing stack entity (named post-process in the world entity)</p>
</li>
<li>
<p>A default light environment entity</p>
</li>
<li>
<p>A post-processing volume entity</p>
</li>
<li>
<p>A default world entity (the blueprint of the world entity)</p>
</li>
<li>
<p>A bunch of helpful geometry entities. They are in the geometry folder.</p>
<ul>
<li>A sphere entity</li>
<li>A box entity</li>
<li>A plane entity</li>
<li>as well as their geometry material</li>
</ul>
</li>
<li>
<p>A bunch of default creation graphs is in the folder creation_graphs</p>
<ul>
<li>import-image</li>
<li>DCC-mesh</li>
<li>editor-icon</li>
<li>drop-image</li>
<li>DCC-material</li>
<li>DCC-image</li>
</ul>
</li>
</ul>
<h2 id="how-to-add-some-life-to-your-project"><a class="header" href="#how-to-add-some-life-to-your-project">How to add some life to your project</a></h2>
<p>All gameplay can be written in C or a C in any binding language such as C++ or Zig. You can also create gameplay code via the Entity Graph. The Entity Graph would live inside of a Graph Component. You can add that to an Entity. </p>
<p>You can find more information about gameplay coding in the <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/gameplay_coding/index.html">&quot;Gameplay Coding&quot; Section</a></p>
<h2 id="project-structure-recommendation"><a class="header" href="#project-structure-recommendation">Project Structure Recommendation</a></h2>
<p>It is recommended to separate your gameplay source code, plugin code from the actual project and store them in a separate folder.</p>
<pre><code>my_project/game_project // the directory project
my_project/game_plugins // the main folder for all your gameplay code, plugins
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="first-gameplay-project"><a class="header" href="#first-gameplay-project">First Gameplay Project</a></h1>
<p>This walkthrough shows how you make a simple scene via the Entity Graph.</p>
<p>This part will cover the following topics:</p>
<ul>
<li>How to create with the visual scripting language (The Entity Graph) a simple playable</li>
</ul>
<p><strong>Table of Content</strong></p>
<ul>
<li><a href="getting_started/first_gameplay_project.html#how-to-add-some-life-to-your-project">How to add some life to your project</a></li>
<li><a href="getting_started/first_gameplay_project.html#add-some-movement">Add some movement</a></li>
<li><a href="getting_started/first_gameplay_project.html#add-physics-based-movement">Add physics-based movement</a></li>
<li><a href="getting_started/first_gameplay_project.html#what-is-next">What is next?</a></li>
</ul>
<h2 id="how-to-add-some-life-to-your-project-1"><a class="header" href="#how-to-add-some-life-to-your-project-1">How to add some life to your project</a></h2>
<p>Let us create a new project and than add some gameplay to it. Before this, let us define a goal:
<em>This part aims to create a plane and a cube that we can move with W on this plane.</em></p>
<p>It requires multiple steps:</p>
<ul>
<li>Add a plane to the Scene</li>
<li>Add a box to the Scene</li>
<li>Add a camera</li>
<li>Make the box and the plane physical so the box cannot fall through</li>
<li>Add an Entity graph for the movement</li>
</ul>
<p>The first one is to add a plane to our Scene. As we remember in <em>Core</em> in the folder <em>geometry</em>, we have a plane entity. All we need to do is drag it into the Scene and scale it a bit up.</p>
<p><img src="https://paper-attachments.dropbox.com/s_09462F237550F87F4C86951FAA779F713337E632E917FE6E6B8E3406BD58F125_1615459641040_add_plane.gif" alt="Open the core/geometry folder and add the plane.entity to the scene by dragging it into the scene" /></p>
<p>The next step is as straightforward as the first step. We repeat what we did before and drag and drop the box from the geometry folder into the scene tab. After this, we can see what happens in the simulation. To start the simulation and open the simulation tab, you need to click on the &quot;play&quot; button.</p>
<p><img src="https://paper-attachments.dropbox.com/s_09462F237550F87F4C86951FAA779F713337E632E917FE6E6B8E3406BD58F125_1615460126086_image.png" alt="" /></p>
<p>The moment the simulation tab opens, the simulation starts. As you might have guessed, nothing happens. You can navigate in the tab by using the AWSD keys if no custom camera is selected. Also, we can pause, reset the current simulation or increase the simulation speed.</p>
<p><img src="https://paper-attachments.dropbox.com/s_09462F237550F87F4C86951FAA779F713337E632E917FE6E6B8E3406BD58F125_1615460267868_image.png" alt="Pause, reset and increase simulation speed" /></p>
<p>Let us go back to the scene tab and add some more exciting things. The next point of our task list is to add physics. To make our entities aware of physics, we need to add the Physics Shape and Physics Body Component to the corresponding entities. 
In this case, the plane should have the Physics shape component that we set as a plane shape, and the box should have the physics shape component and the physics body component. 
Adding a component to an entity can be done either through right-click on and then <strong>Add Component</strong> via the Entity tree or the property tab and the Add component button. It is also possible to select an entity in the Entity Tree and use Space.</p>
<p><img src="https://paper-attachments.dropbox.com/s_09462F237550F87F4C86951FAA779F713337E632E917FE6E6B8E3406BD58F125_1615461868389_image.png" alt="box entity" />
<img src="https://paper-attachments.dropbox.com/s_09462F237550F87F4C86951FAA779F713337E632E917FE6E6B8E3406BD58F125_1615461884406_image.png" alt="plane entity" /></p>
<p>To visualize the box shape or the plane shape, we can use the visualization menu in either the scene or simulation tab.</p>
<p><img src="https://paper-attachments.dropbox.com/s_09462F237550F87F4C86951FAA779F713337E632E917FE6E6B8E3406BD58F125_1615462081977_image.png" alt="" /></p>
<p>When the simulation starts, the box - if placed above the plane - will fall on the plane. Isn't this already more exciting?</p>
<h2 id="add-some-movement"><a class="header" href="#add-some-movement">Add some movement</a></h2>
<p>The next step is to make the box move. There are two approaches we could do a physicals-based movement or just a placement change. We are starting with the simpler option: Placement Change.</p>
<p>We need to add Graph Component to the box entity. (We could also add it to any other entity or the world entity, but we add it to the box for simplicity and organization's sake add it to the box).</p>
<p><img src="https://paper-attachments.dropbox.com/s_09462F237550F87F4C86951FAA779F713337E632E917FE6E6B8E3406BD58F125_1615462362939_image.png" alt="Add Menu opened via right click “Add Component”" /></p>
<p>When the Graph component has been added, all we need is to double-click the Component, and the Graph Editor opens.</p>
<p><img src="https://paper-attachments.dropbox.com/s_09462F237550F87F4C86951FAA779F713337E632E917FE6E6B8E3406BD58F125_1615462398554_image.png" alt="" /></p>
<p>The Graph Editor View is empty. We can add new nodes via pressing Space or right-click a new node. It opens the node adding a menu. In there, we can search for nodes.</p>
<p><img src="https://paper-attachments.dropbox.com/s_09462F237550F87F4C86951FAA779F713337E632E917FE6E6B8E3406BD58F125_1615462451823_image.png" alt="" /></p>
<p>The Entity Graph is an event-based Visual Scripting Language. It means events will trigger actions. </p>
<p>There are three main events we should use for a particular type of action:</p>
<ul>
<li>Init Event - This gets called when the Graph component gets initialized. The perfect place to set up variables etc.</li>
<li>Tick Event - For all actions that need to happen on Tick (Be aware that this might influence your game performance if you do expensive things always on tick)</li>
<li>Terminate Event - For all actions that need to happen when the Component gets removed. It mainly happens when the Entity gets destroyed.</li>
</ul>
<p>You can also create custom events and listen to them. You can define those events in the graph itself or in C.</p>
<p>Our first iteration will use changing the placement of our box whenever we use the key <code>W</code>. The Machinery input system is based on polling rather than on events. 
We can check if key was pressed via the &quot;Key Poll&quot; node needs to be checked every frame. Therefore a tick event is a need. The &quot;Key Poll&quot; node requires the specify the key and returns a Boolean (true/false) if a key has been pressed, is down, released, or up.
It leads to the following setup:</p>
<p><img src="https://paper-attachments.dropbox.com/s_09462F237550F87F4C86951FAA779F713337E632E917FE6E6B8E3406BD58F125_1615463509298_image.png" alt="" /></p>
<p>In this setup on tick, it's being checked if the key &quot;w&quot; is down. If that is the case, the graph will execute the logic. </p>
<p>What is the actual logic? The actual logic is </p>
<ol>
<li>to get the Entity</li>
<li>get its transform</li>
<li>get the components of the transform (split the vector in x,y,z)</li>
<li>manipulate the x value</li>
<li>set the new transform to the Entity</li>
</ol>
<p>In the Entity Graph, any entity of the current Scene can be referenced by name. It 
happens via the &quot;Scene Entity&quot; node. </p>
<blockquote>
<p>If no name is provided, it will return the graph components Entity.</p>
</blockquote>
<p><img src="https://paper-attachments.dropbox.com/s_09462F237550F87F4C86951FAA779F713337E632E917FE6E6B8E3406BD58F125_1615463752914_image.png" alt="" /></p>
<p>The return type is an Entity. When we drag the wire into the void, the Add Node menu will suggest only nodes which take the Entity as input:</p>
<p><img src="https://paper-attachments.dropbox.com/s_09462F237550F87F4C86951FAA779F713337E632E917FE6E6B8E3406BD58F125_1615463814348_image.png" alt="With expanded Entity Category" /></p>
<p>We should connect the entity wire with a Get Transform node to get the world transform. Then the transform position should be split into its components. After this, component X should be modified by adding 10 * delta time.</p>
<p><img src="https://paper-attachments.dropbox.com/s_09462F237550F87F4C86951FAA779F713337E632E917FE6E6B8E3406BD58F125_1615463996352_image.png" alt="" /></p>
<p>To get the delta time, all that is needed is to add the delta time node and multiple its float value with 10.</p>
<p><img src="https://paper-attachments.dropbox.com/s_09462F237550F87F4C86951FAA779F713337E632E917FE6E6B8E3406BD58F125_1615464050098_image.png" alt="" /></p>
<p>When all this is complete, we should set the position of the Entity to the new value. First, a new position vector needs to be constructed by adding the old values to it and then the new modified value.</p>
<p><img src="https://paper-attachments.dropbox.com/s_09462F237550F87F4C86951FAA779F713337E632E917FE6E6B8E3406BD58F125_1615464121876_image.png" alt="" /></p>
<p>The next step is to tell the Entity to use this position instead of the old one. This happens through the Set Transform node.</p>
<p><img src="https://paper-attachments.dropbox.com/s_09462F237550F87F4C86951FAA779F713337E632E917FE6E6B8E3406BD58F125_1615464271230_image.png" alt="" /></p>
<blockquote>
<p>Note that we leave all the other things as they were. It means they remain as before the change.</p>
</blockquote>
<p>If we simulate the Scene now, the box moves, but it won't fall into the void if we move it to beyond the plane. It was to be expected because the physics system has not been updated, and therefore the velocity has not changed.</p>
<h2 id="add-physics-based-movement"><a class="header" href="#add-physics-based-movement">Add physics-based movement</a></h2>
<p>To make the box move with the physics system, we can use the node &quot;PhysX Push&quot;:</p>
<p><img src="https://paper-attachments.dropbox.com/s_09462F237550F87F4C86951FAA779F713337E632E917FE6E6B8E3406BD58F125_1615465150791_image.png" alt="" /></p>
<p>The node will move the box by applying velocity to it.</p>
<h2 id="what-is-next"><a class="header" href="#what-is-next">What is next?</a></h2>
<p>If you are more interested in physics, download the physics sample via the download tab in that project, you will learn more about the use of physics in the Engine.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sample-projects"><a class="header" href="#sample-projects">Sample Projects</a></h1>
<p>You can download any sample project you like from our website:  <a href="https://ourmachinery.com/samples.html">OurMachinery: Samples</a>. Alternatively you find them under <strong>Help &gt; Download Sample Projects</strong> in the main menu. After you have downloaded them you can open them via the <em>Download Tab</em> or directly from the hard drive.</p>
<p>A few sample projects are coming by default with the Engine, you find them in the root folder under <code>samples/</code>. If you are interested in how our tools work you can look their source code up in the <code>code/</code> folder.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h1>
<p>This section addresses common problems that can arise when using The Machinery. </p>
<h2 id="windows-10-editor"><a class="header" href="#windows-10-editor">Windows 10 Editor</a></h2>
<p>When it comes to crashes on Windows which you cannot debug yourself. You can enable a full crash dumb via the following file <code>utils/enable-full-dumps.reg</code>. The dumps can be found in the folder <code>AppData\Local\The Machinery</code> and then in the  <code>CrashDumps</code> folder. In case of a error report it can be very helpful to provide access to the crash dump. You can submit bugs on our public <a href="https://github.com/OurMachinery/themachinery-public/issues">GitHub issues page</a>. Please do not forget to mention your current Engine version.</p>
<p>In order to obtain log files you have to go to the same folder where you can find the CrashDumps (<code>**AppData\Local**``\The Machinery</code>) just this time you can find them in the <code>Logs</code> folder.</p>
<h2 id="tmbuild-cannot-find-build-tools"><a class="header" href="#tmbuild-cannot-find-build-tools">tmbuild cannot find build tools</a></h2>
<p>In case of a none typical installation of Visual Studios you have to provide to tmbuild the correct environment variables: <code>TM_VS2017_DIR</code> or <code>TM_VS2019_DIR</code>. They need to point to the root directory of your Visual Studio installation.</p>
<h2 id="graphics"><a class="header" href="#graphics">Graphics</a></h2>
<p>In case of a crash you will get an error message, this will give some information about the details of the crash. The first step in a Vulkan related crash is to update your graphics drivers. If this didn’t help then please report the issue to us with the following information.</p>
<ul>
<li>The error message you got when the crash happened, this should include file information and a Vulkan error code, it’s vital to share these.</li>
<li>The log file, see the previous section on how to obtain this.</li>
<li>A crash dump file, see the previous section on how to obtain this.</li>
</ul>
<p>You can submit bugs on our public <a href="https://github.com/OurMachinery/themachinery-public/issues">GitHub issues page</a>. Please do not forget to mention your current Engine version.</p>
<h2 id="where-to-report-bugs-or-feedback"><a class="header" href="#where-to-report-bugs-or-feedback">Where to report bugs or feedback</a></h2>
<ol>
<li>If you have any problems running the software, encounter crashes, etc, report them on our <a href="https://github.com/OurMachinery/themachinery-public/issues">public bug tracker</a> as soon as possible. We will fix bugs as soon as we can and provide updated executables for download on the website.</li>
<li>If you have other feedback or questions, post them on our <a href="https://github.com/OurMachinery/themachinery-public/discussions">forum</a>. We appreciate candid, honest opinions.</li>
</ol>
<p>Note that you need to create a separate login to log in to the forum. (We might unify the logins in the future.)
You can also drop in on our <a href="https://discord.gg/SHHSZaH">Discord Server</a>. You will frequently find us there, answering questions. We'll pay special attention on Thursdays.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-machinery-for-unity-devs"><a class="header" href="#the-machinery-for-unity-devs">The Machinery for Unity Dev's</a></h1>
<p>When migrating from Unity to The Machinery, there are a few things that are different.</p>
<p><strong>Quick Glossary</strong></p>
<p>The following table contains common Unity terms on the left and their The Machinery equivalents (or rough equivalent) on the right.</p>
<table><thead><tr><th>Unity</th><th>The Machinery</th></tr></thead><tbody>
<tr><td>GameObjects</td><td>Are composed of Entities and Components and Systems</td></tr>
<tr><td>Prefabs</td><td><a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/editing_workflows/prototypes.html">Prototypes</a></td></tr>
<tr><td>Materials, Shaders, Textures, Particle Effects, Mesh, Geometry, Shader Graph, Material Editor</td><td><a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/creation_graphs/concept.html">Creation Graphs</a></td></tr>
<tr><td><strong>UI</strong></td><td></td></tr>
<tr><td>Hierarchy Panel</td><td><a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/the_editor/entity_tree_tab.html">Entity Tree</a></td></tr>
<tr><td>Inspector</td><td><a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/the_editor/properties_tab.html">Properties Tab</a></td></tr>
<tr><td>Project Browser</td><td><a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/the_editor/asset_browser.html">Asset Browser</a></td></tr>
<tr><td>Scene View</td><td><a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/the_editor/asset_browser.html">Scene Tab</a></td></tr>
<tr><td><strong>Programming</strong></td><td></td></tr>
<tr><td>Blot</td><td><a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/editing_workflows/visual-scripting.html">Entity Graph</a></td></tr>
<tr><td>C#</td><td>C</td></tr>
</tbody></table>
<h2 id="questions-you-might-have"><a class="header" href="#questions-you-might-have">Questions you might have</a></h2>
<p><strong>Where are my GameObjects?</strong></p>
<p>The Machinery has no concept of GameObjects in the sense as Unity does. The Engine is based around Entities and Components. In the game world, not the editor, everything lives within the Entity Component System (ECS). To be exact, it lives within the Entity Context, an isolated world of entities. Your GameObjects are split into data and Behaviour. </p>
<p>You would usually couple your logic together with data in your C# MonoBehaviour scripts. In The Machinery, you separated them into Components and Systems / Engines. They represent your data and Systems or Engines that represent your Behaviour. They operate on multiple entities at the same time. Each Entity Context (the isolated world of Entities) has several systems/engines registered to them.</p>
<p><strong>What is the difference between a System and an Engine?</strong></p>
<p>An Engine update is running on a subset of components that possess some set of components. Some entity component systems are referred to as <em>systems</em> instead, but we choose <em>Engine</em> because it is less ambiguous.</p>
<p>On the other hand, a system is an update function that runs on the entire entity context. Therefore you can not filter for specific components.</p>
<p><strong>Where are my Prefabs?</strong></p>
<p>What Unity calls Prefabs is more or less what we call <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/editing_workflows/prototypes.html">Prototypes</a>. Our prototype system allows entity assets to be used inside other entities. Therefore, you can create an entity asset that represents a room and then creates a house entity that has a bunch of these room entities placed into it. For more information on Prototypes, check out its <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/editing_workflows/prototypes.html">Prototypes</a>.</p>
<p><strong>How do I script?</strong></p>
<p>The Machinery supports two ways of gameplay coding by default:</p>
<ol>
<li>using our Visual Scripting Language (<a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/editing_workflows/visual-scripting.html">Entity Graph</a>)</li>
<li>using our C API's to create your gameplay code. This way, you can create your Systems/Engines to handle your gameplay.</li>
</ol>
<p>You do not like C? Do not worry! You can use C++, Zig, Rust, or any other language that binds to C.</p>
<p><strong>Where are my Materials, Shaders, Textures, Particle Effects?</strong></p>
<p>All of these can be represented via the the <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/creation_graphs/concept.html">Creation Graphs</a>.</p>
<p><strong>Project data?</strong></p>
<p>The Machinery supports two types of Project formats:</p>
<ol>
<li>The Directory Project (Default)</li>
</ol>
<p>A Source control and human-friendly project format in which your project is stored on Disk in separate files (text and binary for binary data)</p>
<ol>
<li>The Database Project</li>
</ol>
<p>A single binary file project. It will contain all your assets and data. This format is mainly used at the end to pack your data for the shipping/publishing process.</p>
<p><strong>Where do I put my assets?</strong></p>
<p>At this point in time, you can only drag &amp; drop your assets via the Asset Browser as well as via the Import Menu. See more in the section about importing assets. <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/editing_workflows/import_assets.html">How to import assets</a></p>
<p><strong>What are common file formats supported?</strong></p>
<table><thead><tr><th align="left">Asset Type</th><th align="left">Supported Formats</th></tr></thead><tbody>
<tr><td align="left">3D</td><td align="left">.fbx, .obj, .gltf</td></tr>
<tr><td align="left">Texture</td><td align="left">.png, .jpeg, .bmp ,.tga, .dds</td></tr>
<tr><td align="left">Sound</td><td align="left">.wav</td></tr>
</tbody></table>
<p>Our importer is based on Assimp. Therefore we support most things assimp supports. (We do not support .blend files)</p>
<p><strong>Where do my source code files go?</strong></p>
<p>In the Machinery, all we care about is your plugins. Therefore if you want your plugins (tm_ prefixed shared libs.) to be globally accessible, please store them in the /plugins folder of the Engine. An alternative approach is to create plugin_asset in the Engine then your plugin becomes part of your project. </p>
<p>Please check out the introduction to the <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/extending_the_machinery/the_plugin_system.html">Plugin System</a> as well as the  <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/extending_the_machinery/plugin-assets.html">Guide about Plugin Assets</a>.</p>
<p><strong>Using Visual Scripting</strong></p>
<p>Visual Scripting is a perfect solution for in-game logic flow (simple) and sequencing of actions. It is a great system for artists, designers, and visually oriented programmers. It is important to keep in mind that the Visual Scripting language comes with an overhead that you would not pay in C (or any other Language you may use for your gameplay code).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-machinery-for-unreal-4-devs"><a class="header" href="#the-machinery-for-unreal-4-devs">The Machinery for Unreal 4 Dev's</a></h1>
<p>When migrating from Unreal Engine 4 (UE4) to The Machinery, there are a few things that are different.</p>
<p><strong>Quick Glossary</strong></p>
<p>The following table contains common UE4 terms on the left and their The Machinery equivalents (or rough equivalent) on the right.</p>
<table><thead><tr><th>UE4</th><th>The Machinery</th></tr></thead><tbody>
<tr><td>Actor, Pawn</td><td>Are composed of Entities and Components and Systems</td></tr>
<tr><td>Blueprint Class (only the inheritance aspect and that they can represent actors)</td><td><a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/editing_workflows/prototypes.html">Prototypes</a></td></tr>
<tr><td>Material Instance, Shaders, Textures, Particle Effects, Static Mesh, Geometry,Skeletal Mesh, Material Editor</td><td><a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/creation_graphs/concept.html">Creation Graphs</a></td></tr>
<tr><td><strong>UI</strong></td><td></td></tr>
<tr><td>World Outliner</td><td><a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/the_editor/entity_tree_tab.html">Entity Tree</a></td></tr>
<tr><td>Details Panel</td><td><a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/the_editor/properties_tab.html">Properties Tab</a></td></tr>
<tr><td>Content Browser</td><td><a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/the_editor/asset_browser.html">Asset Browser</a></td></tr>
<tr><td>Viewport</td><td><a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/the_editor/asset_browser.html">Scene Tab</a></td></tr>
<tr><td><strong>Programming</strong></td><td></td></tr>
<tr><td>Blueprints</td><td><a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/editing_workflows/visual-scripting.html">Entity Graph</a></td></tr>
<tr><td>C++</td><td>C</td></tr>
</tbody></table>
<h2 id="questions-you-might-have-1"><a class="header" href="#questions-you-might-have-1">Questions you might have</a></h2>
<p><strong>Where are my Actors?</strong></p>
<p>The Machinery has no concept of Actors in the sense as UE4 does. The Engine is based around Entities and Components. In the game world, not the editor, everything lives within the Entity Component System (ECS). To be exact, it lives within the Entity Context, an isolated world of entities. Your Actors are split into data and Behaviour. </p>
<p>You would usually couple your logic together with data in your Actor classes. In The Machinery, you separated them into Components and Systems / Engines. Different behaviour can be achieved via composition rather than via Inheritance.</p>
<p>Components represent data while Systems or Engines represent your behaviour. They operate on multiple entities at the same time. Each Entity Context (the isolated world of Entities) has several systems/engines registered to them.</p>
<p><strong>Where are my Blueprints?</strong></p>
<p>The Machinery supports two ways of gameplay coding by default:</p>
<ol>
<li>using our Visual Scripting Language (<a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/editing_workflows/visual-scripting.html">Entity Graph</a>)</li>
<li>using our C API's to create your gameplay code. This way, you can create your Systems/Engines to handle your gameplay.</li>
</ol>
<p>You do not like C? Do not worry! You can use C++, Zig, Rust, or any other language that binds to C.</p>
<p><strong>What is the difference between a System and an Engine?</strong></p>
<p>An Engine update is running on a subset of components that possess some set of components. Some entity component systems are referred to as <em>systems</em> instead, but we choose <em>Engine</em> because it is less ambiguous.</p>
<p>On the other hand, a system is an update function that runs on the entire entity context. Therefore you can not filter for specific components.</p>
<p><strong>Where are my Material Instance, Shaders, Textures, Particle Effects, Static Mesh, Geometry, Skeletal Mesh, Material Editor?</strong></p>
<p>All of these can be represented via the the <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/creation_graphs/concept.html">Creation Graphs</a>.</p>
<p><strong>Project data?</strong></p>
<p>The Machinery supports two types of Project formats:</p>
<ol>
<li>The Directory Project (Default)</li>
</ol>
<p>A Source control and human-friendly project format in which your project is stored on Disk in separate files (text and binary for binary data)</p>
<ol>
<li>The Database Project</li>
</ol>
<p>A single binary file project. It will contain all your assets and data. This format is mainly used at the end to pack your data for the shipping/publishing process.</p>
<p><strong>Where do I put my assets?</strong></p>
<p>At this point in time, you can only drag &amp; drop your assets via the Asset Browser as well as via the Import Menu. See more in the section about importing assets. <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/editing_workflows/import_assets.html">How to import assets</a></p>
<p><strong>What are common file formats supported?</strong></p>
<table><thead><tr><th align="left">Asset Type</th><th align="left">Supported Formats</th></tr></thead><tbody>
<tr><td align="left">3D</td><td align="left">.fbx, .obj, .gltf</td></tr>
<tr><td align="left">Texture</td><td align="left">.png, .jpeg, .bmp ,.tga, .dds</td></tr>
<tr><td align="left">Sound</td><td align="left">.wav</td></tr>
</tbody></table>
<p>Our importer is based on Assimp. Therefore we support most things assimp supports. (We do not support .blend files)</p>
<p><strong>Where do my source code files go?</strong></p>
<p>In the Machinery, all we care about is your plugins. Therefore if you want your plugins (tm_ prefixed shared libs.) to be globally accessible, please store them in the /plugins folder of the Engine. An alternative approach is to create plugin_asset in the Engine then your plugin becomes part of your project. </p>
<p>Please check out the introduction to the <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/extending_the_machinery/the_plugin_system.html">Plugin System</a> as well as the <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/extending_the_machinery/plugin-assets.html">Guide about Plugin Assets</a>.</p>
<p><strong>Using Visual Scripting</strong></p>
<p>Visual Scripting is a perfect solution for in-game logic flow (simple) and sequencing of actions. It is a great system for artists, designers, and visually oriented programmers. It is important to keep in mind that the Visual Scripting language comes with an overhead that you would not pay in C (or any other Language you may use for your gameplay code).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-editor"><a class="header" href="#the-editor">The Editor</a></h1>
<p>After opening the Engine, you should see the Editor's interface with menus along the top of the interface, and the basic tabs opened. The following image will show you the default engine layout.
Here's a brief description of what you can see:</p>
<p><img src="https://paper-attachments.dropbox.com/s_688CFE67758A45D845E788E6DA05448A2BCF730C2B07FEF2D06AB18D2C46F736_1625426376136_image.png" alt="" /></p>
<ol>
<li>The <strong>Main Menu</strong>: It allows you to navigate through the Engine, such as opening new tabs or import assets</li>
<li>The <strong>Entity Tree</strong> shows a tree view of the entity you are editing. It shows the entity's components and child entities. You start editing an entity by double-clicking it in the asset browser. </li>
<li>The <strong>Scene</strong> shows an editable graphic view of the edited entity. You can manipulate components and child entities by selecting them. Use the <em>Move</em>, <em>Rotate</em>, and <em>Scale</em> gizmos for your desired action.</li>
<li>The <strong>Simulate current scene</strong> button will open the <strong>Simulate</strong> tab that lets you &quot;run&quot; or &quot;simulate&quot; a scene.</li>
<li>The <strong>Properties</strong> tab shows the properties of the currently selected object in the Scene. You can modify the properties by editing them in the properties window.</li>
<li>The <strong>Console</strong> tab shows diagnostic messages from the application.</li>
<li>The <strong>Asset Browser</strong> shows all the assets in the project and enables you to manage them.</li>
<li>The <strong>Preview</strong> shows a preview of the currently selected asset in the asset browser.</li>
</ol>
<p>The Editor is a collection of editing <em>Tabs</em>, each with its specific purpose. You can drag tabs around to rearrange them. When you drag them out of the window, a new window opens. Use the <em>View</em> menu to open new tabs.</p>
<p><img src="https://paper-attachments.dropbox.com/s_688CFE67758A45D845E788E6DA05448A2BCF730C2B07FEF2D06AB18D2C46F736_1625426655184_image.png" alt="" /></p>
<p>Note that you can have multiple tabs of the same type. For example, you can open various <em>Asset Browser</em> tabs to drag assets between them easily. Tabs docked in the same window work together. Therefore if you dock a <em>Preview</em> tab in the same window as an <em>Asset Browser</em>, it will show a preview of the selected asset in that browser. You can create multiple windows to view numerous assets simultaneously:</p>
<p><img src="https://paper-attachments.dropbox.com/s_688CFE67758A45D845E788E6DA05448A2BCF730C2B07FEF2D06AB18D2C46F736_1625427376387_image.png" alt="" /></p>
<p><strong>Editor layouts</strong></p>
<p>You can rearrange the Editor layouts by dragging tabs around in the Editor. The best structure for the Editor depends on what you are doing and your personal preferences. You can save layouts via the Window Menu. It is also possible to restore your layout to the default one or load a custom-defined one in this menu.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="about-tabs"><a class="header" href="#about-tabs">About Tabs</a></h2>
<p>The Machinery is based around a collection of editing <em>Tabs</em>, each with its specific purpose. You can drag the tabs around to rearrange them. Use the <em>Tab</em> menu to open new tabs. It is possible to have multiple tabs of the same type.</p>
<p><strong>Table of Content</strong></p>
<ul>
<li><a href="the_editor/tabs.html#about-tab-wells">About Tab-Wells</a></li>
<li><a href="the_editor/tabs.html#pinning-tabs">Pinning tabs</a>
<ul>
<li><a href="the_editor/tabs.html#pinning-options">Pinning options</a></li>
</ul>
</li>
<li><a href="the_editor/tabs.html#keyboard-bindings">Keyboard bindings</a></li>
</ul>
<h2 id="about-tab-wells"><a class="header" href="#about-tab-wells">About Tab-Wells</a></h2>
<p>Windows in The Machinery have a root <strong>tab-well</strong> covering the whole window. A tab-wells are rectangular areas containing one or more tabs. You can split them either horizontally or vertically to form two-child tab-wells. Also, you can switch around tabs within a tab-well via the keyboard using Ctrl + 1-9 or via Ctrl Page Up/Down.</p>
<p><img src="https://paper-attachments.dropbox.com/s_688CFE67758A45D845E788E6DA05448A2BCF730C2B07FEF2D06AB18D2C46F736_1608290650481_keyboard-record.gif" alt="" /></p>
<h2 id="pinning-tabs"><a class="header" href="#pinning-tabs">Pinning tabs</a></h2>
<p>You can also pin tabs to the current content or other settings with the <em>pin</em> icon.</p>
<p><img src="https://paper-attachments.dropbox.com/s_688CFE67758A45D845E788E6DA05448A2BCF730C2B07FEF2D06AB18D2C46F736_1625427774726_image.png" alt="" /></p>
<p>It is also possible to use the context menu if you click on the tab label:</p>
<p><img src="https://paper-attachments.dropbox.com/s_688CFE67758A45D845E788E6DA05448A2BCF730C2B07FEF2D06AB18D2C46F736_1625427822543_image.png" alt="right click on the tab label will show this." /></p>
<h3 id="pinning-options"><a class="header" href="#pinning-options">Pinning options</a></h3>
<p>In the context menu, you have more options for pinning. These allow you to manage and arrange the window layout in a way that suits your workflow. The following table will show all the possible options:</p>
<table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody>
<tr><td>Pin via icon ⚲</td><td>Will pin the tab to the current shown content</td></tr>
<tr><td>Pin to View 🗖</td><td>This Pins the tab's content to another tab view that is currently open in the current window. You can pin a tab to multiple other tabs at the same time.</td></tr>
<tr><td>Pin to Window 🗗</td><td>It pins the current tab to the selected window. For example, if you pin the Properties tab to Window 2. and choose an asset from the Asset Browser, the properties tab in Window 1. will display the selected asset.</td></tr>
</tbody></table>
<p>Besides, it is possible to extend the Engine with custom tabs. You can do this via the <strong>File → New Plugin → Editor Tabs.</strong> How to write your custom tab is out of the scope of this article but is covered <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/extending_the_machinery/write-a-plugin.html">here</a>.</p>
<h2 id="keyboard-bindings"><a class="header" href="#keyboard-bindings">Keyboard bindings</a></h2>
<table><thead><tr><th>Key</th><th>Description</th></tr></thead><tbody>
<tr><td>Ctrl + Tab</td><td>Switch between tabs</td></tr>
<tr><td>Ctrl + 1-9</td><td>Switch between tabs in current tab well</td></tr>
<tr><td>Ctrl + Page up/Down</td><td>Switch between tabs in current tab well</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="entity-tree-tab"><a class="header" href="#entity-tree-tab"><strong>Entity Tree Tab</strong></a></h1>
<p>The <strong>Entity Tree</strong> shows the hierarchy of the entity you choose to edit. This view allows you to organize and add new entities as well as new components to the entities.</p>
<blockquote>
<p><strong>Note:</strong>  Just be aware that the Entity Tree does not reflect the current runtime state. </p>
</blockquote>
<p>Besides, it is essential to remember is that <em>The Machinery</em> does not have specific <em>Scene</em> assets. A scene in <em>The Machinery</em> is just an entity with a lot of child entities.</p>
<p><img src="https://paper-attachments.dropbox.com/s_688CFE67758A45D845E788E6DA05448A2BCF730C2B07FEF2D06AB18D2C46F736_1625427931504_image.png" alt="" /></p>
<p><strong>Table of Content</strong></p>
<ul>
<li><a href="the_editor/entity_tree_tab.html#how-to-edit-a-scene--entity">How to edit a Scene / Entity</a></li>
<li><a href="the_editor/entity_tree_tab.html#managing-entities">Managing Entities</a>
<ul>
<li><a href="the_editor/entity_tree_tab.html#prototypes-in-the-entity-tree-view">Prototypes in the Entity Tree View</a></li>
<li><a href="the_editor/entity_tree_tab.html#adding-new-child-entities">Adding new child entities</a></li>
<li><a href="the_editor/entity_tree_tab.html#searching-and-changing-the-visibility-of-entities">Searching and changing the visibility of Entities</a></li>
</ul>
</li>
<li><a href="the_editor/entity_tree_tab.html#keyboard-bindings">Keyboard bindings</a></li>
</ul>
<h2 id="how-to-edit-a-scene--entity"><a class="header" href="#how-to-edit-a-scene--entity">How to edit a Scene / Entity</a></h2>
<p>In this tab, you can edit any entity from the current project. To start editing, you can either use <strong>Right Click → Open</strong> or <strong>Double Click</strong> the entity to open them. This action will update the Scene Tab and the entity tree view tab. If you close the Scene Tab, the Entity Tree Tab will display an empty tree.</p>
<h2 id="managing-entities"><a class="header" href="#managing-entities">Managing Entities</a></h2>
<p>A Scene is composed of child Entities and Parent Entities. When you create a new project, it starts with a &quot;world&quot; entity. This entity can be edited and lives as <code>world.entity</code> in your Asset Browser. You can create other Entities that function as your Scene. Any entity in the Asset Browser can serve as your Scene. Later, when publishing your game, you can choose the world entity you like. </p>
<p><img src="https://paper-attachments.dropbox.com/s_688CFE67758A45D845E788E6DA05448A2BCF730C2B07FEF2D06AB18D2C46F736_1625428013195_image.png" alt="" /></p>
<p>Click a parent entity's drop-down arrow (on the left-hand side of its name) to show or hide its children. This action is also possible via the Keyboard: Arrow keys down and up let you navigate through the tree, while Arrow keys left and right allow you to show or hide the entity children. </p>
<h3 id="prototypes-in-the-entity-tree-view"><a class="header" href="#prototypes-in-the-entity-tree-view">Prototypes in the Entity Tree View</a></h3>
<p>The Entity Tree view, prototype instances are shown in yellow to distinguish them from locally owned child entities (which are shown in white).</p>
<p><strong>Prototypes:</strong> Prototypes are just entities that live in the Asset Browser as assets (.entity and the current entity in the Entity Tree View is based upon those entity assets. You can overwrite them in the Entity Tree View and make them unique, but any change to the asset will propagate to the entities based on the original prototype. <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/editing_workflows/prototypes.html">More here</a></p>
<p>If you expand an instance, you will notice that most of its components and child entities are grayed out. They cannot be selected because they are inherited from the prototype, and the prototype controls their values.</p>
<p><img src="https://paper-attachments.dropbox.com/s_688CFE67758A45D845E788E6DA05448A2BCF730C2B07FEF2D06AB18D2C46F736_1625428053926_image.png" alt="The light entity is a instance of a prototype and the Render Component is inherited" /></p>
<p>If the prototype is modified — for example, if we scatter some more props on the floor — those changes reflect everywhere the prototype is placed.</p>
<h3 id="adding-new-child-entities"><a class="header" href="#adding-new-child-entities">Adding new child entities</a></h3>
<p>When you want to reorder one entity as a child to another, you can drag and drop them on them onto each other.</p>
<p><img src="https://paper-attachments.dropbox.com/s_688CFE67758A45D845E788E6DA05448A2BCF730C2B07FEF2D06AB18D2C46F736_1625428282189_sort_entity_tree.gif" alt="" /></p>
<p>You can add new children to an Entity through right-click and <em>&quot;Add Child Entity&quot;</em> or dragging an Entity Asset from the Asset Browser into the Entity Tree View.</p>
<h3 id="searching-and-changing-the-visibility-of-entities"><a class="header" href="#searching-and-changing-the-visibility-of-entities">Searching and changing the visibility of Entities</a></h3>
<p>You can search for entities via the filter icon, and you can hide all the components with the little <em>gear</em> icon next to it. You can also change the visibility of each entity via the little <em>eye</em> icon next to its name. If you change the visibility, you will hide the entity in the Scene View.</p>
<p><img src="https://paper-attachments.dropbox.com/s_688CFE67758A45D845E788E6DA05448A2BCF730C2B07FEF2D06AB18D2C46F736_1625428346946_image.png" alt="" /></p>
<p>The Lock Icon makes sure you cannot select the entity in the Scene Tab. It can help to avoid miss-clicking.</p>
<h2 id="keyboard-bindings-1"><a class="header" href="#keyboard-bindings-1">Keyboard bindings</a></h2>
<table><thead><tr><th>Key</th><th>Description</th></tr></thead><tbody>
<tr><td>Arrow Up &amp; Down</td><td>Navigate through the tree</td></tr>
<tr><td>Arrow Left &amp; Right</td><td>Expand or collapse the selected Entities</td></tr>
<tr><td>F</td><td>Selected Entity will be framed in Scene Tab</td></tr>
<tr><td>H</td><td>Selected Entity will be hidden in Scene Tab</td></tr>
<tr><td>F2</td><td>Start renaming the selected Entity</td></tr>
<tr><td>F3</td><td>Adds child entity to parent</td></tr>
<tr><td>Space</td><td>Opens Add Component menu to selected Entity</td></tr>
<tr><td>Space + Shift</td><td>Open Add Entity Menu to add child entity</td></tr>
<tr><td>CTRL + L</td><td>Moves selected entities one level up in the Entity Hierarchy</td></tr>
<tr><td>CTRL + F</td><td>Opens the filter / search menu</td></tr>
<tr><td>CTRL + H</td><td>Don’t show components in the Entity Tree</td></tr>
<tr><td>CTRL + D</td><td>Duplicates selected Entities</td></tr>
<tr><td>CTRL + C</td><td>Copies Entities</td></tr>
<tr><td>CTRL + V</td><td>Pastes Entities</td></tr>
<tr><td>CTRL + X</td><td>Cuts Entities</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scene-tab"><a class="header" href="#scene-tab">Scene Tab</a></h1>
<p>The <strong>Scene</strong> tab is the view into your world. You can use the <strong>Scene tab</strong> to select, manipulate assets, and position new ones in your world. </p>
<p><strong>Table of Content</strong></p>
<ul>
<li><a href="the_editor/scene_tab.html#navigate-through-your-scene">Navigate through your Scene</a>
<ul>
<li><a href="the_editor/scene_tab.html#opening-an-entity-asset">Opening an Entity Asset</a></li>
</ul>
</li>
<li><a href="the_editor/scene_tab.html#working-in-the-scene">Working in the Scene</a>
<ul>
<li><a href="the_editor/scene_tab.html#box-select-in-the-scene-tab">Box Select in the Scene Tab</a></li>
</ul>
</li>
<li><a href="the_editor/scene_tab.html#simulate-your-scene-or-change-visualization-modes">Simulate your Scene or change visualization modes</a></li>
<li><a href="the_editor/scene_tab.html#keyboard-bindings">Keyboard bindings</a></li>
</ul>
<h2 id="navigate-through-your-scene"><a class="header" href="#navigate-through-your-scene">Navigate through your Scene</a></h2>
<p>The Scene Tab allows for different ways of navigating through your world. The primary method of navigating through the Scene is via the mouse and the keyboard. </p>
<p><strong>Movement</strong></p>
<ul>
<li><strong>Middle Mouse Button:</strong> Keep pressed down to move through the scene.</li>
<li><strong>Left Mouse Button:</strong> Keep pressed down to rotate in the Scene by rotating the mouse. If you keep the mouse pressed so you can also use <strong>WASD</strong> to move through the Scene. To increase or decrease the movement speed, you need to move the mouse wheel.</li>
</ul>
<p><strong>Zoom in</strong></p>
<ul>
<li><strong>Mouse Wheel</strong>: To zoom in, you can zoom in or out via the mouse wheel.</li>
</ul>
<p><strong>Frame Entities or the scene</strong></p>
<ul>
<li><strong>Press F</strong>: To frame the currently selected entity or if you have nothing selected the Scene. Alternatively, you can double click on an entity the Entity Tree Tab.</li>
</ul>
<h3 id="opening-an-entity-asset"><a class="header" href="#opening-an-entity-asset">Opening an Entity Asset</a></h3>
<p>Through a double click on an Entity Asset in the Asset Browser, you will load the asset. If you want to move between previously loaded entities, the toolbar provides a back and forth navigation option.</p>
<p><img src="https://paper-attachments.dropbox.com/s_688CFE67758A45D845E788E6DA05448A2BCF730C2B07FEF2D06AB18D2C46F736_1625428401593_image.png" alt="" /></p>
<p>Alternatively, you can use the context menu of the tab label and navigate through the previously focused entities.</p>
<p><img src="https://paper-attachments.dropbox.com/s_688CFE67758A45D845E788E6DA05448A2BCF730C2B07FEF2D06AB18D2C46F736_1625428456420_image.png" alt="" /></p>
<h2 id="working-in-the-scene"><a class="header" href="#working-in-the-scene">Working in the Scene</a></h2>
<p>The Scene tab comes with tools that allow for editing and moving entities in the current Scene.</p>
<p><img src="https://paper-attachments.dropbox.com/s_688CFE67758A45D845E788E6DA05448A2BCF730C2B07FEF2D06AB18D2C46F736_1625428493292_image.png" alt="" /></p>
<p>The main tools you will be working with in to edit the scene are the</p>
<ul>
<li><strong>Select Tool</strong>: To select Entities in the Scene</li>
<li><strong>Move Tool</strong>: For moving Entities in the Scene</li>
<li><strong>Rotate Tool</strong>: Rotates selected Entities</li>
<li><strong>Scale Tool</strong>: Scales Entities</li>
<li><strong>Snapping:</strong> Enable or disable snapping and the snap distance</li>
</ul>
<p>You can manipulate the Grid via <strong>Main Menu → Scene → Grid Settings</strong>.</p>
<p>If you do not like the layout of the current toolbar, you can change its layout by dragging them around.</p>
<p><img src="https://paper-attachments.dropbox.com/s_688CFE67758A45D845E788E6DA05448A2BCF730C2B07FEF2D06AB18D2C46F736_1625428649231_new_order_toolbars.gif" alt="" /></p>
<h3 id="box-select-in-the-scene-tab"><a class="header" href="#box-select-in-the-scene-tab">Box Select in the Scene Tab</a></h3>
<p>The Machinery now supports a long awaited feature — box selection.</p>
<p>To select multiple items in the scene, simply drag out a selection rectangle with the mouse:</p>
<p><img src="https://paper-attachments.dropbox.com/s_AF44CABDD4BF19FA7D54C2D4574B155CAAE2ED895AFB490AC3671972A5F81DC2_1617220755615_image.png" alt="Box dragging to select multiple entities." /></p>
<p>The touched entities will become selected in the scene:</p>
<p><img src="https://paper-attachments.dropbox.com/s_AF44CABDD4BF19FA7D54C2D4574B155CAAE2ED895AFB490AC3671972A5F81DC2_1617220785668_image.png" alt="The resulting selection." /></p>
<h2 id="simulate-your-scene-or-change-visualization-modes"><a class="header" href="#simulate-your-scene-or-change-visualization-modes">Simulate your Scene or change visualization modes</a></h2>
<p>You can simulate your current Scene and manipulate the way your Scene's visualization with this toolbar:</p>
<p><img src="https://paper-attachments.dropbox.com/s_688CFE67758A45D845E788E6DA05448A2BCF730C2B07FEF2D06AB18D2C46F736_1625428527987_image.png" alt="" /></p>
<ul>
<li>The simulation button ▶: Simulates your scene in a new tab if no simulation tab is open.</li>
<li>The camera button 📷: Allows you to change the camera in your viewport.</li>
<li>The light button 💡:  Use Lighting Environment Asset. Will create a lighting environment in the scene. Automatically enabled for assets with no light.</li>
<li>Visualize button: Allows to enable more visualization modes.
<ul>
<li>Lighting Model
<ul>
<li>Visualize Albedo</li>
<li>Visualize Normals</li>
<li>Visualize Specular</li>
<li>Visualize Roughness</li>
<li>Visualize Shadow Maps</li>
<li>Visualize Pixel Velocity</li>
<li>Visualize NaN / INF</li>
<li>Show as Overlay</li>
</ul>
</li>
<li>Exposure
<ul>
<li>Visualize EV100</li>
<li>Visualize Histogram</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="keyboard-bindings-2"><a class="header" href="#keyboard-bindings-2">Keyboard bindings</a></h2>
<table><thead><tr><th>Key</th><th>Description</th></tr></thead><tbody>
<tr><td>F</td><td>Frames either the current scene if nothing is selected or the selected objects</td></tr>
<tr><td>G</td><td>Enables and disables the Grid</td></tr>
<tr><td>ESC</td><td>Deselect objects</td></tr>
<tr><td>CTRL + D</td><td>Duplicates selected objects</td></tr>
<tr><td>Shift + Drag with mouse</td><td>Duplicates selected objects</td></tr>
<tr><td>CTRL + C</td><td>Copies object</td></tr>
<tr><td>CTRL + V</td><td>Pastes object</td></tr>
<tr><td>CTRL + X</td><td>Cuts object</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="properties-tab"><a class="header" href="#properties-tab">Properties Tab</a></h1>
<p>The <strong>Properties</strong> tab shows the properties of the currently selected object. You can modify the properties by editing them in the properties window. </p>
<p><img src="https://paper-attachments.dropbox.com/s_688CFE67758A45D845E788E6DA05448A2BCF730C2B07FEF2D06AB18D2C46F736_1625428761738_image.png" alt="" /></p>
<h3 id="use-mathematical-expression"><a class="header" href="#use-mathematical-expression">Use mathematical expression</a></h3>
<p>We’ve also have support for mathematical expression to our property editor. So you can now type both numerical values and expressions.</p>
<p>You can use <code>x</code> in the expression to mean whatever value the property had before, so if you type <code>x + 1</code> you will increase the current value by 1.</p>
<p><img src="https://paper-attachments.dropbox.com/s_AF44CABDD4BF19FA7D54C2D4574B155CAAE2ED895AFB490AC3671972A5F81DC2_1617121646846_expressions.gif" alt="Using expressions in the property editor." /></p>
<h3 id="multiple-tabs-with-different-properties"><a class="header" href="#multiple-tabs-with-different-properties">Multiple tabs with different properties</a></h3>
<p>You can have multiple tabs of different properties open if you wish. In this case, it comes very handily that you can pin Properties Tabs to a specific Object. 
Otherwise, the property tab will reflect the next selected object, and you would have multiple times the same thing open. 
You can pin content by clicking the <em>Pin</em> icon on Properties Tab. It will bind the current object to this instance. </p>
<p><img src="https://paper-attachments.dropbox.com/s_688CFE67758A45D845E788E6DA05448A2BCF730C2B07FEF2D06AB18D2C46F736_1625428863969_image.png" alt="Pin the properties tab for the prop floor barrel (module dungeon kit example)" /></p>
<p>Moreover, if you dock a <em>Preview</em> tab in the same window as an <em>Asset Browser</em>, it will show a preview of the selected asset in that browser.</p>
<p><strong>About Prototypes</strong></p>
<p>The Machinery has a prototype system that allows entity assets to be used within each other. Therefore you can create an Entity-Asset that represents a room and then create a house Entity with a bunch of these room entities placed within. 
We call the room asset a <em>prototype</em>, and we call each placed room entity an <em>instance</em> of this prototype. </p>
<p>Any Entity-Asset can be a prototype, with instances of it placed in another entity asset. Note that prototypes are not special assets. More about this <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/editing_workflows/prototypes.html">here.</a></p>
<p><img src="https://paper-attachments.dropbox.com/s_688CFE67758A45D845E788E6DA05448A2BCF730C2B07FEF2D06AB18D2C46F736_1625428959141_image.png" alt="" /></p>
<p>The overridden entities and components are drawn in blue. We change the x and z components of the position to move the box. Note how the changed values are shown in white, while the values inherited from the prototype are shown in grey. </p>
<p>Missing</p>
<ul>
<li>link somehow somewhere the prototype content</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asset-browser"><a class="header" href="#asset-browser">Asset Browser</a></h1>
<p>The <strong>Asset Browser</strong> shows all your project's assets and enables you to manage them. It has multiple views at your exposal, which can make managing assets easier. The asset browser also allows you to search for assets in the current folder.</p>
<p><img src="https://paper-attachments.dropbox.com/s_688CFE67758A45D845E788E6DA05448A2BCF730C2B07FEF2D06AB18D2C46F736_1625429028821_image.png" alt="The asset browser’s grid view" /></p>
<p>As the image shows, the asset browser contains two components: The Directory Tree View of your project and the actual Asset View Panel.</p>
<p><strong>Table of Content</strong></p>
<ul>
<li><a href="the_editor/asset_browser.html#structure">Structure</a></li>
<li><a href="the_editor/asset_browser.html#search">Search</a></li>
<li><a href="the_editor/asset_browser.html#asset-management">Asset management</a></li>
<li><a href="the_editor/asset_browser.html#keyboard-bindings">Keyboard bindings</a></li>
</ul>
<h2 id="structure"><a class="header" href="#structure">Structure</a></h2>
<p><strong>The Directory Tree View</strong> reflects all directories and subdirectories of your project. You can use it to navigate quickly through your project. The navigation works either via mouse or via keyboard. You have the same management functionality as in the Asset View Panel:</p>
<ul>
<li>Add a new folder or assets to a folder</li>
<li>Rename, Delete, Copy, Cut, Paste, Duplicate folder</li>
<li>Drag Drop folder and reorganize the folder structure</li>
<li>Show in explorer if the current project is a directory project</li>
<li>Copy the path if the current project is a directory</li>
<li>Change Views: Change to Grid, Details or List view</li>
<li>Change the Filter &amp; Sorting</li>
</ul>
<p>All of those actions can be either done via the Main Menu or via the context menu.</p>
<p><strong>The Asset View Panel</strong> reflects all directories and sub directories as well as their assets in your project. This is the main place to organize your assets and folders. You have the same management functionality as in the Directory Tree View.</p>
<p>The Asset View Panel comes in three different views: <strong>Grid (default),</strong> <strong>Detail, and List-View.</strong>  You can change the views via the context menu or the <em>Change View</em> button next to the search field. Besides, there are also shortcuts to change the views: <strong>Shift + C</strong> will switch to the Grid View, <strong>Shift + L</strong> will change to the List view, and <strong>Shift + D</strong> will change to the details view. </p>
<p><img src="https://paper-attachments.dropbox.com/s_688CFE67758A45D845E788E6DA05448A2BCF730C2B07FEF2D06AB18D2C46F736_1625429106698_image.png" alt="Detail View" /></p>
<p><strong>Different View Modes</strong></p>
<p><strong>The Grid View</strong> will display your assets in a grid, which will shrink or grow depending on the tab size. In <strong>Details View</strong> allows you to see the details of your assets: What type are they easily? How big are they, and where on the disc are they located (if it's a directory project). The <strong>List-View</strong> will display your project's content in a list form.</p>
<p><strong>About filtering, sorting, and changing the view</strong>
There you have the option to filter via file extension or Asset-Labels. You can filter all assets by file extension type / Asset-Labels via the little filter icon or the context menu. You can also mix and match, as you require.</p>
<p><img src="https://paper-attachments.dropbox.com/s_688CFE67758A45D845E788E6DA05448A2BCF730C2B07FEF2D06AB18D2C46F736_1625429197285_image.png" alt="" />
<img src="https://paper-attachments.dropbox.com/s_688CFE67758A45D845E788E6DA05448A2BCF730C2B07FEF2D06AB18D2C46F736_1625429212614_image.png" alt="" /></p>
<p>You can sort them via the context menu or the sort arrow up/down buttons (▲▼). Besides, there are also shortcuts to change the views: <strong>Shift + N</strong> will sort by Name <strong>Shift + S</strong> sort by Size, and <strong>Shift + T</strong> sort by type. The sorting will be applied in all view modes.</p>
<h2 id="search"><a class="header" href="#search">Search</a></h2>
<p>You can search in your project, and the default search is local. If you want to search globally, you want to click on the button with the Globe. This search will search for you in the entire project. Be aware your filters will influence your search!</p>
<p><img src="https://paper-attachments.dropbox.com/s_688CFE67758A45D845E788E6DA05448A2BCF730C2B07FEF2D06AB18D2C46F736_1625430508007_image.png" alt="Switch from local to global view" /></p>
<p>When searching globally, you can right-click on any search result and open the location of the selected asset.</p>
<p><img src="https://paper-attachments.dropbox.com/s_688CFE67758A45D845E788E6DA05448A2BCF730C2B07FEF2D06AB18D2C46F736_1625430660296_image.png" alt="" /></p>
<h2 id="asset-management"><a class="header" href="#asset-management">Asset management</a></h2>
<p><em>Editing specific assets</em>
Double clicks on an asset may open the asset in their corresponding tab or window. Not all assets have a specific action associated with them. </p>
<table><thead><tr><th>Asset</th><th>Action on double click</th></tr></thead><tbody>
<tr><td>Animation State Machine (.asm)</td><td>Opens a new window with the Animation state machine layout.</td></tr>
<tr><td>Creation (.creation)</td><td>Opens a graph tab if no graph tab is open. If a graph tab is open it will load this graph. When ever we have a <strong>.creation</strong> file than the graph is called Creation Graph and is used for working on graphics related workflows such as materials.</td></tr>
<tr><td>Entity (.entity)</td><td>Opens a s<strong>cene tab</strong> if no scene tab is open. If a scene tab is open it will change the view to this entity.</td></tr>
<tr><td>Entity Graph (.entity_graph)</td><td>Opens a graph tab if no graph tab is open. If a graph tab is open it will load this graph. When ever we have a <strong>.entity_graph</strong> file than the graph is called Entity Graph and is used to make Entity Graph functionality reusable and shareable between multiple graphs.</td></tr>
</tbody></table>
<p>A single click will always focus a associated Properties Tab on the selected asset.</p>
<p><em>Dragging assets into the Scene</em></p>
<p>You can drag assets around in the asset browser. It allows for quick reorganization of assets. It is also possible to drag assets from the asset browser directly into the Scene. Assets can be dragged from the Asset Browser Tab to other tabs if they support the asset type.
You can also drag assets from the Windows-Explorer into your project. This action supports the same formats as the regular importer via <strong>File → Import Assets.</strong> </p>
<p><em>Asset Labelling</em></p>
<p>To organize your project, you can use Asset Labels. An asset can be associated with one or more different asset labels. You can use them to filter your asset in the asset browser or plugins via the <a href="https://ourmachinery.com/apidoc/plugins/editor_views/asset_label.h.html#structtm_asset_label_api">asset label api</a>.</p>
<p>There are two types of Asset labels: </p>
<ul>
<li>System Asset Labels: They are added by plugins and cannot be assigned by the user to a asset.
<ul>
<li>User Asset Labels: You add them, and they are part of the project with the file extension: .asset_label and can be found in the asset_label directory.</li>
</ul>
</li>
</ul>
<p>The user can manage them like any other asset and delete user-defined Asset Labels via the asset browser. There you can also rename them, and this will automatically propagate to all users of those asset labels.</p>
<p><em>Add an Asset Label to as Asset</em> </p>
<p>You can add asset Labels via the property view to any asset:</p>
<ul>
<li>You select an Asset.</li>
<li>You expand the Label View in the Property View Tab.</li>
<li>You can type in any asset label name you want. The system will suggest already existing labels or allow you to create the new one.</li>
</ul>
<p><img src="https://paper-attachments.dropbox.com/s_688CFE67758A45D845E788E6DA05448A2BCF730C2B07FEF2D06AB18D2C46F736_1625429529838_image.png" alt="1. Asset Label View in the Asset Property View Tab 2. The home of all your asset labels." /></p>
<h2 id="keyboard-bindings-3"><a class="header" href="#keyboard-bindings-3">Keyboard bindings</a></h2>
<table><thead><tr><th>Key</th><th>Descriptions</th></tr></thead><tbody>
<tr><td>Arrow Keys</td><td>Allow you to navigate through the Asset browser</td></tr>
<tr><td>Enter</td><td>If selected a folder or a asset will open the folder or asset</td></tr>
<tr><td>F2</td><td>Will rename asset or folder in Asset View Panel and Directory Tree View</td></tr>
<tr><td>Ctrl + F</td><td>Search in the current project</td></tr>
<tr><td>CTRL + D</td><td>Duplicates selected Asset</td></tr>
<tr><td>CTRL + C</td><td>Copies Assets</td></tr>
<tr><td>CTRL + V</td><td>Pastes Assets</td></tr>
<tr><td>CTRL + X</td><td>Cuts Assets</td></tr>
<tr><td>Ctrl + Alt + O</td><td>Opens Location of the asset in the asset browser view if in search view.</td></tr>
<tr><td>Ctrl + Shift + N</td><td>New folder</td></tr>
<tr><td>Ctrl + Shift + E</td><td>Open in Explorer</td></tr>
<tr><td>Shift + D</td><td>Change to Details View</td></tr>
<tr><td>Shift + L</td><td>Change to List View</td></tr>
<tr><td>Shift + C</td><td>Change to Grid View</td></tr>
<tr><td>Shift + N</td><td>Sort by Name</td></tr>
<tr><td>Shift + S</td><td>Sort by Size</td></tr>
<tr><td>Shift + T</td><td>Sort by File Extension</td></tr>
<tr><td>Shift + O</td><td>Opens a Directory or Asset</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simulate-tab"><a class="header" href="#simulate-tab">Simulate Tab</a></h1>
<p>In <em>The Machinery</em>, we make a distinction between <em>simulating</em> and <em>editing</em>. When you are <em>editing</em>, you see a static view of the scene. (Editing the scene with everything moving around would be very tricky.) all the runtime behaviors like physics, animation, destruction, entity spawning, etc., are disabled.
If you are building a game, the simulation mode will correspond to running the game. In contrast, when you are <em>simulating</em> or <em>running</em>, all the dynamic behaviors are enabled. It allows you to see the runtime behavior of your entities. To <em>simulate</em> a scene, open a scene in the <em>Simulate</em> tab.</p>
<p><img src="https://paper-attachments.dropbox.com/s_688CFE67758A45D845E788E6DA05448A2BCF730C2B07FEF2D06AB18D2C46F736_1625573554323_image.png" alt="" /></p>
<p><strong>Control over your simulation</strong>
While your simulation is running, you can Stop, reset or speed up the simulation.</p>
<p><img src="https://paper-attachments.dropbox.com/s_688CFE67758A45D845E788E6DA05448A2BCF730C2B07FEF2D06AB18D2C46F736_1625573595318_image.png" alt="" /></p>
<p>If your scene contains multiple cameras, you can pick between them via the camera toolbar.The default camera is a free flight camera.</p>
<p><img src="https://paper-attachments.dropbox.com/s_688CFE67758A45D845E788E6DA05448A2BCF730C2B07FEF2D06AB18D2C46F736_1625573634527_image.png" alt="" /></p>
<p>In the same toolbar, you can enable Debug-Rendering-Tags from various components. For example, it will render a box around the Volume Component from the Volume Component if enabled.</p>
<p><img src="https://paper-attachments.dropbox.com/s_688CFE67758A45D845E788E6DA05448A2BCF730C2B07FEF2D06AB18D2C46F736_1625573748963_components.gif" alt="" /></p>
<p>Within this toolbar, you also find the statistic button to open several overlays, such as <em>Frame Time.</em></p>
<p><img src="https://paper-attachments.dropbox.com/s_688CFE67758A45D845E788E6DA05448A2BCF730C2B07FEF2D06AB18D2C46F736_1625573806537_image.png" alt="" /></p>
<p>Besides those options, you have the <em>Render</em> option, which allows for the same options as in the Scene Tab.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="preview-tab"><a class="header" href="#preview-tab">Preview Tab</a></h1>
<p>The Preview Tab displays selected objects for you.</p>
<p><img src="https://paper-attachments.dropbox.com/s_688CFE67758A45D845E788E6DA05448A2BCF730C2B07FEF2D06AB18D2C46F736_1625574207263_image.png" alt="" /></p>
<p><strong>Camera Controls</strong>
It allows for the same Free-Camera controls as the Scene Tab. </p>
<p><strong>Movement</strong></p>
<ul>
<li><strong>Middle Mouse Button:</strong> Keep pressed down to move through the Scene.</li>
<li><strong>Left Mouse Button:</strong> Keep pressed down to rotate in the Scene by rotating the mouse. If you keep the mouse pressed so you can also use <strong>WASD</strong> to move through the Scene. To increase or decrease the movement speed, you need to move the mouse wheel.</li>
</ul>
<p><strong>Zoom in</strong></p>
<ul>
<li><strong>Mouse Wheel</strong>: To zoom in, you can zoom in or out via the mouse wheel.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-editing-workflow"><a class="header" href="#basic-editing-workflow">Basic editing workflow</a></h1>
<p>The basic scene editing workflow in <em>The Machinery</em> looks something like this:</p>
<ol>
<li>
<p>Import some asset files into the Asset Browser using <strong>File &gt; Import…</strong> If you don't have any
models to work with you can find free ones at <a href="https://sketchfab.com">Sketchfab</a> for example.</p>
</li>
<li>
<p>Organize the files by right-clicking the Asset Browser and choosing <strong>New &gt; New Folder</strong> and by
dragging and dropping.</p>
</li>
<li>
<p>Any imported model, for example <code>fbx</code> or <code>gltf</code>, will appear as a <code>dcc_asset</code>.</p>
</li>
<li>
<p>Rig an entity from the <code>dcc_asset</code> by selecting it and clicking <em>Import Assets</em> in the property
panel. This also imports the materials and images inside the <code>dcc_asset</code>.</p>
</li>
<li>
<p>Double click the imported entity to open it for editing.</p>
</li>
<li>
<p>Add components for physics, animation, scripting, etc to the entity.</p>
</li>
<li>
<p>Open a scene entity that you want to place your imported entity inside. A new project has a scene
entity called <code>world.entity</code> that you can use. Or you can create your own scene entity by right
clicking in the Asset Browser and choosing <strong>New &gt; New Entity</strong>.</p>
</li>
<li>
<p>Drag your asset entities into the scene entity to position them in the scene.</p>
</li>
<li>
<p>Use the Move, Rotate, and Scale tools in the Scene tab to arrange the sub-entities.</p>
</li>
<li>
<p>Holding down <em>shift</em> while using the move tools creates object clones.</p>
</li>
<li>
<p>Select entities or components in the Entity Tree and Scene tabs to modify their properties using the
Properties Tab.</p>
</li>
<li>
<p>Drag and drop in the Entity Tree Tab to re-link entities.</p>
</li>
<li>
<p>Each tool (Move, Rotate and Scale) has tool-specific settings, such as snapping and pivot point, in
the upper-left corner of the scene tab.</p>
</li>
<li>
<p>Use <strong>Scene &gt; Frame Selection</strong> and <strong>Scene &gt; Frame Scene</strong> to focus the
camera on a specific selected entity, or the entire scene. Or just use the <em>F key</em>.</p>
</li>
<li>
<p>When you are done, use <strong>File &gt; Save Project…</strong> to save the scene for future
work.</p>
</li>
</ol>
<blockquote>
<p><strong>Known issues:</strong> When you drag a tab out of the current window to create a new one, you don’t
get any visual feedback until the new window is created.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="entities"><a class="header" href="#entities">Entities</a></h2>
<p><em>The Machinery</em> uses an entity-component based approach as a flexible way of
representing “objects” living in a “world”.</p>
<p>An <em>entity</em> is an independently existing object. An entity can have a number of
<em>components</em> associated with it. These components provide the entity with
specific functionality and features. The components currently available in <em>The</em>
<em>Machinery</em> are:</p>
<table><thead><tr><th>Component</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>Animation Simple Player</strong></td><td>Plays individual animations on the entity.</td></tr>
<tr><td><strong>Animation State Machine</strong></td><td>Assigns an Animation State Machine to the entity which can be used to play and blend between animations.</td></tr>
<tr><td><strong>Camera</strong></td><td>Adds a camera to the entity. The <strong>Scene &gt; Camera</strong> menu option lets you view the scene through this camera.</td></tr>
<tr><td><strong>Cubemap Capture</strong></td><td>Used to capture cubemaps to be used for rendering reflections.</td></tr>
<tr><td><strong>Dcc Asset</strong></td><td>Renders an asset from a DCC tool. For more advanced rendering you would use the <em>Render</em> component.</td></tr>
<tr><td><strong>Entity Rigger</strong></td><td>Used to &quot;rig&quot; an imported DCC Asset as an entity. See below.</td></tr>
<tr><td><strong>Graph</strong></td><td>Implements a visual scripting language that can be used to script entity behaviors without writing code.</td></tr>
<tr><td><strong>Light</strong></td><td>Adds a light source to the entity.</td></tr>
<tr><td><strong>Physics Body</strong></td><td>Represents a dynamic physics body. Entities that have this component will be affected by gravity.</td></tr>
<tr><td><strong>Physics Joint</strong></td><td>Represents a physics joint, such as a hinge or a ball bearing.</td></tr>
<tr><td><strong>Physics Mover</strong></td><td>Represents a physics character controller. Used to move a character around the physics world.</td></tr>
<tr><td><strong>Physics Shape</strong></td><td>Represents a physics collision shape. If the entity has a physics body, this will be a dynamic shape, otherwise a static shape.</td></tr>
<tr><td><strong>Render</strong></td><td>Renders models output by a Creation Graph.</td></tr>
<tr><td><strong>Scene Tree</strong></td><td>Represents a hierarchy of nodes/bones inside an entity. Entities with skeletons, such as characters have scene trees.</td></tr>
<tr><td><strong>Sculpt</strong></td><td>Component used to free-form sculpt with blocks.</td></tr>
<tr><td><strong>Sound Source</strong></td><td>Component that will play a looping sound on the entity.</td></tr>
<tr><td><strong>Spin</strong></td><td>Sample component that spins the entity.</td></tr>
<tr><td><strong>Tag</strong></td><td>Assigns one or more &quot;tags&quot; to an entity, such as &quot;bullet&quot;, &quot;player&quot;, &quot;enemy&quot;, etc. When implementing gameplay, we can query for all entities with a certain tag.</td></tr>
<tr><td><strong>Tessellated Plane</strong></td><td>Sample component that draws a tessellated plane.</td></tr>
<tr><td><strong>Transform</strong></td><td>Represents the entity’s location in the world (position, scale, rotation). Any entity that exists at a specific location in the world should have a Transform Component. Note that you can have entities without a Transform Component. Such entities can for example be used to represent abstract logical concepts.</td></tr>
<tr><td><strong>Velocity</strong></td><td>Gives the entity a velocity that moves it through the world.</td></tr>
</tbody></table>
<p>In addition to components, an entity can also have <em>Child Entities</em>. These are
associated entities that are spawned together with the entity. Using child
entities, you can create complex entities with deep hierarchies. For example, a
house could be represented as an entity with doors and windows as child
entities. The door could in turn have a handle as a child entity.</p>
<p>In <em>The Machinery</em> entity system, an entity can't have multiple components of the same type. So you
can’t for example create an entity with two Transform Components. This is to avoid confusion
because if you allowed multiple Transform Components it would be tricky to know which represented
the “actual” transform of the entity.</p>
<p>In cases where you want multiple components (for example, you may want an entity
with multiple lights) you have to solve it by creating child entities and have
each child entity hold one of the lights.</p>
<blockquote>
<p>Note that <em>The Machinery</em> does not have specific <em>Scene</em> assets. A scene in The
Machinery is just an entity with a lot of child entities.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="creation-graphs-and-asset-pipeline"><a class="header" href="#creation-graphs-and-asset-pipeline">Creation graphs and asset pipeline</a></h2>
<p>There are lots of things you might want to do to an imported asset coming from a DCC-tool. For
example, extracting images and materials into a representation that can be further tweaked by your
artists or rigging an entity from the meshes present in the asset. In The Machinery, we provide full
control over how data enters the engine and what data-processing steps that get executed, allowing
technical artists to better optimize content and setup custom, game-specific asset pipelines.</p>
<p>This is handled through <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/creation_graphs/concept.html"><em>Creation Graphs</em></a>. A <em>Creation Graph</em> is essentially a generic framework for
processing arbitrary data on the CPUs and GPUs, exposed through a graph front-end view. While we can
use <em>Creation Graphs</em> for any type of data processing. </p>
<p>For more information visit the <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/creation_graphs/concept.html"><em>Creation Graphs</em></a> section. For the rest of this section we focus on how to set up a simple entity from an imported <code>dcc_asset</code>. </p>
<blockquote>
<p><strong>Tip:</strong>  if you wish to see other use cases such as particle systems, sky rendering and sprite sheets, then have a look in the
<a href="https://ourmachinery.com/samples.html"><code>creation_graphs</code></a> sample that we provide. </p>
</blockquote>
<h1 id="importing-a-dcc-asset"><a class="header" href="#importing-a-dcc-asset">Importing a DCC asset</a></h1>
<p>You can import an asset by selecting <strong>File &gt; Import...</strong> in the main menu, pressing <strong>Ctrl-I</strong>, or dropping a DCC file on the Asset Browser tab. When you do this, it ends up in our data-model as a <code>dcc_asset</code>. A <code>dcc_asset</code> can hold all types of data that was used to build the asset in the DCC-tool, such as objects, images, materials, geometry and animation data.</p>
<p>During the import step, The Machinery only runs a bare minimum of data processing, just enough so that we can display a visual representation of the asset in the <em>Preview</em> tab. Imports run in the background so you can continue to work uninterrupted. When the import finishes the asset will show up in the <em>Asset Browser</em>. Note that import of large assets can take a significant amount of time. You can monitor the progress of the import operation in the status bar.</p>
<p>For more in detail explanation about how to import assets checkout the <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/editing_workflows/import_assets.html">Asset Import Part</a>.</p>
<h3 id="basic-entity-rigging-with-image-and-material-extraction"><a class="header" href="#basic-entity-rigging-with-image-and-material-extraction">Basic entity rigging, with image and material extraction</a></h3>
<p>If you click on a <code>dcc_asset</code> that contains a mesh in the Asset Browser, you will be presented
with importer settings in the Properties tab:</p>
<p><img src="https://www.dropbox.com/s/n6njdkl84dzem8n/dcc-asset-before-entity-rig.png?dl=1" alt="Inspecting a dcc_asset" /></p>
<p>The Preview tab does just enough to show you what the <code>dcc_asset</code> contains, but what you probably
want is an <code>entity</code> that contains child entities representing the meshes found inside the
<code>dcc_asset</code>. Also, you probably want it to extract the images and materials from the <code>dcc_asset</code> so
you can continue to tweak those inside The Machinery. There are two ways to do this. Either you drag
the DCC asset onto the <em>Scene Tab</em>, or you click the <em>Import Asset</em> button. The <em>Import Assets</em>
button will automatically create a prototype Entity Asset in your project, while dropping it into
the scene will rig the entity inside the scene, without creating a prototype.</p>
<p>In either case, we will for our <code>door.dcc_asset</code> get a <code>door.resources</code> directory next to it. This
directory will contain materials and images extracted from the DCC asset. If you prefer dropping
the assets into the scene directly, but also want an entity prototype, then you can check the
<code>Create Prototype on Drop</code> check box.</p>
<p>Each image and material in the resources folder is a <em>Creation Graph</em>, which is responsible for the
data-processing of those resources. You can inspect these graphs to see what each one does. They are
described in more detail below.</p>
<iframe frameborder="0" scrolling="no" marginheight="0" marginwidth="0"width="788.54" height="443" type="text/html" src="https://www.youtube.com/embed/loaYaeSl-_g?autoplay=0&fs=0&iv_load_policy=3&showinfo=0&rel=0&cc_load_policy=0&start=0&end=0&origin=ourmachinery.com"></iframe>
<h3 id="creation-graphs-for-dcc_asset-import"><a class="header" href="#creation-graphs-for-dcc_asset-import">Creation Graphs for <code>dcc_asset</code> import</a></h3>
<p>In The Machinery, there are no specific asset types for images or materials, instead, we only have
<em>Creation Graphs</em> (<code>.creation</code> assets). To extract data from a <code>dcc_asset</code> in a creation graph, the
<code>dcc_asset</code>-plugin exposes a set of helper nodes in the <em>DCC Asset</em> category:</p>
<ul>
<li>
<p><code>DCC Asset/DCC Image</code> -- Takes the source <code>dcc_asset</code> together with the name of the image as input
and outputs a <code>GPU Image</code> that can be wired into various data processing nodes (such as mipmap
generation through the <code>Image/Filter Image</code> node) or directly to a shader node.</p>
</li>
<li>
<p><code>DCC Asset/DCC Material</code> -- Takes the source <code>dcc_asset</code> together with the name of the material as
input and outputs all properties of the material model found inside the <code>dcc_asset</code>. This material
representation is a close match to GLTF 2.0's PBR material model. Image outputs are references to
other <code>.creation</code> assets which in turn output <code>GPU Images</code>.</p>
</li>
<li>
<p><code>DCC Asset/DCC Mesh</code> -- Takes the source <code>dcc_asset</code> together with the name of the mesh as input
and outputs a <code>GPU Geometry</code> that can be wired to an <code>Output/Draw Call</code> output node for rendering
together with the minimum and maximum extents of the geometry that can be wired to an
<code>Output/Bounding Volume</code> output node for culling.</p>
</li>
</ul>
<p>The steps for extracting images and material <code>.creation</code> assets from a <code>dcc_asset</code> involve deciding
what data-processing should be done to the data before it gets wired to an output node of the graph.
This can either be done by manually assembling creation graphs for each image and material, or by
building a generic creation graph for each asset <em>type</em> and use that as a prototype when running a
batch processing step we refer to as <em>Resource Extraction</em>.</p>
<p>Here's an example of what a generic creation graph prototype for extracting images might look like:</p>
<p><img src="https://www.dropbox.com/s/z2e3s5w1h8yiv1k/image-cg.png?dl=1" alt="Simple image processing." /></p>
<p>To quickly get up and running we provide a number of pre-authored creation graphs for some of the
more common operations:</p>
<ul>
<li>
<p><code>import-image</code>-- Operations applied to images imported directly into the editor (not as part of a
<code>dcc-asset</code>).</p>
</li>
<li>
<p><code>dcc-image</code> -- Operations applied to images extracted from an imported <code>dcc_asset</code>.</p>
</li>
<li>
<p><code>dcc-material</code> -- Shader graph setup to represent materials extracted from an imported <code>dcc_asset</code>.</p>
</li>
<li>
<p><code>dcc-mesh</code> -- Operations for generating a draw call that reprensents a mesh from an imported <code>dcc_asset</code>.</p>
</li>
<li>
<p><code>drop-image</code> -- Operations for generating a draw call to display the image output of another
creation graph in the context of an entity, making it possible to drag-and-drop images into the
Scene Tab.</p>
</li>
</ul>
<p>These pre-authored creation graphs are shipped as part of our Core project which is automatically
copied into new projects. How they are used when working with assets is exposed through the
<code>import_settings</code> asset:</p>
<p><img src="https://www.dropbox.com/s/sr52qac8i1i757l/import-settings.png?dl=1" alt="Default Import Settings." /></p>
<p>By exposing these settings through an asset it is possible to easily change the default behavior of
how imported assets are treated when placed under a specific folder. </p>
<blockquote>
<p><strong>Note:</strong> It's worth noting that this is somewhat of a power-user feature and not something you need to have a detailed
understanding of to get started working with The Machinery.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="import-assets"><a class="header" href="#import-assets">Import assets</a></h1>
<p>This walkthrough shows how to import assets into a project and how to use them.</p>
<p>This part will cover the following topics:</p>
<ul>
<li>Import Asset pipeline</li>
</ul>
<p><strong>Table of Content</strong></p>
<ul>
<li><a href="editing_workflows/import_assets.html#how-to-import-assets-into-the-project">How to import assets into the project</a></li>
<li><a href="editing_workflows/import_assets.html#adding-the-asset-to-our-scene">Adding the asset to our scene</a></li>
<li><a href="editing_workflows/import_assets.html#about-import-setting">About Import Setting</a></li>
</ul>
<p>Related videos to these topics are:</p>
<iframe frameborder="0" scrolling="no" marginheight="0" marginwidth="0"width="788.54" height="443" type="text/html" src="https://www.youtube.com/embed/loaYaeSl-_g?autoplay=0&fs=0&iv_load_policy=3&showinfo=0&rel=0&cc_load_policy=0&start=0&end=0&origin=ourmachinery.com"></iframe>
<h2 id="how-to-import-assets-into-the-project"><a class="header" href="#how-to-import-assets-into-the-project">How to import assets into the project</a></h2>
<p>The Machinery has three different ways of importing assets. The first method of important an asset is via the <strong>File</strong> menu. There, we have an entry called <em>Import,</em> which will open a file dialog. Here one can import any of the supported file formats. At the time of writing this walkthrough, The Machinery is supporting the following formats:</p>
<p>Besides, it is possible to import assets from a remote location. In the <strong>File</strong> menu, the entry <em>Import from URL</em> allows for importing any supported asset archive of the type zip or 7zip. This archive will be unpacked and recursively checked for supported assets.</p>
<p><img src="https://paper-attachments.dropbox.com/s_8A68AE93396574AC0D937BFA8CFC626D302DBC4E0617A82A7B5162043ADD88EF_1615467083098_image.png" alt="" /></p>
<blockquote>
<p>Note: The url import does not support implicitly provided archives or files such as https://myassetrepo.tld/assets/0fb778f1ef46ae4fab0c26a70df71b04 only clear file paths are supported.  For example: https://myassetrepo.tld/assets/tower.zip</p>
</blockquote>
<p>The next method is to drag and drop either a zip/7zip archive into the asset browser or an asset of the supported type.
Assets that are created by e.g. Maya will be of type “dcc_asset” after they are imported.  Where DCC stands for Digital Content Creation.  While textures will be imported as creation graphs.</p>
<h2 id="adding-the-asset-to-our-scene"><a class="header" href="#adding-the-asset-to-our-scene">Adding the asset to our scene</a></h2>
<p>In The Machinery a scene is composed of entities. The engine does not have a concept of scenes like other engines do. A dcc_asset that is dragged into the scene automatically extracts its materials and textures etc. into the surrounding folder and adds an entity with the correct mash etc. to the Entity view.</p>
<p><img src="https://paper-attachments.dropbox.com/s_8A68AE93396574AC0D937BFA8CFC626D302DBC4E0617A82A7B5162043ADD88EF_1615468046484_drag_dcc_asset.gif" alt="" /></p>
<p>Another way of extracting the important information of a DCC asset is it to click on the DCC asset in the asset browser and click the button &quot;Extract Assets&quot; in the properties panel. 
This will exactly work like the previous method, but the main difference is that it creates a new entity asset that is not added to the scene. </p>
<p>Entity assets define a prototype in The Machinery. They are distinguished in the Entity Tree with yellow instead of white text. This concept allows having multiple versions of the same entity in the scene but they all change if the Prototype changes.</p>
<h2 id="about-import-setting"><a class="header" href="#about-import-setting">About Import Setting</a></h2>
<p>You can define the import creation graph prototype there as well.</p>
<ul>
<li>For Images</li>
<li>For Materials</li>
<li>For Meshes</li>
</ul>
<p>Every DCC asset allows changing of the extraction configuration. Therefore it is possible to define the extraction locations for outputs, images and materials.</p>
<p>Instead of importing assets and change their the configuration per asset , it is possible to define them per folder. All you need to do is add an &quot;<em>Import Settings Asset</em>&quot; in the correct folder. This can be done via the asset browser. <strong>Right Click -&gt; New -&gt; Import Settings</strong></p>
<p><img src="https://paper-attachments.dropbox.com/s_8A68AE93396574AC0D937BFA8CFC626D302DBC4E0617A82A7B5162043ADD88EF_1615469368165_image.png" alt="" /></p>
<blockquote>
<p><strong>Note:</strong> worth noting that this is somewhat of a power-user feature and not something you need to have a detailed
understanding of to get started working with The Machinery.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="import-projects"><a class="header" href="#import-projects">Import Projects</a></h1>
<p>The Machinery allows to share and remix the content of projects made within the Engine via the import project feature.</p>
<p><em>Project Import</em> provides an easy way to import assets from one The Machinery project to another. To use it, select <strong>File &gt; Import File…</strong> and pick a The Machinery project file to import. The project you select is opened in a new <em>Import Project</em> tab and from there, you can simply drag-and-drop or copy/paste assets into your main project’s <em>Asset Browser</em>.</p>
<p><img src="https://ourmachinery.com/images/beta_20_11__import_project.png" alt="Importing assets from another project." /></p>
<p><em>Importing assets from another project.</em></p>
<p>When you drag-and-drop or copy-paste some assets, all their dependencies are automatically dragged along so that they are ready to use.</p>
<p>Here is a video showing this in action. We start with a blank project, then we drag in a level from the physics sample and a character from the animation sample, put them both in the same scene, and play:</p>
<iframe frameborder="0" scrolling="no" marginheight="0" marginwidth="0"width="788.54" height="443" type="text/html" src="https://www.youtube.com/embed/gJpieDfxXQ0?autoplay=0&fs=0&iv_load_policy=3&showinfo=0&rel=0&cc_load_policy=0&start=0&end=0&origin=ourmachinery.com"></iframe>
<p>To make it even easier to share your stuff, we’ve also added <strong>File &gt; Import from URL…</strong> This lets you import any file that The Machinery understands: GLTF, FBX, JPEG, or a complete The Machinery project directly from an URL. You can even import zipped resource directories in the same way.</p>
<p>For example, in the image below, we imported a Curiosity selfie from NASA (using the URL <a href="https://www.nasa.gov/sites/default/files/thumbnails/image/curiosity_selfie.jpg">https://www.nasa.gov/sites/default/files/thumbnails/image/curiosity_selfie.jpg</a> ) and dropped it into the scene we just created:</p>
<p><img src="https://ourmachinery.com/images/beta_20_11__import_jpeg.png" alt="JPEG imported from URL." /></p>
<p><em>JPEG imported from URL.</em></p>
<p>Have you made something interesting in <em>The Machinery</em> that you want to share with the world? Save your project as an <em>Asset Database</em> and upload it to a web server somewhere. </p>
<p>Other people can use the <em>Import from URL…</em> option to bring your assets into their own projects.</p>
<blockquote>
<p><strong>Note</strong>: Be aware when you download plugins from the internet, they might contain plugin assets. Only Trust them if you can trust the source! More on this <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/extending_the_machinery/plugin-assets.html">See Plugin Assets</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creation-graphs"><a class="header" href="#creation-graphs">Creation Graphs</a></h1>
<p>The creation graph is (as the name implies) a graph based tool for creating assets. It allows developers to define and alter various types of assets using visual scripting. More broadly speaking, the creation graph can be used for arbitrary data processing tasks.</p>
<p>A creation graph thus defines the asset’s pipeline into its final state. For instance, an image asset will have a file that defines the data of the image, but the creation graph asset specifies how that data should be processed. Should it generate mipmaps, should it be compressed, do we need a CPU copy of it, etc.</p>
<p>A more familiar example might be a material shader. In The Machinery this is also defined using a creation graph. This case maps very well to Unity’s shader assets and Unreal’s material assets. In the image below you can see a simple default material with a saturated red base color.</p>
<p><img src="https://www.dropbox.com/s/w5ty4r8tttntt0t/tm_guide_creation_graph_simple_material.png?dl=1" alt="Simple red material" /></p>
<p>Image loading and material creation are just a few examples of what can be achieved with the creation graph. The table below shows when a creation graph is used compared to the tools one could use in Unity and Unreal.</p>
<table><thead><tr><th>Asset Type</th><th>Unity</th><th>Unreal</th><th>The Machinery</th></tr></thead><tbody>
<tr><td>Images</td><td>Texture</td><td>Texture</td><td>Creation graphs</td></tr>
<tr><td>Materials</td><td>Shader</td><td>Material</td><td>Creation graphs</td></tr>
<tr><td>Particles</td><td>Particle Effect</td><td>Cascade</td><td>Creation graphs</td></tr>
<tr><td>Post processing</td><td>Shader</td><td>Material</td><td>Creation graphs</td></tr>
<tr><td>Procedural materials</td><td>Procedural Materials</td><td>Material</td><td>Creation graphs</td></tr>
<tr><td>Meshes</td><td>Mesh</td><td>Static Mesh</td><td>DCC Asset + <br>Creation graphs</td></tr>
</tbody></table>
<p>Another example for the creation graph is mesh processing. A graph like this will define how the mesh should be draw or traced against. The graph below takes two inputs, a material creation graph and the mesh data from a DCC asset. This data is than imported and passed to the various outputs of our mesh pipeline. In this case those are: a ray tracing instance, a normal draw call, a bounding volume, and a physics shape. Note that not all of these outputs have to be used, rather the code that uses this creation graph might only look for the rendering outputs and ignore the physics shape, whilst some other code might only care about the physics shape output.</p>
<p><img src="https://www.dropbox.com/s/103bvtqaz6lnsog/tm_guide_creation_graph_mesh_processing.png?dl=1" alt="Mesh processing" /></p>
<p>Like the entity graph, the creation graph can executes nodes in sequence from an event. Some examples of this are the <code>Tick</code>, <code>Init</code>, and <code>Compile</code> events which are executed at known intervals. Most of the creation graphs however work with a reverse flow, compiling the graph into a sequence of nodes for a specific output. The two examples presented earlier show this workflow. Some outputs are: <code>Draw Call</code>, <code>Shader Instance</code>, <code>Image</code>, and <code>Physics Shape</code>. Note that these outputs are just blobs of data, an implementation can define more output type in code.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="prototypes"><a class="header" href="#prototypes">Prototypes</a></h2>
<p>The Machinery has a prototype system that allows entity assets to be used inside
other entities. So you can for example create an entity asset that represents a
room, and then create a house entity that has a bunch of these room entities
placed into it:</p>
<p><img src="https://www.dropbox.com/s/2hpnogh7bff9jge/house-entity.png?dl=1" alt="Three Room entities placed to form a House entity." /></p>
<p>We call the room asset a <em>prototype</em>, and we call each placed room entity an
<em>instance</em> of that prototype. Note that prototypes are not special assets, any
entity asset can be used as a prototype, with instances of it placed in another
entity asset.</p>
<p>In the Entity Tree tab, prototype instances are shown in yellow to distinguish them from locally
owned child entities (which are shown in white).</p>
<p>If you expand an instance you will notice that most of its components and child entities are grayed
out and can't be selected. This is because they are inherited from the prototype, and the prototype
controls their values. If the prototype is modified — for example if we scatter some more props on
the floor — those changes are reflected everywhere the prototype has been placed. In the example
above, all three room instances would get the scattered objects.</p>
<p>If we want to, however, we can choose to <em>override</em> some of the prototype’s
properties. When we override a property, we modify its value for <em>this instance</em>
of the prototype only. Other instances will keep the value from the prototype.</p>
<p>To initiate an override, right-click the component or child entity whose
properties you want to override and choose <strong>Override</strong> in the context
menu. In addition to modifying properties, you can also add or remove components
or child entities on the overridden entity.</p>
<p>If you override the property of some node deep in the hierarchy of the placed entity, all its
parents will automatically get overridden too. Let's modify the position of the barrel in the
front-most room:</p>
<p><img src="https://www.dropbox.com/s/uy0rzwhrjzen42i/override.png?dl=1" alt="Barrel position overridden." /></p>
<p>The overridden entities and components are drawn in blue. We change the x and z components of the
position to move the barrel. Note how the changed values are shown in white, while the values that
are inherited from the prototype are shown in gray.</p>
<p>If you look back to the first picture you will see that the Link Component was
automatically overridden when the prototype was instanced. This is needed
because if we didn’t override the Link Component, it would use the values from
the prototype, which means all three room instances would be placed in the same
position.</p>
<p>When we override something on an instance, all the things not explicitly
overridden are still inherited from the prototype. If we modify the prototype —
for example change the barrel to a torch — all instances will get the change,
since it was only the x and z positions of the object that we changed.</p>
<p>The context menus can be used to perform other prototype operations. For example,
you can <strong>Reset</strong> properties back to the prototype values. You can also
<strong>Propagate</strong> the changes you have made to an overridden component or entity
back to the prototype so that all instances get the changes. Finally, you can
<strong>Remove</strong> the overrides and get the instance back to being an exact replica of
the prototype.</p>
<p>Prototypes can also be used for other things than entities. For example, if you have a graph that
you want to reuse in different places you can create a Graph Asset to hold the graph, and then
instantiate that asset in the various places where you want to use it. Just as with the entity
instances, you can override specific nodes in the graph instance to customize the behavior.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="simulation"><a class="header" href="#simulation">Simulation</a></h2>
<p>In <em>The Machinery</em>, we make a distinction between <em>simulating</em> and <em>editing</em>. When you are <em>editing</em>,
you see a static view of the scene. All the runtime behaviors like physics, animation, destruction,
entity spawning, etc are disabled. (Editing the scene with everything moving around would be very
tricky.)</p>
<p>In contrast, when you are <em>simulating</em> or <em>running</em>, all the dynamic behaviors are enabled. This
allows you to see the runtime behavior of your entities. If you are building a game, the simulation
mode would correspond to running the game.</p>
<p>To <em>simulate</em> a scene, open a scene in the <em>Simulate</em> tab.</p>
<p><img src="https://www.dropbox.com/s/7t8elpzqllqkqrb/simulate-tab.png?dl=1" alt="Simulate tab." /></p>
<p>You can use the controls in the tab to pause, play, or restart the simulation or change the
simulation speed. Note that if you haven't added any simulation components to the scene, the
<em>Simulate</em> tab will be just as static as the Scene tab. In order to get something to happen, you
need to add some runtime components.</p>
<p>The <em>Entity Graph</em> gives you a visual scripting language for controlling entity behavior. It will
be described in the next section.</p>
<p>You can launch the engine in simulation mode from the command line:</p>
<pre><code>the-machinery.exe --load-project project.the_machinery --simulate scene
</code></pre>
<p>Here <code>project.the_machinery</code> should be the name of your project file and <code>scene</code> the name of the
entity you want to simulate. This will open a window with just the <em>Simulate</em> tab, simulating the
scene that you specified.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="entity-graphs"><a class="header" href="#entity-graphs">Entity Graphs</a></h2>
<p>The <em>Entity Graph</em> implements a visual scripting language based on nodes and connections. To use
it, right-click on an entity to add a Graph Component and then double click on the Graph Component
to open it in the Graph Editor:</p>
<p><img src="https://www.dropbox.com/s/ssasbp5sb0vq7gy/graph-editor.png?dl=1" alt="Graph editor." /></p>
<p>The visual scripting language uses <em>Events</em> to tick the execution of nodes. For example, the
<em>Tick Event</em> node will trigger its out connector whenever the application ticks its frame. Connect
its output event connector to another node to run that node during the application's update.</p>
<p>Nodes that just fetch data and don't have any side-effects are considered &quot;pure&quot;. They don't have
any event connectors and will run automatically whenever their data is needed by one of the non-pure
nodes. Connect the data connectors with wires to pass data between nodes.</p>
<p>In addition to connecting wires, you can also edit input data on the nodes directly. Click a node
to select it and edit its input data in the properties.</p>
<p>There are a lot of different nodes in the system and I will not attempt to describe all of them.
Instead, here is a simple example that adds a super simple animation to an entity using the graph
component:</p>
<p><img src="https://youtu.be/3DupUNK9GNc" alt="Adding a simple behavior." /></p>
<p>For more examples, check out the <code>pong</code> and <code>animation</code> projects in the samples.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="physics"><a class="header" href="#physics">Physics</a></h2>
<p>The Machinery integrates Nvidia's PhysX toolkit and uses it for physics simulation of entities. This section will not attempt to describe in detail how physics simulation works, for that we refer to <a href="https://docs.nvidia.com/gameworks/content/gameworkslibrary/physx/guide/Manual/Index.html">the PhysX documentation</a>. 
We will only talk about how physics is set up in The Machinery.</p>
<p><strong>Table of Content</strong></p>
<ul>
<li><a href="editing_workflows/physics.html#the-physics-simulation-system">The physics simulation system</a>
<ul>
<li><a href="editing_workflows/physics.html#physics-assets">Physics Assets</a></li>
<li><a href="editing_workflows/physics.html#physics-components">Physics Components</a></li>
</ul>
</li>
<li><a href="editing_workflows/physics.html#physics-scripting">Physics scripting</a></li>
<li><a href="editing_workflows/physics.html#missing-features">Missing Features</a></li>
<li><a href="editing_workflows/physics.html#tutorials">Tutorials</a></li>
</ul>
<h2 id="the-physics-simulation-system"><a class="header" href="#the-physics-simulation-system">The physics simulation system</a></h2>
<p>The physics simulation system introduces two new assets: <em>Physics Material</em> and <em>Physics Collision</em>
as well as four new components: <em>Physics Shape Component</em>, <em>Physics Body Component</em>, <em>Physics
Joint Component</em>, and <em>Physics Mover Component</em>.</p>
<h3 id="physics-assets"><a class="header" href="#physics-assets">Physics Assets</a></h3>
<p>A <em>Physics Material</em> asset specifies the physical properties of a physics object: <em>friction</em> (how
&quot;slippery&quot; the object is) and <em>restitution</em> (how &quot;bouncy&quot; the object is). Note that if you don't
assign a material to a physics shape it will get default values for <em>friction</em> and <em>constitution</em>.</p>
<p>A <em>Physics Collision</em> asset describes a <em>collision class</em>. <em>Collision Classes</em> control which physics
shapes collide with each other. For example, a common thing to do is to have a <em>debris</em> class for
small objects and set it up so that <em>debris</em> collide with regular objects, but not with other
<em>debris</em>. That way, you are not wasting resources on computing collisions between lots of tiny
objects. (Note that the debris objects still need to collide with regular objects, or they would
just fall through the world.)</p>
<p>In addition to deciding who collides with who, the collision class also decides which collisions
generate callback events. These events can be handled in the <em>Entity Graph</em>.</p>
<p>If you don't assign a collision class to a physics shape, it will get the <em>Default</em> collision class.</p>
<h3 id="physics-components"><a class="header" href="#physics-components">Physics Components</a></h3>
<p>The <em>Physics Shape Component</em> can be added to an entity to give it a collision shape for physics.
Entities with shape components will collide with each other when physics is simulated.</p>
<p>A physics shape can either be specified as geometry (sphere, capsule, plane, box) or it can be
computed from a graphics mesh (convex, mesh). Note that if you use computed geometry, you must press
the <strong>Cook</strong> button in the Properties UI to explicitly compute the geometry for the object.</p>
<p><img src="editing_workflows/physics.html#" alt="Convex shape." /></p>
<p>If you just give an entity a <em>Physics Shape Component</em> it will become a static physics object. Other
moving objects can still collide with it, but the object itself won't move.</p>
<p>To create a moving physics object, you need to add a <em>Physics Body Component</em>. The body component
lets you specify dynamic properties such as damping, mass, and inertia tensor. It also lets you
specify whether the object should be <em>kinematic</em> or not. A <em>kinematic</em> object is being moved by
<em>animation</em>. Its movement is not affected by physics, but it can still affect other physical
objects by colliding with them and pushing them around. In contrast, if the object is <em>not
kinematic</em> it will be completely controlled by physics. If you place it above ground, it will fall
down as soon as you start the simulation.</p>
<p>Note that parameters such as <em>damping</em> and <em>mass</em> do not really affect kinematic objects, since
the animations will move them the same way, regardless of their mass or damping. However, these
parameters can still be important because gameplay code could at some point change the object
from being kinematic to non-kinematic. If the gameplay code never makes the body non-kinematic, the
mass doesn't matter.</p>
<p>The <em>Physics Joint Component</em> can be used to add <em>joints</em> to the physics simulation. Joints can tie
together physics bodies in various ways. For example, if you tie together two bodies with a hinge
joint they will swing as if they were connected by a hinge. For a more thorough description of
joints, we refer to the PhysX documentation.</p>
<p>The <em>Physics Mover Component</em> implements a physics-based character controller. If you add it to an
entity, it will keep the entity's feet on the ground, prevent it from going through walls, etc. For
an example of how to use the character controller, check out the <code>animation</code> or <code>gameplay</code> sample
projects.</p>
<h2 id="physics-scripting"><a class="header" href="#physics-scripting">Physics scripting</a></h2>
<p>Physics can be scripted using the visual scripting language in the <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/editing_workflows/visual-scripting.html"><em>Entity Graph</em></a>.</p>
<p>We can divide the PhysX scripting nodes into a few categories.</p>
<p><strong>Nodes that query the state of a physics body:</strong></p>
<ul>
<li>Get Angular Velocity</li>
<li>Get Velocity</li>
<li>Is Joint Broken</li>
<li>Is Kinematic</li>
</ul>
<p><strong>Nodes that manipulate physics bodies:</strong></p>
<ul>
<li>Add Force</li>
<li>Add Torque</li>
<li>Break Joint</li>
<li>Push</li>
<li>Set Angular Velocity</li>
<li>Set Kinematic</li>
<li>Set Velocity</li>
</ul>
<p><strong>Event nodes that get triggered when something happens in the scene:</strong></p>
<ul>
<li>On Contact Event</li>
<li>On Joint Break Event</li>
<li>On Trigger Event</li>
</ul>
<p><strong>Nodes that query the world for physics bodies:</strong></p>
<ul>
<li>Overlap</li>
<li>Raycast</li>
<li>Sweep</li>
</ul>
<blockquote>
<p><strong>Note</strong> that the query nodes may return more than one result. They will do that by triggering their
<em>Out</em> event multiple times, each time with one of the result objects. (In the future we might change
this and have the nodes actually return arrays of objects.)</p>
</blockquote>
<p>From C you can access those features via the <a href="https://ourmachinery.com/apidoc/plugins/physx/physx_scene.h.html#structtm_physx_scene_api">tm_physx_scene_api</a>.</p>
<h2 id="missing-features"><a class="header" href="#missing-features">Missing Features</a></h2>
<p>Note that The Machinery doesn't currently support all the features found in PhysX. The most
glaring omissions are:</p>
<ul>
<li>D6 joints and joint motors.</li>
<li>Vehicles.</li>
</ul>
<p>We will add more support going forward.</p>
<p>For an example of how to use physics, see the <a href="https://ourmachinery.com/samples.html">Physics Sample Project</a>.</p>
<h2 id="tutorials"><a class="header" href="#tutorials">Tutorials</a></h2>
<p>For more information and guides checkout out the <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/">The Machinery Tutorials Book</a> as well as our <a href="https://ourmachinery.com/samples.html">Physics Sample</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="animation"><a class="header" href="#animation">Animation</a></h2>
<p>The <em>Animation</em> system lets you play animations on entities. You can also create complicated
animation blends, crossfades, and transitions using an <em>Animation State Machine</em>.</p>
<p>The animation system adds two new assets to The Machinery: <em>Animation Clip</em> and <em>Animation State
Machine</em> as well as two new components: <em>Animation Simple Player</em> and <em>Animation State Machine</em>.</p>
<p>To get an animation into <em>The Machinery</em> you first export it from your DCC tool as FBX or another
suitable file format. Then you import this using <strong>File &gt; Import...</strong>.</p>
<p>An <em>Animation Clip</em> is an asset created from an imported DCC animation asset that adds some
additional data. First, you can set a range of the original animation to use for the clip, so you
can cut up a long animation into several individual clips. Second, you can specify whether the
animation should loop or not as well as its playback speed. You can use a negative playback speed to
get a &quot;reverse&quot; animation.</p>
<p>Finally, you can specify a &quot;locomotion&quot; node for the animation. If you do, the delta motion of that
node will be extracted from the animation and applied to the <em>entity</em> that animation is played on,
instead of to that bone. This lets an animation &quot;drive&quot; the entity and is useful for things like
walking and running animations. The locomotion node should typically be the root node of the
skeleton. If the root mode is animated and you &quot;don't&quot; specify a locomotion node, the result will be
that the root node &quot;walks away&quot; from the animation.</p>
<iframe id="ytplayer" type="text/html" width="640" height="360"
  src="https://www.youtube.com/embed/OcgBaG0rHtk?autoplay=1"
  frameborder="0"></iframe>
<p>The <em>Animation Simple Player Component</em> is a component that you can add to an entity to play
animations on it. The component lets you pick a single animation to play on the entity. This is
useful when you want to play simple animations such as doors opening, coins spinning, flags waving,
etc. If you want more control over the playback and be able to crossfade and blend between
animations you should use an <em>Animation State Machine</em> instead.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="animation-state-machines"><a class="header" href="#animation-state-machines">Animation state machines</a></h3>
<p>The <em>Animation State Machine Asset</em> represents an <em>Animation State Machine</em>. If you double-click an
Animation State Machine Asset in the Asset Browser, an Animation State Machine Editor will open:</p>
<p><img src="editing_workflows/animation/animation-state-machine.html#" alt="Animation State Machine Editor" /></p>
<p>The Animation State Machine (ASM) introduces a number of concepts: <em>Layers</em>, <em>States</em>,
<em>Transitions</em>, <em>Events</em>, <em>Variables</em>, and <em>Blend Sets</em>.</p>
<p>The ASM represents a complex animation setup with multiple animations that can be played on a
character by dividing it into <em>States</em>. Each state represents something the character is doing
(running, walking, swimming, jumping, etc) and in each state, one particular animation, or a
particular blend of animations is being played. The states are the boxes in the <em>State Graph</em>.</p>
<p>The ASM can change state by taking a <em>Transition</em> from one state to another. The transitions are
represented by arrows in the graph. When the transition is taken, the animation crossfades over from
the animations in one state to the animations in the other state. The properties of the transition
specify the crossfade time. Note that even though the crossfade takes some time, the logical <em>state
transition</em> is immediate. I.e. as soon as the transition is taken, the state machine will logically
be in the new state.</p>
<p>The transitions are triggered by <em>Events</em>. An event is simply a named thing that can be sent to the
ASM from gameplay code. For example, the gameplay may send a &quot;jump&quot; event and that triggers the
animation to transition to the &quot;jump&quot; state.</p>
<p><em>Variables</em> are float values that can be set from gameplay code to affect how the animations play.
The variables can be used in the states to affect their playback. For example, you may create a
variable called <code>run_speed</code> and set the playback <em>Speed</em> of your <em>run</em> state to be <code>run_speed</code>.
That way, gameplay can control the speed of the animation.</p>
<p>Note that the <em>Speed</em> of a state can be set to a fixed number, a variable, or a mathematical
expression using variables and numbers. (E.g. <code>run_speed * 2</code>.) We have a small expression language
that we use to evaluate these expressions.</p>
<p>The ASM supports multiple <em>Layers</em> of state graphs. This works similar to image layering in an
application such as Photoshop. Animations in &quot;higher&quot; layers will be played &quot;on top&quot; of animations
in the lower layers and hide them.</p>
<p>As an example of how to use layering, you could have a bottom layer that controls the player's basic
locomotion (walking, running, etc). Then you could have a second layer on top of that for
controlling arm movements. That way, you could play a reload animation on the arms while the legs
are still running. Finally, you could have a top layer to play &quot;hurt&quot; animations when the player for
example gets hit by a bullet. These hurt animations could then interrupt the reload animations
whenever the player got hit.</p>
<p><em>Blend Sets</em> can be used to control the per-bone opacity of animations playing in higher layers.
They simply specify a weight for each bone. In the example above, the animations in the &quot;arm
movement&quot; layer would have opacity 1.0 for all arm bones, but 0.0 for all leg bones. That way, they
would hide the arm movement from the running animation below, but let the leg movement show through.</p>
<p>The Animation State Machine Editor has a <em>Tree View</em> to the left that lets you browse all the
layers, states, transitions, events, variables, and blend sets. The <em>State Graph</em> lets you edit the
states and transitions in the current layer. The <em>Properties</em> window lets you set the properties of
the currently selected objects and the <em>Preview</em> shows you a preview of what the animation looks
like. Note that for the preview to work, you must specify a <em>Preview Entity</em> in the properties of
the state machine. This is the entity that will be used to preview the ASM. When you select a state
in the <em>State Graph</em>, the preview will update to show that state.</p>
<p>In the <em>Preview</em> window, you also find the <em>Motion Mixer</em>. This allows you to send events to the ASM
and change variables to see how the animation reacts.</p>
<p>The ASM currently supports the following animation states:</p>
<p><strong>Regular State</strong></p>
<p>Plays a regular animation.</p>
<p><strong>Random State</strong></p>
<p>Randomly plays an animation out of a set of options.</p>
<p><strong>Empty State</strong></p>
<p>A state that doesn't play any animation at all. Note that this state is only useful in higher layers.
You can transition to an empty state to &quot;clear&quot; the animation in the layer and let the animations from
the layers below it shine through.</p>
<p><strong>Blend State</strong></p>
<p>Allows you to make a 1D or 2D blend between animations based on the value of variables. This is often
used for locomotion. You can use different animations based on the characters running speed and whether
the character is turning left or right and position them on a map to blend between them.</p>
<p><img src="editing_workflows/animation/animation-state-machine.html#" alt="Animation Blending" /></p>
<p>Once you have created an Animation State Machine, you can assign it to a character by giving it an
Animation State Machine Component.</p>
<p>For an example of how the animation system works, have a look at the <code>mannequin</code> sample project.</p>
<h3 id="missing-features-1"><a class="header" href="#missing-features-1">Missing features</a></h3>
<p>Note that the animation system is still under active development. Here are some features that are
planned for the near future:</p>
<ul>
<li>Ragdolls.</li>
<li>Animation compression.</li>
<li>Triggers.</li>
<li>More animation states.
<ul>
<li>Offset State.</li>
<li>Template State.</li>
<li>Expression-based Blend State.</li>
<li>Graph-based Blend State.</li>
</ul>
</li>
<li>Beat transitions.</li>
<li>Constraints.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="animation-compression"><a class="header" href="#animation-compression">Animation Compression</a></h2>
<p>We support compressed animations. Compressed animations have the extension <code>.animation</code>. Note that with this, we have three kinds of animation resources:</p>
<table><thead><tr><th><strong>Resource</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td><code>.dcc_asset</code></td><td>Animation imported from a Digital Content Creation (DCC) software, such as Max, Maya, Blender, etc. Note  that <code>.dcc_asset</code> is used for all imported content, so it could be animations, textures, models, etc.</td></tr>
<tr><td><code>.animation</code></td><td>A compressed animation. The compressed animation is generated from the <code>.dcc_asset</code> by explicitly compressing it.</td></tr>
<tr><td><code>.animation_clip</code></td><td>Specifies how an animation should be played: playback speed, whether it plays forward or backward, if it drives the root bone or not, etc.<br><br>An <em>Animation Clip</em> references either an uncompressed <code>.dcc_asset</code> or a compressed <code>.animation</code> to access the actual animation data.</td></tr>
</tbody></table>
<p>To create a compressed animation, right-click a <code>.dcc_asset</code> file that contains an animation and choose <strong>Create xxx.animation</strong> in the context menu:</p>
<p><img src="https://paper-attachments.dropbox.com/s_AF44CABDD4BF19FA7D54C2D4574B155CAAE2ED895AFB490AC3671972A5F81DC2_1617123138052_image.png" alt="A compressed animation." /></p>
<p>When you first do this, the animation shows a white skeleton in T-pose and a moving blue skeleton. The blue skeleton is the reference <code>.dcc_animation</code> and the white skeleton is the compressed animation. By comparing the skeletons you can see how big the error in the animation is.</p>
<p>At first, the white skeleton is in T-pose because we haven’t actually generated the compressed data yet. To do that, press the <strong>Compress</strong> button:</p>
<p><img src="https://paper-attachments.dropbox.com/s_AF44CABDD4BF19FA7D54C2D4574B155CAAE2ED895AFB490AC3671972A5F81DC2_1617123319435_image.png" alt="Compressed animation with data." /></p>
<p>This will update the <strong>Format</strong> and <strong>Buffer</strong> fields and we can see that we have 9.2 KB of compressed data for this animation and that the compression ratio is x 6.66. I.e, the compressed data is 6.66 times smaller than the uncompressed one. The white and the blue skeletons overlap. The compression error is too small to be noticed in this view, we have to really zoom in to see it:</p>
<p><img src="https://paper-attachments.dropbox.com/s_AF44CABDD4BF19FA7D54C2D4574B155CAAE2ED895AFB490AC3671972A5F81DC2_1617123494752_image.png" alt="Zoomed in view of one of the fingers." /></p>
<p>When you compress an animation like this, The Machinery tries to come up with some good default compression settings. The default settings work in a lot of cases, but they’re not perfect,
because The Machinery can’t know how the animation is intended to be viewed in your game.</p>
<p>Are you making a miniature fighting game, and all the models will be viewed from a distant overhead camera? In that case, you can get away with a lot of compression. Or are you animating a gun sight that will be held up really close to the player’s eye? In that case, a small error will be very visible.</p>
<p>To help the engine, you can create an <code>.animation_compression</code> asset. (<strong>New Animation Compression</strong> in the asset browser.) The Animation Compression asset control the settings for all the animations in the same folder or in its subfolders (unless the subfolders override with a local Animation Compression asset):</p>
<p><img src="https://paper-attachments.dropbox.com/s_AF44CABDD4BF19FA7D54C2D4574B155CAAE2ED895AFB490AC3671972A5F81DC2_1617124020292_image.png" alt="Animation Compression settings." /></p>
<p>The Animation Compression settings object has two properties:</p>
<p><strong>Max Error</strong> specifies the maximum allowed error in the compressed animation. The default value is 0.001 or 1 mm. This means that when we do the compression we allow bones to be off by 1 mm, but not more. The lower you set this value, the less compression you will get.</p>
<p><strong>Skin Size</strong> specifies the size we assume for the character’s skin. It defaults to 0.1, or 10 cm. We need the skin size to estimate the effects of rotational errors. For example, if the rotation of a bone is off by 1°, the effect of that in mm depends on how far away from the bone the mesh is.</p>
<p>10 cm is a reasonable approximation for a human character, but notice that there are situations where the skin size can be significantly larger. For example, suppose that a 3 m long staff is attached to the player’s hand bone. In this case, rotational errors in the hand are amplified by the full length of the staff and can lead to really big errors in the position of the staff end. If this gives you trouble, you might want to up the skin size to 3 for animations with the staff.</p>
<p>We don’t support setting a per-bone skin size, because it’s unclear if the effort of specifying per-bone skin sizes is really worth it in terms of the memory savings it can give. (Also, even a per-bone skin size might not be enough to estimate errors perfectly. For example, an animator could have set up a miter joint where the extent of the skin depends on the relative angle of two bones and goes to infinity as the angle approaches zero.)</p>
<p>Note that sometimes animations are exported in other units than meters. In this case, the Skin Size and the Max Error should be specified in the same units that are used in the animation file.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="sound"><a class="header" href="#sound">Sound</a></h2>
<p>The Machinery comes with a low-level sound system that can import WAV files into the project and
play them back. The sound system can position sounds in 3D space and mix together 2D and 3D sounds
for output on a stereo, 5.1, or 7.1 sound system.</p>
<p>You can play a sound by adding a <em>Sound Source Component</em> to an object in the level of by using one
of the sound playing nodes in the visual scripting language.</p>
<h3 id="missing-features-2"><a class="header" href="#missing-features-2">Missing features</a></h3>
<p>The sound system is rudimentary. Here are some features that are planned for the future:</p>
<ul>
<li>Sound streaming</li>
<li>Sound compression</li>
<li>WASAPI backend</li>
<li>React to the user plugging in or unplugging headphones</li>
<li>Hermite-interpolated resampling</li>
<li>Reverb</li>
<li>Directional sound sources</li>
<li>Doppler effect</li>
<li>Multiple listeners</li>
<li>HRTF</li>
<li>High-level sound system
<ul>
<li>Random sounds</li>
<li>Composite sounds</li>
<li>Streaming sounds</li>
<li>Compressing sounds</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="publishing-your-game"><a class="header" href="#publishing-your-game">Publishing your game</a></h2>
<p>You publish your game via <strong>File -&gt; Publish</strong>. The Engine opens the publishing tab.</p>
<p><img src="https://paper-attachments.dropbox.com/s_688CFE67758A45D845E788E6DA05448A2BCF730C2B07FEF2D06AB18D2C46F736_1625575509478_image.png" alt="" /></p>
<p>In there, you have a couple of options:</p>
<table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody>
<tr><td>Executable Name</td><td>The name of the executable, e.g. <code>test.exe</code></td></tr>
<tr><td>Window Title</td><td>The text which is displayed in the window title.</td></tr>
<tr><td>World Entity</td><td>The Entry point of your game.</td></tr>
<tr><td>Resolution</td><td>The default resolution to use when running the published project</td></tr>
<tr><td>Fullscreen</td><td>If checked the game will launch in Fullscreen</td></tr>
<tr><td>Directory Project</td><td>Decides if the game data is published as binary data or as human readable directory.</td></tr>
</tbody></table>
<p><strong>Directory vs. none Directory Project</strong></p>
<p><img src="https://paper-attachments.dropbox.com/s_688CFE67758A45D845E788E6DA05448A2BCF730C2B07FEF2D06AB18D2C46F736_1625575521208_image.png" alt="" /></p>
<p>If you check this option, the game is exported as a human-readable project. Otherwise the game data will be compressed and stored in a binary <code>.the_machinery</code> format.</p>
<p><img src="https://paper-attachments.dropbox.com/s_688CFE67758A45D845E788E6DA05448A2BCF730C2B07FEF2D06AB18D2C46F736_1625575817141_image.png" alt="" /></p>
<blockquote>
<p>Not recommended for other than debug purposes.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="sculpt-tool"><a class="header" href="#sculpt-tool">Sculpt Tool</a></h2>
<blockquote>
<p><strong>Note:</strong> This tool is in a preview state.</p>
</blockquote>
<p>With the Sculpt Tool The Machinery supportes rapid prototyping when it comes to level white boxing. You make use of the tool by adding a Sclupt Component to an Entity. Using the sculpt component you can quickly sketch out levels or make beautiful blocky art:</p>
<p><img src="https://ourmachinery.com/images/beta_20_11__blocky.png" alt="A blocky character in a blocky forest setting." /></p>
<p><em>A blocky character in a blocky forest setting.</em></p>
<h2 id="how-to-use-the-tool"><a class="header" href="#how-to-use-the-tool">How to use the Tool</a></h2>
<p>To use the Sculpt Component, first add it to an entity, by right-clicking the entity in the <em>Entity Tree</em> and selecting <em>Add Component.</em> Then, select the newly created <em>Sculpt</em> component in the <em>Entity Tree</em>.</p>
<p>This gives you a new sculpt tool in the toolbar:</p>
<p><img src="https://ourmachinery.com/images/beta_20_11__sculpt_tool.png" alt="Sculpt tool." /></p>
<p><em>Sculpt tool.</em></p>
<p>With this tool selected, you can drag out prototype boxes on the ground. You can also drag on an existing prototype box to create boxes attached to that box.</p>
<p>The standard <em>Select</em>, <em>Move</em>, <em>Rotate,</em> and <em>Scale</em> tools can be used to move or clone (by shift-dragging) boxes.</p>
<p>You can add physics to your sculpts, by adding a <em>Physics Shape Component</em>, just as you would for any other object. </p>
<blockquote>
<p><strong>Note</strong>: If you are cooking a physics mesh or convex from your sculpt data, you need to explicitly recook whenever the sculpt data changes.</p>
</blockquote>
<p>Here is a video of sculpting in action:</p>
<iframe frameborder="0" scrolling="no" marginheight="0" marginwidth="0"width="788.54" height="443" type="text/html" src="https://www.youtube.com/embed/YUyz1qPf1CM?autoplay=0&fs=0&iv_load_policy=3&showinfo=0&rel=0&cc_load_policy=0&start=0&end=0&origin=ourmachinery.com"></iframe>
<blockquote>
<p><strong>Note:</strong> Currently, all the sculpting is done with boxes. We may add additional shape support in the future. </p>
</blockquote>
<h2 id="additional-though"><a class="header" href="#additional-though">Additional though</a></h2>
<p>In addition to being a useful tool, the <em>Sculpt Component</em> also shows the deep integration you can get with custom plugins in The Machinery. The <em>Sculpt Component</em> is a separate plugin, completely isolated from the rest of The Machinery and if you wanted to, you could write your own plugins to do similar things.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-truth"><a class="header" href="#the-truth">The Truth</a></h1>
<p>The Machinery uses a powerful data model to represent edited assets. This model has built-in support for serialization, streaming, copy/paste, drag-and-drop as well as unlimited undo/redo. It supports an advanced hierarchical prefab model for making derivative object instances and propagating changes. It even has full support for real-time collaboration. Multiple people can work together in the same game project, Google Docs-style. Since all of these features are built into the data model itself, your custom, game-specific data will get them automatically, without you having to write a line of code.</p>
<h2 id="the-data-model"><a class="header" href="#the-data-model">The Data Model</a></h2>
<p>The Machinery stores its data as <strong>objects with properties</strong>. Each object has a type and the type defines what properties the object has. Available property types are <em>bools, integers, floats, strings, buffers, references</em>, <em>sub-objects</em> and <em>sets of references or sub-objects</em>.</p>
<p>The object/properties model gives us us <em>forward and backward compatibility</em> and allows us to implement operations such as <em>cloning</em> without knowing any details about the data. We can also represent modifications to the data in a uniform way <code>(object, property, old-value, new-value)</code> for undo/redo and collaboration.</p>
<p>The model is <strong>memory-based</strong> rather than disk-based. I.e. the in-memory representation of the data is considered <em>authoritative.</em> Read/write access to the data is provided by a thread-safe API. If two systems want to co-operate, they do so by talking to the same in-memory model, not by sharing files on disk. Of course, we still need to save data out disk at some point for persistence, but this is just a “backup” of the memory model and we might use different disk formats for different purposes (i.e. a git-friendly representation for collaborative work vs single binary for solo projects).</p>
<p>Since we have a memory-based model which supports cloning and change tracking, copy/paste and undo can be defined in terms of the data model. Real-time collaboration is also supported, by serializing modifications and transmitting them over the network. Since the runtime has equal access to the data model, modifying the data from within a VR session is also possible.</p>
<p>We make a clear <strong>distinction between “buffer data” and “object data”</strong>. <em>Object data</em> is stuff that can be reasoned about on a per-property level. I.e. if user A changes one property of an object, and user B changes another, we can merge those changes. <em>Buffer data</em> are binary blobs of data that are opaque to the data model. We use it for large pieces of binary data, such as textures, meshes and sound files. Since the data model cannot reason about the content of these blobs it can’t for example merge changes made to the same texture by different users.</p>
<p>Making the distinction between buffer data and object data is important because we pay an overhead for representing data as objects. We only want to pay that overhead when the benefits outweigh the costs. Most of a game’s data (in terms of bytes) is found in things like textures, meshes, audio data, etc and does not really gain anything from being stored in a JSON-like object tree.</p>
<p>In The Truth, <strong>references are represented by IDs</strong>. Each object has a unique ID and we reference other objects by their IDs. Since references have their own property type in The Truth, it is easy for us to reason about references and find all the dependencies of an object.</p>
<p>Sub-objects in The Truth are references to <em>owned</em> objects. They work just as references, but have special behaviours in some situations. For examples, when an object is cloned, all its sub-objects will be cloned too, while its references will not.</p>
<p>For more information checkout the <a href="https://ourmachinery.com/apidoc/foundation/the_truth.h.html">documentation</a> and these blog posts: <a href="https://ourmachinery.com/post/the-story-behind-the-truth-designing-a-data-model/">The Story behind The Truth: Designing a Data Model</a>  or this <a href="https://ourmachinery.com/post/multi-threading-the-truth/">one</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="access-values"><a class="header" href="#access-values">Access values</a></h1>
<p>The truth objects (<a href="https://ourmachinery.com/apidoc/foundation/api_types.h.html#structtm_tt_id_t">tm_tt_id_t</a>) are immutable objects unless you explicitly make them writable. Therefore we do not be afraid of accidently changing a value when reading from a object property.</p>
<p>To read from a object property we need access to the correct Truth Instance as well as to a object id.  We also need to know what kind of property we want to access. That is why we always want to define our properties in a Header-File. Which allows us and others to find quickly our type definitions. A good practice is to comment on what kind of data type property contains.</p>
<p>Let us assume our object is of type <code>TM_TT_TYPE__RECT</code>:</p>
<pre><code>enum {
    TM_TT_PROP__RECT__X, // float
    TM_TT_PROP__RECT__Y, // float
    TM_TT_PROP__RECT__W, // float
    TM_TT_PROP__RECT__H, // float
};
</code></pre>
<p>When we know what we want to access, we call the correct function and access the value. In our example we want to get the width of a object. The width is stored in <a href="https://ourmachinery.com/apidoc/foundation/the_truth_types.h.html#enumtm_tt_prop__rect">TM_TT_PROP__RECT__W</a>.</p>
<p>The function we need to call:</p>
<pre><code class="language-c">void (*get_float)(tm_the_truth_o *tt,const tm_the_truth_object_o *obj, uint32_t property);
</code></pre>
<p>With this knowledge we can assemble the following function that logs the width of a object:</p>
<pre><code class="language-c">void log_with(tm_the_truth_o *tt, tm_tt_id_t my_object){   
	const float wdith = tm_the_truth_api-&gt;get_float(tt,tm_tt_read(tt,my_object),TM_TT_PROP__RECT__W);
    TM_LOG(&quot;the width is %f&quot;,width);
}
</code></pre>
<h2 id="make-the-code-robust"><a class="header" href="#make-the-code-robust">Make the code robust</a></h2>
<p>To ensure we are actually handling the right type we should check this at the beginning of our function. If the type is not correct we should early out and log a warning.</p>
<p>All we need to do is compare the <a href="https://ourmachinery.com/apidoc/foundation/api_types.h.html#structtm_tt_type_t">tm_tt_type_t</a>'s of our types. Therefore we need to obtain the type id from the object id and from our expected type. From a <a href="https://ourmachinery.com/apidoc/foundation/api_types.h.html#structtm_tt_id_t">tm_tt_id_t</a> we can obtain the type by calling <code>tm_tt_type()</code> on them. <code>tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__MY_TYPE);</code> will give us back the object type from a given hash. After that we can do our comparison.</p>
<pre><code class="language-c">    void log_with(tm_the_truth_o *tt, tm_tt_id_t my_object){   
    const tm_tt_type_t type = tm_tt_type(my_object);
    const tm_tt_type_t expected_type = tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__RECT);
    
    if(type.u64 != expected_type.u64){
        TM_LOG(&quot;The provided type does not mmatch! %p{tm_tt_type_t} != %p{tm_tt_type_t}&quot;,&amp;type,&amp;expected_type);
        return;
    }
   
const 	float wdith = tm_the_truth_api-&gt;get_float(tt,tm_tt_read(tt,my_object),my_object_w,TM_TT_PROP__RECT__W);
            TM_LOG(&quot;the width is %f&quot;,width);
}
</code></pre>
<blockquote>
<p><strong>Note:</strong> Check out the logger documentation for more information on it. <a href="https://ourmachinery.com/apidoc/foundation/log.h.html#log.h">log.h</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="create-an-object"><a class="header" href="#create-an-object">Create an Object</a></h2>
<p>You can create an object of a Truth Type via two steps:</p>
<ol>
<li>You need to obtain the Type from the type hash. We call the <code>object_type_from_name_hash</code> to obtain the <a href="https://ourmachinery.com/apidoc/foundation/api_types.h.html#structtm_tt_type_t">tm_tt_type_t</a></li>
<li>You need to create an Object from that Type. We call <code>create_object_of_type</code> to create a object <a href="https://ourmachinery.com/apidoc/foundation/api_types.h.html#structtm_tt_id_t">tm_tt_id_t</a> . We pass <a href="https://ourmachinery.com/apidoc/foundation/the_truth.h.html#tm_tt_no_undo_scope">TM_TT_NO_UNDO_SCOPE</a> because we do not need a undo scope for our example.</li>
</ol>
<p>First, we need to have access to a Truth instance. Otherwise, we could not create an object. In this example, we create a function.</p>
<pre><code class="language-c">tm_tt_id_t create_my_type_object(tm_the_truth_o *tt){
    const tm_tt_type_t my_type= tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__MY_TYPE);
    const tm_tt_id_t my_type_object = tm_the_truth_api-&gt;create_object_of_type(tt, my_type, TM_TT_NO_UNDO_SCOPE);
    return my_type_object;
}
</code></pre>
<p>Where ever we call this function we can than edit and modify the type and add content to it!</p>
<p>The alternative approach is to use the &quot;Quick Object Creation function&quot;.</p>
<pre><code class="language-c">tm_tt_id_t create_my_type_object(tm_the_truth_o *tt){
    return tm_the_truth_api-&gt;quick_create_object(tt, TM_TT_NO_UNDO_SCOPE, TM_TT_TYPE_HASH__MY_TYPE, -1);
}
</code></pre>
<blockquote>
<p><strong>Note:</strong>  need to pass <code>-1</code> to tell the function that we are at the end of the creation process. More info <a href="https://ourmachinery.com/apidoc/foundation/the_truth.h.html#structtm_the_truth_api.quick_create_object()">here</a>.</p>
</blockquote>
<h2 id="what-is-next-1"><a class="header" href="#what-is-next-1">What is next?</a></h2>
<p>If you want to learn more about how to create your own custom type, follow the <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book//the_truth/custom_truth_type.html">&quot;Custom Truth Type&quot;</a> walkthrough.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modify-an-object"><a class="header" href="#modify-an-object">Modify an object</a></h1>
<p>To manipulate an object, you need to have its ID (<a href="https://ourmachinery.com/apidoc/foundation/api_types.h.html#structtm_tt_id_t">tm_tt_id_t</a>). When you create an object, you should keep its ID around if you intend to edit it later.</p>
<p><strong>Table of Content</strong></p>
<ul>
<li><a href="the_truth/modify_an_object.html#1-make-the-object-writable">1. Make the object writable</a></li>
<li><a href="the_truth/modify_an_object.html#2-write-to-the-object">2. Write to the object.</a></li>
<li><a href="the_truth/modify_an_object.html#3-save-the-change">3. Save the change</a></li>
<li><a href="the_truth/modify_an_object.html#4-get-a-value">4. Get a value</a></li>
<li><a href="the_truth/modify_an_object.html#5-make-the-code-robust">5. Make the code robust</a></li>
</ul>
<p>In this example, we have a function that gets an object and the Truth instance of that object.</p>
<pre><code class="language-c">void modify_my_object(tm_the_truth_o *tt, tm_tt_id_t my_object){
    //...
}
</code></pre>
<blockquote>
<p><strong>Important:</strong> you can only edit an object that is part of the same instance! Hence your <code>my_object</code> must be created within this instance of the Truth (<code>tt</code>).</p>
</blockquote>
<h2 id="1-make-the-object-writable"><a class="header" href="#1-make-the-object-writable">1. Make the object writable</a></h2>
<p>To edit an object, we need to make it writeable first. In the default state, objects from the Truth are immutable. The Truth API has a function that is called <code>write</code>. When we call it on an object, we make it writable.</p>
<pre><code class="language-c">void modify_my_object(tm_the_truth_o *tt, tm_tt_id_t my_object){
	tm_the_truth_object_o *my_object_w = tm_the_truth_api-&gt;write(tt, my_object);
//...
}
</code></pre>
<h2 id="2-write-to-the-object"><a class="header" href="#2-write-to-the-object">2. Write to the object.</a></h2>
<p>We need to know what kind of property we want to edit. That is why we always want to define our properties in a Header-File. A good practice is to comment on what kind of data type property contains.</p>
<p>Let us assume our object is of type <code>TM_TT_TYPE__RECT</code>:</p>
<pre><code>enum {
    TM_TT_PROP__RECT__X, // float
    TM_TT_PROP__RECT__Y, // float
    TM_TT_PROP__RECT__W, // float
    TM_TT_PROP__RECT__H, // float
};
</code></pre>
<p>In our example we want to set the width to <code>100</code>. The width is stored in <a href="https://ourmachinery.com/apidoc/foundation/the_truth_types.h.html#enumtm_tt_prop__rect">TM_TT_PROP__RECT__W</a>.</p>
<p>When we know what we want to edit, we call the correct function and change the value.</p>
<p>The function we need to call:</p>
<pre><code class="language-c">void (*set_float)(tm_the_truth_o *tt, tm_the_truth_object_o *obj, uint32_t property,float value);
</code></pre>
<p>Let us bring all of this together:</p>
<pre><code class="language-c">void modify_my_object(tm_the_truth_o *tt, tm_tt_id_t my_object){
	tm_the_truth_object_o *my_object_w = tm_the_truth_api-&gt;write(tt, my_object);
    tm_the_truth_api-&gt;set_float(tt,my_object_w,TM_TT_PROP__RECT__W,100);
    //...
}
</code></pre>
<h2 id="3-save-the-change"><a class="header" href="#3-save-the-change">3. Save the change</a></h2>
<p>In the end, we need to commit our change to the system. In this example we do not care about the undo scope. That is why we provide the <a href="https://ourmachinery.com/apidoc/foundation/the_truth.h.html#tm_tt_no_undo_scope">TM_TT_NO_UNDO_SCOPE</a> define. This means this action is not undoable.</p>
<pre><code class="language-c">void modify_my_object(tm_the_truth_o *tt, tm_tt_id_t my_object){
	tm_the_truth_object_o *my_object_w = tm_the_truth_api-&gt;write(tt, my_object);
    tm_the_truth_api-&gt;set_float(tt,my_object_w,TM_TT_PROP__RECT__W,100);
    tm_the_truth_api-&gt;commit(tt, my_object_w, TM_TT_NO_UNDO_SCOPE);
}
</code></pre>
<p>If we wanted to provide a undo scope we need to create one:</p>
<pre><code class="language-c">void modify_my_object(tm_the_truth_o *tt, tm_tt_id_t my_object){
	tm_the_truth_object_o *my_object_w = tm_the_truth_api-&gt;write(tt, my_object);
    tm_the_truth_api-&gt;set_float(tt,my_object_w,TM_TT_PROP__RECT__W,100);
    const tm_tt_undo_scope_t undo_scope = tm_the_truth_api-&gt;create_undo_scope(tt,&quot;My Undo Scope&quot;);
    tm_the_truth_api-&gt;commit(tt, my_object_w, undo_scope);
}
</code></pre>
<p>Now this action can be reverted in the Editor.</p>
<h2 id="4-get-a-value"><a class="header" href="#4-get-a-value">4. Get a value</a></h2>
<p>Instead of changing the value  of width to 100 we can also increment it by 100! All we need to do is get the value first of the Truth Object and add 100 to it. To access a property we need to use the macro <a href="https://ourmachinery.com/apidoc/foundation/the_truth.h.html#tm_tt_read()">tm_tt_read</a>. This will give us a immutable (read only) pointer to the underlaying object. This allows us to read the data from it.</p>
<pre><code class="language-c">void modify_my_object(tm_the_truth_o *tt, tm_tt_id_t my_object){
	float wdith = tm_the_truth_api-&gt;get_float(tt,tm_tt_read(tt,my_object),my_object_w,TM_TT_PROP__RECT__W);
    wdith += 100;
	tm_the_truth_object_o *my_object_w = tm_the_truth_api-&gt;write(tt, my_object);
    tm_the_truth_api-&gt;set_float(tt,my_object_w,TM_TT_PROP__RECT__W,wdith);
    const tm_tt_undo_scope_t undo_scope = tm_the_truth_api-&gt;create_undo_scope(tt,&quot;My Undo Scope&quot;);
    tm_the_truth_api-&gt;commit(tt, my_object_w, undo_scope);
}
</code></pre>
<blockquote>
<p><strong>Note:</strong> If we had a lot of read actions we should only call <a href="https://ourmachinery.com/apidoc/foundation/the_truth.h.html#tm_tt_read()">tm_tt_read</a> once and store the result in a  <code>const tm_the_truth_object_o*</code> variable and reuse.</p>
</blockquote>
<h2 id="5-make-the-code-robust"><a class="header" href="#5-make-the-code-robust">5. Make the code robust</a></h2>
<p>To ensure we are actually handling the right type we should check this at the beginning of our function. If the type is not correct we should early out.</p>
<p>All we need to do is compare the <a href="https://ourmachinery.com/apidoc/foundation/api_types.h.html#structtm_tt_type_t">tm_tt_type_t</a>'s of our types. Therefore we need to obtain the type id from the object id and from our expected type. From a <a href="https://ourmachinery.com/apidoc/foundation/api_types.h.html#structtm_tt_id_t">tm_tt_id_t</a> we can obtain the type by calling <code>tm_tt_type()</code> on them. <code>tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__MY_TYPE);</code> will give us back the object type from a given hash. After that we can do our comparison.</p>
<pre><code class="language-c">void modify_my_object(tm_the_truth_o *tt, tm_tt_id_t my_object){
    const tm_tt_type_t type = tm_tt_type(my_object);
    const tm_tt_type_t expected_type = tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__RECT);
    
    if(type.u64 != expected_type.u64)
        return;
   
	float wdith = tm_the_truth_api-&gt;get_float(tt,tm_tt_read(tt,my_object),my_object_w,TM_TT_PROP__RECT__W);
    wdith += 100;
	tm_the_truth_object_o *my_object_w = tm_the_truth_api-&gt;write(tt, my_object);
    tm_the_truth_api-&gt;set_float(tt,my_object_w,TM_TT_PROP__RECT__W,wdith);
    const tm_tt_undo_scope_t undo_scope = tm_the_truth_api-&gt;create_undo_scope(tt,&quot;My Undo Scope&quot;);
    tm_the_truth_api-&gt;commit(tt, my_object_w, undo_scope);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="common-types"><a class="header" href="#common-types">Common Types</a></h1>
<p>The Truth comes with several useful common types. You can find them in the <a href="https://ourmachinery.com/apidoc/foundation/the_truth_types.h.html#the_truth_types.h">the_truth_types.h</a> (<a href="https://ourmachinery.com/apidoc/foundation/the_truth_types.h.html#structtm_the_truth_common_types_api">API Documentation</a>).</p>
<table><thead><tr><th>Macro</th><th>Description</th></tr></thead><tbody>
<tr><td>[<a href="https://ourmachinery.com/apidoc/foundation/the_truth_types.h.html#tm_tt_type__bool">TM_TT_TYPE__BOOL</a>](https://ourmachinery.com/apidoc/foundation/the_truth_types.h.html#tm_tt_type__bool) /<a href="https://ourmachinery.com/apidoc/foundation/the_truth_types.h.html#tm_tt_type__bool"><code>TM_TT_TYPE_HASH__BOOL</code></a></td><td>The first property contains the value.</td></tr>
<tr><td><a href="https://ourmachinery.com/apidoc/foundation/the_truth_types.h.html#tm_tt_type__uint32_t"><code>TM_TT_TYPE__UINT32_T</code></a> /<a href="https://ourmachinery.com/apidoc/foundation/the_truth_types.h.html#tm_tt_type__uint32_t"><code>TM_TT_TYPE_HASH__UINT32_T</code></a></td><td>The first property contains the value.</td></tr>
<tr><td><a href="https://ourmachinery.com/apidoc/foundation/the_truth_types.h.html#tm_tt_type__uint64_t"><code>TM_TT_TYPE__UINT64_T</code></a> /<a href="https://ourmachinery.com/apidoc/foundation/the_truth_types.h.html#tm_tt_type__uint64_t"><code>TM_TT_TYPE_HASH__UINT64_T</code></a></td><td>The first property contains the value.</td></tr>
<tr><td>[<a href="https://ourmachinery.com/apidoc/foundation/the_truth_types.h.html#tm_tt_type__float">TM_TT_TYPE__FLOAT</a>](https://ourmachinery.com/apidoc/foundation/the_truth_types.h.html#tm_tt_type__float) /<a href="https://ourmachinery.com/apidoc/foundation/the_truth_types.h.html#tm_tt_type__float"><code>TM_TT_TYPE_HASH__FLOAT</code></a></td><td>The first property contains the value.</td></tr>
<tr><td>[<a href="https://ourmachinery.com/apidoc/foundation/the_truth_types.h.html#tm_tt_type__double">TM_TT_TYPE__DOUBLE</a>](https://ourmachinery.com/apidoc/foundation/the_truth_types.h.html#tm_tt_type__double) /<a href="https://ourmachinery.com/apidoc/foundation/the_truth_types.h.html#tm_tt_type__double"><code>TM_TT_TYPE_HASH__DOUBLE</code></a></td><td>The first property contains the value.</td></tr>
<tr><td>[<a href="https://ourmachinery.com/apidoc/foundation/the_truth_types.h.html#tm_tt_type__string">TM_TT_TYPE__STRING</a>](https://ourmachinery.com/apidoc/foundation/the_truth_types.h.html#tm_tt_type__string) /<a href="https://ourmachinery.com/apidoc/foundation/the_truth_types.h.html#tm_tt_type__string"><code>TM_TT_TYPE_HASH__STRING</code></a></td><td>The first property contains the value.</td></tr>
<tr><td><a href="https://ourmachinery.com/apidoc/foundation/the_truth_types.h.html#tm_tt_type__vec2"><code>TM_TT_TYPE__VEC2</code></a> /<a href="https://ourmachinery.com/apidoc/foundation/the_truth_types.h.html#tm_tt_type__vec2"><code>TM_TT_TYPE_HASH__VEC2</code></a></td><td>The first property contains the x value and the second the y value.</td></tr>
<tr><td><a href="https://ourmachinery.com/apidoc/foundation/the_truth_types.h.html#tm_tt_type__vec3"><code>TM_TT_TYPE__VEC3</code></a> /<a href="https://ourmachinery.com/apidoc/foundation/the_truth_types.h.html#tm_tt_type__vec3"><code>TM_TT_TYPE_HASH__VEC3</code></a></td><td>The first property contains the x value and the second the y value and the third the z value.</td></tr>
<tr><td><a href="https://ourmachinery.com/apidoc/foundation/the_truth_types.h.html#tm_tt_type__vec4"><code>TM_TT_TYPE__VEC4</code></a> /<a href="https://ourmachinery.com/apidoc/foundation/the_truth_types.h.html#tm_tt_type__vec4"><code>TM_TT_TYPE_HASH__VEC4</code></a></td><td>The first property contains the x value and the second the y value and the third the z value while the last one contains the w value.</td></tr>
<tr><td>[<a href="https://ourmachinery.com/apidoc/foundation/the_truth_types.h.html#tm_tt_type__position">TM_TT_TYPE__POSITION</a>](https://ourmachinery.com/apidoc/foundation/the_truth_types.h.html#tm_tt_type__position) /<a href="https://ourmachinery.com/apidoc/foundation/the_truth_types.h.html#tm_tt_type__position"><code>TM_TT_TYPE_HASH__POSITION</code></a></td><td>Same as <code>vec4</code>.</td></tr>
<tr><td>[<a href="https://ourmachinery.com/apidoc/foundation/the_truth_types.h.html#tm_tt_type__rotation">TM_TT_TYPE__ROTATION</a>](https://ourmachinery.com/apidoc/foundation/the_truth_types.h.html#tm_tt_type__rotation) /<a href="https://ourmachinery.com/apidoc/foundation/the_truth_types.h.html#tm_tt_type__rotation"><code>TM_TT_TYPE_HASH__ROTATION</code></a></td><td>Based on a <code>vec4</code>. Used to represent the rotation of a object via quaternions.</td></tr>
<tr><td>[<a href="https://ourmachinery.com/apidoc/foundation/the_truth_types.h.html#tm_tt_type__scale">TM_TT_TYPE__SCALE</a>](https://ourmachinery.com/apidoc/foundation/the_truth_types.h.html#tm_tt_type__scale) /<a href="https://ourmachinery.com/apidoc/foundation/the_truth_types.h.html#tm_tt_type__scale"><code>TM_TT_TYPE_HASH__SCALE</code></a></td><td>Same as <code>vec3.</code></td></tr>
<tr><td>[<a href="https://ourmachinery.com/apidoc/foundation/the_truth_types.h.html#tm_tt_type__color_rgb">TM_TT_TYPE__COLOR_RGB</a>](https://ourmachinery.com/apidoc/foundation/the_truth_types.h.html#tm_tt_type__color_rgb) /<a href="https://ourmachinery.com/apidoc/foundation/the_truth_types.h.html#tm_tt_type__color_rgb"><code>TM_TT_TYPE_HASH__COLOR_RGB</code></a></td><td>Represents a RGB colour.</td></tr>
<tr><td>[<a href="https://ourmachinery.com/apidoc/foundation/the_truth_types.h.html#tm_tt_type__color_rgba">TM_TT_TYPE__COLOR_RGBA</a>](https://ourmachinery.com/apidoc/foundation/the_truth_types.h.html#tm_tt_type__color_rgba) /<a href="https://ourmachinery.com/apidoc/foundation/the_truth_types.h.html#tm_tt_type__color_rgba"><code>TM_TT_TYPE_HASH__COLOR_RGBA</code></a></td><td>Represents a RGBA colour.</td></tr>
<tr><td>[<a href="https://ourmachinery.com/apidoc/foundation/the_truth_types.h.html#tm_tt_type__rect">TM_TT_TYPE__RECT</a>](https://ourmachinery.com/apidoc/foundation/the_truth_types.h.html#tm_tt_type__rect) /<a href="https://ourmachinery.com/apidoc/foundation/the_truth_types.h.html#tm_tt_type__rect"><code>TM_TT_TYPE_HASH__RECT</code></a></td><td>The first property contains the x value and the second the y value and the third the width value while the last one contains the height value.</td></tr>
</tbody></table>
<p>There is a helper API to handle all of these types in a easy way, to reduce the boilerplate code: <a href="https://ourmachinery.com/apidoc/foundation/the_truth_types.h.html#structtm_the_truth_common_types_api">tm_the_truth_common_types_api</a>. </p>
<blockquote>
<p><strong>Note:</strong> There is a list of all Truth Types the Engine comes with available on our <a href="https://ourmachinery.com/apidoc/truth_types.html">API Documentation</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aspects"><a class="header" href="#aspects">Aspects</a></h1>
<p>An “aspect” is an interface (struct of function pointers) identified by a unique identifier. The Truth allows you to associate aspects with object types. This lets you extend The Truth with new functionality. For example, you could add an interface for debug printing an object:</p>
<pre><code class="language-c"> #define TM_TT_ASPECT__DEBUG_PRINT TM_STATIC_HASH(&quot;tm_debug_print_aspect_i&quot;, 0x39821c78639e0773ULL)

 typedef struct tm_debug_print_aspect_i {
    void (*debug_print)(tm_the_truth_o *tt, uint64_t o);
} tm_debug_print_aspect_i;
</code></pre>
<p>You could then use this code to debug print an object <code>o</code> with:</p>
<pre><code class="language-c">tm_debug_print_aspect_i *dp = tm_the_truth_api-&gt;get_aspect(tt, tm_tt_type(o), TM_DEBUG_PRINT_ASPECT);
if (dp)
    dp-&gt;debug_print(tt, o);
</code></pre>
<blockquote>
<p><strong>Note</strong>: that plugins can extend the system with completely new aspects.</p>
</blockquote>
<p>The best example of how the Engine is using the aspect system is the <a href="https://ourmachinery.com/apidoc/plugins/editor_views/properties.h.html#tm_tt_aspect__properties">TM_TT_ASPECT__PROPERTIES</a> which helps us to defines custom UIs for Truth objects.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-a-custom-truth-type"><a class="header" href="#create-a-custom-truth-type">Create a custom Truth Type</a></h1>
<p>This walkthrough shows you how to create a type for the Truth. The Truth is our centralized data model for editing data in the Engine. For more details on the system itself, click here: <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/the_truth/index.html">The Truth</a>. </p>
<p>You should have basic knowledge about how to write a custom plugin. If not, you might want to check this <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/extending_the_machinery/the_plugin_system.html">Guide</a>. </p>
<p>We will cover the following topics:</p>
<ul>
<li>How to define a Type.</li>
<li>Type Properties</li>
</ul>
<p>After this walkthrough you could checkout the <a href="https://ourmachinery.github.io/themachinery-books/tutorials//the_truth/custom_asset/index.html">&quot;Create a custom asset&quot;</a> tutorial! </p>
<p><strong>Table of Content</strong></p>
<ul>
<li><a href="the_truth/custom_truth_type.html#define-a-type">Define a Type</a></li>
<li><a href="the_truth/custom_truth_type.html#about-properties">About Properties</a></li>
<li><a href="the_truth/custom_truth_type.html#adding-properties">Adding properties</a></li>
<li><a href="the_truth/custom_truth_type.html#what-is-next">What is next?</a></li>
</ul>
<h2 id="define-a-type"><a class="header" href="#define-a-type">Define a Type</a></h2>
<p>A Truth-Type in The Machinery consists out of a name (its identifier) and properties. </p>
<blockquote>
<p><strong>Note:</strong> In theory, you could also define a Type without properties.</p>
</blockquote>
<p>To add a Type to the system, you need access to the Truth instance. The Engine may have more than one instance of a Truth. </p>
<blockquote>
<p><strong>Example:</strong> There is a Project Truth to keep all the project-related settings and an Engine/Application Truth that holds all the application-wide settings.</p>
</blockquote>
<p>Generally speaking, you want to define Truth Types at the beginning of the Engine's life cycle. Therefore the designated place is the <code>tm_load_plugin</code> function. The Truth has an <em>interface</em> to register a truth type creation function: <a href="https://ourmachinery.com/apidoc/foundation/the_truth.h.html#tm_the_truth_create_types_interface_name">TM_THE_TRUTH_CREATE_TYPES_INTERFACE_NAME</a>. </p>
<p>This interface expects a function of the signature: <code>void create_truth_types(tm_the_truth_o *tt)</code>. Whenever the Engine creates a Truth, it invokes this interface on all loaded plugins, and their types are registered. You do not need to register your Type to the interface if you want to register your Type to a specific Truth.</p>
<blockquote>
<p><strong>Note:</strong> Mostly this function is called: <code>create_truth_types</code></p>
</blockquote>
<p>Let us define a type. To do that, we need to get the <code>tm_truth_api</code> first:</p>
<pre><code class="language-c">// beginning of the source file
static struct tm_the_truth_api *tm_the_truth_api;
#include &lt;foundation/api_registry.h&gt;
#include &lt;foundation/the_truth.h&gt;
// ... other code
TM_DLL_EXPORT void tm_load_plugin(struct tm_api_registry_api *reg, bool load)
{
 tm_the_truth_api = reg-&gt;get(TM_THE_TRUTH_API_NAME);
}
</code></pre>
<p>After this, we define our type name once as a constant char define and one hashed version. There are some conventions to keep in mind:</p>
<ol>
<li>The plain text define should start with: <code>TM_TT_TYPE__</code>.</li>
<li>The hashed define should start with: <code>TM_TT_TYPE_HASH__</code></li>
<li>The name may or may not start with <code>tm_</code> but the name plain text and the hashed version need to match!</li>
</ol>
<pre><code class="language-c">#define TM_TT_TYPE__MY_TYPE &quot;tm_my_type&quot;
#define TM_TT_TYPE_HASH___MY_TYPE TM_STATIC_HASH(&quot;tm_my_type&quot;, 0xde0e763ccd72b89aULL)
</code></pre>
<blockquote>
<p><strong>Tip:</strong> Do not forget to run <code>hash.exe.</code> Otherwise, the <a href="https://ourmachinery.com/apidoc/foundation/api_types.h.html#tm_static_hash()">TM_STATIC_HASH</a> macro will cause an error. You can also run <code>tmbuild --gen-hash</code></p>
</blockquote>
<p>It is good practice to place the types into a header file so others can use these types as well!  When that is done we can call the <code>tm_the_truth_api-&gt;create_object_type()</code> to create the actual type. It will return a <a href="https://ourmachinery.com/apidoc/foundation/api_types.h.html#structtm_tt_type_t">tm_tt_type_t</a> which is the identifier of our type. The <a href="https://ourmachinery.com/apidoc/foundation/api_types.h.html#structtm_tt_id_t">tm_tt_id_t</a> will also refer to the type here! </p>
<p>The function expects:</p>
<table><thead><tr><th>Argument</th><th>Description</th></tr></thead><tbody>
<tr><td><code>tm_the_truth_o *tt</code></td><td>The Truth instance. This function will add the type to this instance</td></tr>
<tr><td><code>const char *name</code></td><td>The name of the type. It will be hashed internally. Therefore the hash value of <code>TM_TT_TYPE__</code>  and <code>TM_TT_TYPE_HASH___</code> should match!  <em>If a type with <code>name</code> already exists, that type is returned. Different types with the same are not supported!</em></td></tr>
<tr><td><code>const tm_the_truth_property_definition_t *properties</code></td><td>The definitions of the properties of the type.</td></tr>
<tr><td><code> uint32_t num_properties</code></td><td>The number of properties. Should match <code>properties</code></td></tr>
</tbody></table>
<p>The home of this function should be our <code>void create_truth_types(tm_the_truth_o *tt)</code> . We need to add this one to our source file. After this we add the call to <code>create_object_type</code> to it. Remember that we have no properties yet, and our call would look like this:</p>
<pre><code class="language-c">void create_truth_types(tm_the_truth_o *tt){
	tm_the_truth_api-&gt;create_object_type(tt, TM_TT_TYPE__MY_TYPE, 0, 0);
}
</code></pre>
<p>The last step is to tell the plugin system that we intend to register our <code>register_truth_type()</code>.</p>
<pre><code class="language-c">TM_DLL_EXPORT void tm_load_plugin(struct tm_api_registry_api *reg, bool load)
{
 tm_the_truth_api = reg-&gt;get(TM_THE_TRUTH_API_NAME);
 tm_add_or_remove_implementation(reg, load, TM_THE_TRUTH_CREATE_TYPES_INTERFACE_NAME, create_truth_types);
}
</code></pre>
<p>The full source code should look like this:</p>
<p><code>my_type.h</code></p>
<pre><code class="language-c">#pragma once
#include &lt;foundation/api_types.h&gt;
#define TM_TT_TYPE__MY_TYPE &quot;tm_my_type&quot;
#define TM_TT_TYPE_HASH___MY_TYPE TM_STATIC_HASH(&quot;tm_my_type&quot;, 0xde0e763ccd72b89aULL)
</code></pre>
<p>(Tip: Do not forget to run hash.exe)</p>
<p><code>my_type.c</code></p>
<pre><code class="language-c">// beginning of the source file
static struct tm_the_truth_api *tm_the_truth_api;
#include &lt;foundation/api_registry.h&gt;
#include &lt;foundation/the_truth.h&gt;

void create_truth_types(tm_the_truth_o *tt){
	tm_the_truth_api-&gt;create_object_type(tt, TM_TT_TYPE__MY_TYPE, 0, 0);
}

TM_DLL_EXPORT void tm_load_plugin(struct tm_api_registry_api *reg, bool load)
{
 tm_the_truth_api = reg-&gt;get(TM_THE_TRUTH_API_NAME);
 tm_add_or_remove_implementation(reg, load, TM_THE_TRUTH_CREATE_TYPES_INTERFACE_NAME, create_truth_types);
}
</code></pre>
<p>After all of this you have registered your type and it could be used. This type is just not really useful without properties.</p>
<h2 id="about-properties"><a class="header" href="#about-properties">About Properties</a></h2>
<p>In The Truth, an Object-Type is made of one or multiple properties. Properties can represent the basic types:</p>
<ul>
<li><code>bool</code>, <code>string</code>, <code>float</code>, <code>UINT64</code>, <code>UNIT32</code>, <code>double</code>, `<code>buffer\</code></li>
<li><code>subobject</code> - An object that lives within this property </li>
<li><code>reference</code> - A reference to another object</li>
<li><code>subobject set</code> - A Set of subobjects</li>
<li><code>reference set</code> - A Set of references.</li>
</ul>
<p><em>What is the difference between a reference and a subobject?</em></p>
<p>To see the difference, consider how <a href="https://ourmachinery.com/apidoc/foundation/the_truth.h.html#structtm_the_truth_api.clone_object()">clone_object()</a> works in both cases:</p>
<ul>
<li>When you clone an object with references, the clone will reference the same objects as the original, i.e. they now have multiple references to them.</li>
<li>When you clone an object with subobjects, all the subobjects will be cloned too. After the clone operation, there is no link between the object's subobjects and the clone's subobjects.</li>
</ul>
<p>An arbitrary number of objects can reference the same object, but a subobject only has a single owner.</p>
<p>When you destroy an object, any references to that object become NIL references — i.e., they no longer refer to anything.</p>
<p>When you destroy an object that has subobjects, all the subobjects are destroyed with it.</p>
<blockquote>
<p><strong>Note:</strong> For more information please check: <a href="https://ourmachinery.com/apidoc/foundation/the_truth.h.html#the_truth.h">The API Documentation</a> </p>
</blockquote>
<h2 id="adding-properties"><a class="header" href="#adding-properties">Adding properties</a></h2>
<p>Let us add some properties to our Type! As you remember, when we created the Type, the function <code>create_object_type()</code> required a pointer to the definition of properties. You can define properties via the <a href="https://ourmachinery.com/apidoc/foundation/the_truth.h.html#structtm_the_truth_property_definition_t">tm_the_truth_property_definition_t</a> struct.</p>
<pre><code class="language-c">typedef struct tm_the_truth_property_definition_t
{
    // Name of the property, e.g. &quot;cast_shadows&quot;.
    //
    // This name is used both for serialization and for the UI of editing the property. When
    // displayed in the UI, the name will be automatically capitalized (e.g. &quot;Cast Shadows&quot;).
    //
    // The name shouldn't be longer than [[TM_THE_TRUTH_PROPERTY_NAME_LENGTH]] characters.
    const char *name;

    // [[enum tm_the_truth_property_type]] type of the property.
    uint32_t type;

    // [[enum tm_the_truth_editor]] enum defining what editor should be used for editing the property.
    uint32_t editor;

    // Editor specific settings.
    union
    {
        tm_the_truth_editor_enum_t enum_editor;
        tm_the_truth_editor_string_open_path_t string_open_path_editor;
        tm_the_truth_editor_string_save_path_t string_save_path_editor;
    };

    // For properties referring to other objects (references &amp; subobjects), specifies the type of
    // objects that they can refer to. A value of [[TM_TT_TYPE__ANYTHING]] is used for an object
    // that can refer to anything.
    //
    // Note: We currently don't have any system for representing &quot;interfaces&quot; or groups of types.
    // I.e. you can't say &quot;I want this to reference any type that inherits from the GRAPH_NODE_TYPE,
    // but no other types.&quot; We may add this in the future.
    tm_strhash_t type_hash;

    // Specifies that the property is allowed to refer to other types than the `type_hash`.
    //
    // !!! NOTE: Note
    //     This flag should not be used going forward. Instead, if a property can refer to multiple
    //     types, you should use a `type_hash` of [[TM_TT_TYPE__ANYTHING]]. It is provided for
    //     compatibility purposes, because some object types have a `type_hash` specified but
    //     store subobjects of other types. We cannot simply change the `type_hash` of those objects
    //     to [[TM_TT_TYPE__ANYTHING]], because there may be saved data that has serialized versions
    //     of those objects that omits the object type (if it is `type_hash`). We can't deserialize
    //     those objects if we don't know the `type_hash` of the type.
    bool allow_other_types;
    TM_PAD(7);

    // For buffer properties, the extension (if any) used to represent the buffer type. This can
    // either be hard-coded in `buffer_extension`, or computed by the `buffer_extension_f()`
    // callback (set the unused option to `NULL`).
    const char *buffer_extension;
    const char *(*buffer_extension_f)(const tm_the_truth_o *tt, tm_tt_id_t object, uint32_t property);

    // Tooltip used to describe the property in more detail. The tooltip text will be displayed in
    // the property editor when the property is hovered over.
    //
    // The tooltip should be registered using [[TM_LOCALIZE_LATER()]]. It will be dynamically
    // localized to the current interface language with [[TM_LOCALIZE_DYNAMIC()]] before being
    // displayed in the UI.
    const char *tooltip;

    // If *true*, this property will be skipped during serialization.
    bool not_serialized;
    TM_PAD(7);

    // If specified, this will be used instead of `name` for the UI.
    const char *ui_name;
} tm_the_truth_property_definition_t;
</code></pre>
<p>(<a href="https://ourmachinery.com/apidoc/foundation/the_truth.h.html#structtm_the_truth_property_definition_t">API Documentation</a>)</p>
<p>Within our <code>create_truth_types</code> we create a array of type <a href="https://ourmachinery.com/apidoc/foundation/the_truth.h.html#structtm_the_truth_property_definition_t">tm_the_truth_property_definition_t</a>. For this example, we define the properties of type bool and string.</p>
<pre><code class="language-c">// include [macros.h](https://ourmachinery.com/apidoc/foundation/macros.h.html#macros.h) to access TM_ARRAY_COUNT for convinace:
#include &lt;foundation/macros.h&gt;
//..code
void create_truth_types(tm_the_truth_o *tt){
    tm_the_truth_property_definition_t properties[] = {
        { &quot;my_bool&quot;, TM_THE_TRUTH_PROPERTY_TYPE_BOOL },
        { &quot;my_string&quot;, TM_THE_TRUTH_PROPERTY_TYPE_STRING },
    };
	tm_the_truth_api-&gt;create_object_type(tt, TM_TT_TYPE__MY_TYPE, properties,TM_ARRAY_COUNT(properties);
}
</code></pre>
<p>That is all we need to do to define properties for our Type! Also thanks to our automatic &quot;reflection&quot; system you do not have to worry about providing a UI for the type. The Properties View will automatically provide a UI for this type.</p>
<h2 id="what-is-next-2"><a class="header" href="#what-is-next-2">What is next?</a></h2>
<p>You can find more in depth and practical tutorials in the <a href="https://ourmachinery.github.io/themachinery-books/tutorials//the_truth/index.html">tutorial book</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creation-graphs-1"><a class="header" href="#creation-graphs-1">Creation Graphs</a></h1>
<p>The creation graph is (as the name implies) a graph based tool for creating assets. It allows developers to define and alter various types of assets using visual scripting. More broadly speaking, the creation graph can be used for arbitrary data processing tasks.</p>
<p>A creation graph thus defines the asset’s pipeline into its final state. For instance, an image asset will have a file that defines the data of the image, but the creation graph asset specifies how that data should be processed. Should it generate mipmaps, should it be compressed, do we need a CPU copy of it, etc.</p>
<p>A more familiar example might be a material shader. In The Machinery this is also defined using a creation graph. This case maps very well to Unity’s shader assets and Unreal’s material assets. In the image below you can see a simple default material with a saturated red base color.</p>
<p><img src="https://www.dropbox.com/s/w5ty4r8tttntt0t/tm_guide_creation_graph_simple_material.png?dl=1" alt="Simple red material" /></p>
<p>Image loading and material creation are just a few examples of what can be achieved with the creation graph. The table below shows when a creation graph is used compared to the tools one could use in Unity and Unreal.</p>
<table><thead><tr><th>Asset Type</th><th>Unity</th><th>Unreal</th><th>The Machinery</th></tr></thead><tbody>
<tr><td>Images</td><td>Texture</td><td>Texture</td><td>Creation graphs</td></tr>
<tr><td>Materials</td><td>Shader</td><td>Material</td><td>Creation graphs</td></tr>
<tr><td>Particles</td><td>Particle Effect</td><td>Cascade</td><td>Creation graphs</td></tr>
<tr><td>Post processing</td><td>Shader</td><td>Material</td><td>Creation graphs</td></tr>
<tr><td>Procedural materials</td><td>Procedural Materials</td><td>Material</td><td>Creation graphs</td></tr>
<tr><td>Meshes</td><td>Mesh</td><td>Static Mesh</td><td>DCC Asset + <br>Creation graphs</td></tr>
</tbody></table>
<p>Another example for the creation graph is mesh processing. A graph like this will define how the mesh should be draw or traced against. The graph below takes two inputs, a material creation graph and the mesh data from a DCC asset. This data is than imported and passed to the various outputs of our mesh pipeline. In this case those are: a ray tracing instance, a normal draw call, a bounding volume, and a physics shape. Note that not all of these outputs have to be used, rather the code that uses this creation graph might only look for the rendering outputs and ignore the physics shape, whilst some other code might only care about the physics shape output.</p>
<p><img src="https://www.dropbox.com/s/103bvtqaz6lnsog/tm_guide_creation_graph_mesh_processing.png?dl=1" alt="Mesh processing" /></p>
<p>Like the entity graph, the creation graph can executes nodes in sequence from an event. Some examples of this are the <code>Tick</code>, <code>Init</code>, and <code>Compile</code> events which are executed at known intervals. Most of the creation graphs however work with a reverse flow, compiling the graph into a sequence of nodes for a specific output. The two examples presented earlier show this workflow. Some outputs are: <code>Draw Call</code>, <code>Shader Instance</code>, <code>Image</code>, and <code>Physics Shape</code>. Note that these outputs are just blobs of data, an implementation can define more output type in code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creation-graphs-for-unity-developers"><a class="header" href="#creation-graphs-for-unity-developers">Creation Graphs for Unity Developers</a></h1>
<p>Creation graphs are used for many different assets in The Machinery. When a creation graph is used for a surface shader it most closely relates to Unity’s shader graph. This is what we will focus on first.</p>
<p><img src="https://www.dropbox.com/s/lg5dir5rxbz8c6l/tm_guide_creation_graph_unity.png?dl=1" alt="Simple surface shader" /></p>
<p>In the example above the editor’s layout was made to resemble Unity’s shader graph view. When creating a material shader you need to specify a <code>Shader Instance</code> output node. From here we can specify out surface shader, in the example above the <code>Lit</code> node closely resembles Unity’s <code>PBR Master</code> node.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creation-graphs-for-unreal-engine-developers"><a class="header" href="#creation-graphs-for-unreal-engine-developers">Creation Graphs for Unreal Engine developers</a></h1>
<p>Creation graphs are used for many different assets in The Machinery. When a creation graph is used for a shader it most closely relates to Unreal’s materials (any domain). This is what we will focus on first.</p>
<p><img src="https://www.dropbox.com/s/nxy6jtq7f5drmin/tm_guide_creation_graph_unreal_material.png?dl=1" alt="Simple brick material" /></p>
<p>In the example above the editor closely resembles the material editor from Unreal, this is however not the default layout. You can see the creation graph in the center with its output being a <code>Shader Instance</code>. Adding this allows any consuming code to query the material from this creation graph and it will allow the preview tab to display your material. </p>
<p><img src="https://www.dropbox.com/s/kpf05fwzl47d0ip/tm_guide_creation_graph_unreal_particle.png?dl=1" alt="Simple rotating particle" /></p>
<p>The previous example showed a surface or material shader. This example shows a creation graph that fully defines a simple particle. The <code>Shader Instance</code> (material) is now passed to a <code>Draw Call</code> node, with this combination we can now fully render the particle without the need of an explicit mesh. Instead we use the <code>Construct Quad</code> node for a procedural quad mesh. Note that we specify the <code>Instance Count</code> and <code>Num Vertices</code> (for a single quad that is 6).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="node-types"><a class="header" href="#node-types">Node types</a></h1>
<p>Nodes in the creation graph can be subdivided into four types, understanding the difference between these nodes is important when creating new nodes. The diagram below shows how each node can be categorized.</p>
<p><img src="https://www.dropbox.com/s/h4uni5g7syk0zgn/tm_guide_creation_graph_node_types_graph.png?dl=1" alt="" /></p>
<p>GPU nodes are somewhat special as they will be compiled down into a single shader instead of being interpreted like the CPU part of the creation graph. Note that GPU nodes also have a different background color to distinguish them. GPU nodes will not connect to any CPU node unless their output is a <code>Shader Instance</code>, this is the point where the GPU portion of the graph is compiled and passed to the CPU.</p>
<p>The CPU portion of a creation graph is very similar to the entity graph in terms of layout with one exception. The creation graph often works by querying <code>output nodes</code> from the creation graph and working its way back from there. <code>event nodes</code> on the other hand allow you to follow the same flow as the entity graph, beginning from some event and continuing into other nodes. </p>
<p><img src="https://www.dropbox.com/s/poi2rg73gttdixz/tm_guide_creation_graph_node_types_practical.png?dl=1" alt="" /></p>
<p>In the example above you can see a creation graph that could be passed to a <code>render component</code> because it uses the <code>Draw Call</code> and <code>Bounding Volume</code> output nodes. The parameters to these are: a DCC mesh and a <code>Lit Shader Instance</code>. Note the <code>Variable</code> GPU node that is used to pass the color from the CPU side to the GPU side, this is the only way to connect CPU nodes to GPU nodes.
Currently we support the following output nodes, note that multiple of these can be present in a single creation graph.</p>
<table><thead><tr><th><strong>Name</strong></th><th><strong>Information</strong></th></tr></thead><tbody>
<tr><td>Image Output</td><td>Allows preview, creates asset thumbnail.</td></tr>
<tr><td>Bounding Volume</td><td>Used for culling.</td></tr>
<tr><td>Draw Call</td><td>Generally used with the <code>Render Component</code>, allows preview.</td></tr>
<tr><td>Shader Instance</td><td>Generally a material, allows preview.</td></tr>
<tr><td>Physics Shape</td><td>Generally used with a <code>Physics Shape Component</code>.</td></tr>
<tr><td>Ray Trace Instance</td><td>Used to generate acceleration structures and hit shaders.</td></tr>
<tr><td>Entity Spawner - Output Transforms</td><td>Can be used to query transforms from the <code>Entity Spawner</code> node.</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shader-system-interaction"><a class="header" href="#shader-system-interaction">Shader system interaction</a></h1>
<p>A creation graph interacts with the shader system in three main ways:</p>
<ul>
<li>Its GPU nodes are defined using <code>.tmsl</code> shaders.</li>
<li>GPU output nodes call special linker functions to evaluate the creation graph.</li>
<li>Shader instances in a creation graph are constructed using the shader system.</li>
</ul>
<p>The last point is a technical detail that doesn’t matter for anyone extending or using the creation graph so it won’t be covered in this guide. Additional information about the <code>creation_graph_node</code> shader block can be found in the <a href="https://ourmachinery.com/apidoc/doc/shader_system_reference.md.html">Shader System Reference</a>.</p>
<p>Any GPU node that can be used in the creation graph has an associated <code>.tmsl</code> shader file. Most of these can be found here: <code>the_machinery/shaders/nodes/*.tmsl</code>. We also supply a <a href="https://marketplace.visualstudio.com/items?itemName=OurMachinery.tmShaderLang">Visual Studio extension</a> for this file format which adds syntax highlighting, this extension will be used in this guide. </p>
<p><img src="https://www.dropbox.com/s/4o13cq3rzvqm813/tm_guide_creation_graph_sin_node.png?dl=1" alt="" /></p>
<p>This is the shader code for the <code>Sin</code> node. It defines one input (<code>a</code>) and one output (<code>res</code>, which is the same type as <code>a</code>). This shader file will be constructed using the shader system into a single <code>.hlsl</code> function. For more information on how to create basic GPU nodes see <a href="https://ourmachinery.github.io/themachinery-books/tutorials/creation_graph/custom_gpu_nodes.html">Creating custom GPU Nodes</a>.</p>
<p><img src="https://www.dropbox.com/s/cs31mi8njs9gpno/tm_guide_creation_graph_linkage.png?dl=1" alt="" /></p>
<p>This is an example of the shader code needed in the creation graph output nodes. When a creation graph node outputs a <code>Shader Instance</code> and has any inputs; it should define these three functions in it’s shader code block so the graph can be evaluated. The <code>tm_graph_read</code> function passes all the stage input variables to the graph (like position, color, uv, etc.). The <code>tm_graph_evaluate</code> function does most of the work. It uses the <code>tm_graph_io_t</code> struct to evaluate the graph by calling the functions generated by the normal nodes. Finally the <code>tm_graph_write</code> function passes all the graph variable to the stage output. It is important to note that whilst the <code>tm_graph_evaluate</code> function is necessary for graph evaluation; the <code>tm_graph_read</code> and <code>tm_graph_write</code> are not, they are helper function. For more information on how to create GPU output nodes see <a href="https://ourmachinery.github.io/themachinery-books/tutorials/creation_graph/custom_gpu_nodes.html">Creating custom GPU Nodes</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extending-the-machinery"><a class="header" href="#extending-the-machinery">Extending The Machinery</a></h1>
<p>In The Machinery, <strong>everything is a <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/extending_the_machinery/the_plugin_system.html">plugin</a></strong>. You can <strong>extend</strong>, <strong>modify</strong> or <strong>replace</strong> existing engine functionality with your plugins. </p>
<p>The Engine explicitly aims to be simple, minimalistic, and easy to understand. All our code is written in plain C, a significantly more straightforward language than modern C++. The entire codebase compiles in less than 30 seconds, and we support hot-reloading of DLLs, allowing for fast iteration cycles. You can modify your plugin code while the editor or the game runs since the plugin system supports <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/extending_the_machinery/hot-reloading.html">hot-reloading</a>. In short, we want to be &quot;hackable.&quot; Our APIs are exposed as C interfaces, which means you can easily use them from C, C++, D, or any other language with an FFI for calling into C code.</p>
<p><strong>Guides to follow:</strong></p>
<ul>
<li>Basic understanding on how to <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/extending_the_machinery/write-a-plugin.html">write a plugin</a>.</li>
<li>Basic understanding about <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/gameplay_coding/index.html">gameplay coding</a>.</li>
<li>More complex tutorials about custom plugins check out the <a href="https://ourmachinery.github.io/themachinery-books/tutorials/">Tutorials Book</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-plugin-system"><a class="header" href="#the-plugin-system">The plugin system</a></h1>
<p><em>The Machinery</em> is built around a plugin model. All features, even the built-in ones, are provided through plugins. You can extend <em>The Machinery</em> by writing your own plugins.</p>
<p>When <em>The Machinery</em> launches, it loads all the plugins named <code>tm_*.dll</code> in its <code>plugins/</code> folder. If you write your own plugins, name them so that they start with <code>tm_</code> and put them in this folder, they will be loaded together with the built-in plugins.</p>
<p><strong>Table of Content</strong></p>
<ul>
<li><a href="extending_the_machinery/the_plugin_system.html#about-apis">About API's</a></li>
<li><a href="extending_the_machinery/the_plugin_system.html#about-interfaces">About Interfaces</a></li>
<li><a href="extending_the_machinery/the_plugin_system.html#per-project-plugins">Per project plugins</a></li>
</ul>
<h2 id="about-apis"><a class="header" href="#about-apis">About API's</a></h2>
<p><em>The Machinery</em> is organized into individual APIs that can be called to perform specific tasks. A
plugin is a DLL that exposes one or several of these APIs. In order to implement its functionality,
the plugin may in turn rely on APIs exposed by other plugins.</p>
<p>A central object called the <em>API registry</em> is used to keep track of all the APIs. When you want to
use an API from another plugin, you ask the API registry for it. Similarly, you expose your APIs to
the world by registering them with the API registry.</p>
<p>This may seem a bit abstract at this point, so let’s look at a concrete example, <a href="https://ourmachinery.com/apidoc/foundation/unicode.h.html#unicode.h">unicode.h</a> which
exposes an API for encoding and decoding Unicode strings:</p>
<pre><code class="language-c">// This header has been abridged and commented from the original to make things
// clearer.

// Include standard header.
#include &quot;api_types.h&quot;

// Forward declarations.
struct tm_temp_allocator_i;

// Name of this API in the registry.
#define TM_UNICODE_API_NAME &quot;tm_unicode_api&quot;

// Unicode helper functions.
struct tm_unicode_api
{
    // Encodes the `codepoint` as UTF-8 into `utf8` and returns a pointer to the
    // position where to insert the next codepoint. `utf8` should have room for at
    // least four bytes (the maximum size of a UTF-8 encoded codepoint).
    char *(*utf8_encode)(char *utf8, uint32_t codepoint);

    // Decodes and returns the first codepoint in the UTF-8 string `utf8`. The string
    // pointer is advanced to point to the next codepoint in the string. Will generate
    // an error message if the string is not a UTF-8 string.
    uint32_t (*utf8_decode)(const char **utf8);

    // ...
};
</code></pre>
<p>Let’s go through this.</p>
<p>First, the code includes <code>&lt;api_types.h&gt;</code>. This is a shared header with common type declarations, it
includes things like <code>&lt;stdbool.h&gt;</code> and <code>&lt;stdint.h&gt;</code> and also defines a few <em>The Machinery</em> specific
types, such as <code>tm_vec3_t</code>.</p>
<p>In <em>The Machinery</em> we have a rule that header files can't include other header files (except
for <code>&lt;api_types.h&gt;</code>). This helps keep compile times down, but it also simplifies the structure of the
code. When you read a header file you don’t have to follow a long chain of other header files to understand
what is happening.</p>
<p>Next follows a block of forward struct declarations (in this case only one).</p>
<p>Next, we have the name of this API defined as a constant <a href="https://ourmachinery.com/apidoc/foundation/unicode.h.html#tm_unicode_api_name">TM_UNICODE_API_NAME</a>, followed by the
<code>struct tm_unicode_api</code> that defines the functions in the API.</p>
<p>To use this API, you would first use the API registry to query for the API pointer, then using that
pointer, call the functions of the API:</p>
<pre><code class="language-c">struct tm_unicode_api *tm_unicode_api =
    (struct tm_unicode_api *)tm_global_api_registry-&gt;get(TM_UNICODE_API_NAME);

tm_unicode_api-&gt;utf8_encode(utf8, codepoint);
</code></pre>
<p>The different APIs that you can query for and use are documented in their respective header files,
and in the <code>apidoc.md.html</code> documentation file (which is just extracted from the headers). Consult
these files for information on how to use the various APIs that are available in <em>The Machinery.</em></p>
<p>In addition to APIs defined in header files, <em>The Machinery</em> also contains some header files with
inline functions that you can include directly into your implementation files. For example
<code>&lt;math.inl&gt;</code> provides common mathematical operations on vectors and matrices, while <code>&lt;carray.inl&gt;</code>
provides a “stretchy-buffer” implementation (i.e. a C version of C++’s <code>std::vector</code>).</p>
<h2 id="about-interfaces"><a class="header" href="#about-interfaces">About Interfaces</a></h2>
<p>We also add an <em>implementation</em> of the unit test <em>interface</em> to the registry. The API registry has
support for both APIs and interfaces. The difference is that APIs only have a single implementation,
whereas interfaces can have many implementations. For example, all code that can be unit-tested
implements the unit test interface. Unit test programs can query the API registry to find all these
implementations and run all the unit tests.</p>
<p>To extend the editor you add implementations to the interfaces used by the editor. For example, you
can add implementations of the <a href="https://ourmachinery.com/apidoc/foundation/the_truth.h.html#tm_the_truth_create_types_interface_name">TM_THE_TRUTH_CREATE_TYPES_INTERFACE_NAME</a>  in order to create new
data types in The Truth, and add implementations of the <a href="https://ourmachinery.com/apidoc/plugins/entity/entity.h.html#tm_entity_create_component_interface_name">TM_ENTITY_CREATE_COMPONENT_INTERFACE_NAME</a>
in order to define new entity components. See the sample plugin examples.</p>
<p>It does not matter in which order the plugins are loaded. If you query for a plugin that hasn’t yet
been registered, you get a pointer to a nulled struct back. When the plugin is loaded, that struct
is filled in with the actual function pointers. As long as you don’t <em>call</em> the functions before the
plugin that implements them has been loaded, you are good. (You can test this by checking for NULL
pointers in the struct.)</p>
<h2 id="per-project-plugins"><a class="header" href="#per-project-plugins">Per project plugins</a></h2>
<p>The Engine supports per project plugins through <em>Plugin Assets</em>. A Plugin Asset is an asset in the
Asset Browser that holds a plugin.</p>
<p>To create a plugin asset in a particular project, just drop the <code>.dll</code> into the Asset Browser
(or use <strong>Import...</strong>). Every time you open the project, the plugin will be loaded.</p>
<blockquote>
<p><strong>Note</strong>: For security reasons, if you open a project containing plugins, you will be asked
whether you want to allow the plugins to run or not. Plugins aren't sandboxed, they have full
access to your machine. So you should only allow project plugins to run if you trust the author
of the plugin.</p>
</blockquote>
<p>When selecting a plugin asset in the asset browser the properties tab will show the following:</p>
<p><img src="https://ourmachinery.com/images/tutorials/plugin__properties.png" alt="" /></p>
<p>If you check the ☒ <strong>Import when changed</strong> checkbox, The Machinery will re-import and reload the
plugin every time it detects a change. You can use this to hot-reload your project plugins.</p>
<blockquote>
<p><strong>Note:</strong> since The Machinery APIs change with each release version, a plugin DLL built for one
specific version is unlikely to work with another version. Thus, to open a project with plugin
DLLs, you should make sure that your version matches the version the DLL was built for. In the
future, when The Machinery is out of beta, we will provide more stable APIs that will work across
multiple releases.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hot-reloading"><a class="header" href="#hot-reloading">Hot-Reloading</a></h1>
<p>We support hot-reloading of plugins while <em>The Machinery</em> is running. This allows you to work on a
plugin and see the changes in real-time without having to shut down and restart the application
between each change to your code.</p>
<p>Hot-reloading is enabled by default, but can be disabled with the <code>--no-hot-reload</code> parameter.</p>
<p>When a reload happens, the function pointers in the plugin's API struct are replaced with function
pointers to the new code. Since clients hold pointers to this struct, they will use the new function
pointers automatically -- they don't have to re-query the system for the API.</p>
<p>Note that hot-reloading is not magical and can break in a lot of situations. For example, if you
remove functions in the API or change their parameters, any clients of your API will still try to
call them using the old parameter lists, and things will most likely crash. Similarly, if a client
has stashed away a function pointer to one of your API functions somewhere, such as in a list of
callbacks, there is no way for us to patch that copy and it will continue to call the old code.
Also, if you make changes to the layout of live data objects (such as adding or removing struct
fields) things will break because we make no attempts to transfer the data to the new struct
format.</p>
<p>But adding or removing static functions, or changing the code inside functions should work without
problems. We find hot-reloading to be a big time saver even if it doesn't work in all circumstances.</p>
<p>If you want to use global variables in your DLL you should do so using the
<code>tm_api_registry_api-&gt;static_variable()</code> function in your <code>tm_load_plugin()</code> code. If you just
declare a global variable in your .c file, that variable will be allocated in the DLLs memory space
and when the DLL is reloaded you will lose all changes to the variable. When you use
<code>static_variable()</code>, the variable is allocated on the heap, and its content is preserved when the
DLL is reloaded.</p>
<p>If you are using hot-reloading together with a debugger on Windows, be aware that the debugger will
lock <code>.pdb</code> files which will prevent you from rebuilding your code. The suggested workflow is
something like this:</p>
<ul>
<li>Detach the debugger if it's currently attached.</li>
<li>Rebuild your DLL and fix any compiler bugs.</li>
<li>When the DLL is built successfully, The Machinery will automatically reload it.</li>
<li>If you need to continue debugging, re-attach the debugger.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="write-a-plugin"><a class="header" href="#write-a-plugin">Write a plugin</a></h2>
<p>This walkthrough show you how to extend the engine with a custom plugin.</p>
<p>You will learn about:</p>
<ul>
<li>What is needed to write a plugin</li>
<li>How to write a plugin</li>
</ul>
<p>This walk through expects you to have the basic understanding about the plugin system. Otherwise you can read more <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/extending_the_machinery/the_plugin_system.html">here</a>.</p>
<p><strong>Table of Content</strong></p>
<ul>
<li><a href="extending_the_machinery/write-a-plugin.html#where-does-the-engine-search-for-plugins">Where does the engine search for plugins</a></li>
<li><a href="extending_the_machinery/write-a-plugin.html#inspect-a-existing-example-to-get-inspiration">Inspect a existing example to get inspiration</a>
<ul>
<li><a href="extending_the_machinery/write-a-plugin.html#what-are-the-build-requirements">What are the build Requirements</a></li>
<li><a href="extending_the_machinery/write-a-plugin.html#build-the-sample-plugin">Build the sample plugin</a></li>
</ul>
</li>
<li><a href="extending_the_machinery/write-a-plugin.html#programming-in-c">Programming in C</a>
<ul>
<li><a href="extending_the_machinery/write-a-plugin.html#write-your-own-plugin">Write your own plugin</a></li>
<li><a href="extending_the_machinery/write-a-plugin.html#structure-of-a-plugin">Structure of a plugin</a>
<ul>
<li><a href="extending_the_machinery/write-a-plugin.html#where-does-my-gameplay-code-live">Where does my gameplay code live?</a></li>
<li><a href="extending_the_machinery/write-a-plugin.html#how-do-i-update-my-tool--tab-content">How do I update my tool / tab content?</a></li>
<li><a href="extending_the_machinery/write-a-plugin.html#plugin-callbacks-init-sutdown-tick">Plugin callbacks (Init, Sutdown, Tick)</a></li>
<li><a href="extending_the_machinery/write-a-plugin.html#how-do-i-deal-with-static-variables">How do I deal with static variables?</a></li>
</ul>
</li>
<li><a href="extending_the_machinery/write-a-plugin.html#write-your-own-api">Write your own API</a></li>
</ul>
</li>
</ul>
<h2 id="where-does-the-engine-search-for-plugins"><a class="header" href="#where-does-the-engine-search-for-plugins">Where does the engine search for plugins</a></h2>
<p>The Machinery is built around a plugin model. All features, even the built-in ones, are provided
through plugins. You can extend The Machinery by writing your own plugins. When The Machinery
launches, it loads all the plugins named <code>tm_*.dll</code> in its <code>plugins/</code> folder. If you write your own
plugins, name them so that they start with <code>tm_</code> and put them in this folder, they will be loaded
together with the built-in plugins.</p>
<blockquote>
<p><strong>Note:</strong> When you create a new plugin via the Engine, the <code>premake</code> file will <strong>not</strong> copy the plugin into your global plugin folder. The reason behind this is that we do not know if you want to create a plugin asset. <em>This workflow is currently under review.</em></p>
<p><strong>Important:</strong> The plugins created via the Engine expect a binary build version if you are using the source access version you might have to modify the <code>premake</code> file to make it point to the correc version. This workflow is currently under review.</p>
</blockquote>
<h2 id="inspect-a-existing-example-to-get-inspiration"><a class="header" href="#inspect-a-existing-example-to-get-inspiration">Inspect a existing example to get inspiration</a></h2>
<p>The easiest way to build a plugin is to start with an existing example. There are three places where
you can find plugin samples:</p>
<ol>
<li>
<p>The <code>samples</code> folder in the SDK has a number of plugin samples.</p>
</li>
<li>
<p>The <em>All Sample Projects</em> package in the <em>Download</em> tab has a <code>plugins</code> folder with some small
samples.</p>
</li>
<li>
<p>You can create a new plugin with the menu command <strong>File &gt; New Plugin</strong>. This will create a
new <code>.c</code> file for the plugin together with some helper files for compiling it. (<a href="extending_the_machinery/write-a-plugin.html#write-your-own-plugin">Follow this guide</a>)</p>
</li>
</ol>
<p>The distribution already comes with pre-built .dlls for the sample plugins, such as
<code>bin/plugins/tm_pong_tab.dll</code>. You can see this plugin in action by selecting <strong>Tab &gt; Pong</strong> in the
editor to open up its tab:</p>
<p><img src="https://www.dropbox.com/s/hats2jgr3wroahz/pong-tab.png?dl=1" alt="Pong tab." /></p>
<h3 id="what-are-the-build-requirements"><a class="header" href="#what-are-the-build-requirements">What are the build Requirements</a></h3>
<p>To build plugins you need three things:</p>
<ol>
<li>You need to have Visual Studio 2019 installed including the MS C++ Build Tools on your computer.
Note that the Community Edition works fine. (Or clang and the build essentials on Linux)</li>
<li>You need to set the <code>TM_SDK_DIR</code> environment variable to the path of the SDK package that you
installed on your computer. When you compile a plugin, it looks for The Machinery headers in the
<code>%TM_SDK_DIR%/headers</code> folder. </li>
<li>You need the <code>tmbuild.exe</code> from the SDK package. <code>tmbuild.exe</code> does all the steps needed to
compile the plugin. Put it in your <code>PATH</code> or copy it to your plugin folder so that you can run it
easily from the command line.</li>
</ol>
<h3 id="build-the-sample-plugin"><a class="header" href="#build-the-sample-plugin">Build the sample plugin</a></h3>
<p>To compile a plugin, simply open a command prompt in the plugin folder and run the <code>tmbuild.exe</code>
executable:</p>
<pre><code class="language-cmdinput">sample-projects/plugins/custom_tab&gt; %TM_SDK_DIR%/bin/tmbuild.exe
​~~~ cmd output
Installing 7za.exe...
Installing premake-5.0.0-alpha14-windows...
Building configurations...
Running action 'vs2019'...
Generated custom_tab.sln...
Generated build/custom_tab/custom_tab.vcxproj...
Done (133ms).
Microsoft (R) Build Engine version 16.4.0+e901037fe for .NET Framework
Copyright (C) Microsoft Corporation. All rights reserved.

  custom_tab.c
  custom_tab.vcxproj -&gt; C:\work\themachinery\build\bin\plugins\tm_custom_tab.dll

-----------------------------
tmbuild completed in: 23.471 s
</code></pre>
<p><code>tmbuild.exe</code> will perform the following steps to build your executable:</p>
<ol>
<li>Create a <code>libs</code> folder and download <code>premake5</code> into it. (You can set the <code>TM_LIB_DIR</code> environment
variable to use a shared <code>libs</code> directory for all your projects.)</li>
<li>Run <code>premake5</code> to create a Visual Studio project from the <code>premake5.lua</code> script.</li>
<li>Build the Visual Studio project to build the plugin.</li>
</ol>
<blockquote>
<p><strong>Note:</strong> You can learn more about <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/helper_tools/tmbuild.html">tmbuild</a> in its own section.</p>
</blockquote>
<h2 id="programming-in-c"><a class="header" href="#programming-in-c">Programming in C</a></h2>
<p><em>The Machinery</em> uses C99 as its interface language. I.e., all the header files that you use to
communicate with <em>The Machinery</em> are C99 header files, and when you write a plugin you should expose
C99 headers for your APIs. The <em>implementation</em> of a plugin can be written in whichever language you
like, as long as it exposes and communicates through a C99 header. In particular, you can write the
implementation in C++ if you want to. (At Our Machinery, we write the implementations in C99.)</p>
<h3 id="write-your-own-plugin"><a class="header" href="#write-your-own-plugin">Write your own plugin</a></h3>
<p>To write a plugin you need to implement a <code>tm_load_plugin()</code> function that is called whenever the
plugin DLL is loaded/unloaded. In this function, you can interact with various engine interfaces. For
example, you can implement <a href="https://ourmachinery.com/apidoc/foundation/unit_test.h.html#tm_unit_test_interface_name">TM_UNIT_TEST_INTERFACE_NAME</a> to implement unit tests that get run
together with the engine unit tests, you can implement <a href="https://ourmachinery.com/apidoc/foundation/the_truth.h.html#tm_the_truth_create_types_interface_name">TM_THE_TRUTH_CREATE_TYPES_INTERFACE_NAME</a> to
extend our data model, The Truth, with your own data types or implement
<a href="https://ourmachinery.com/apidoc/plugins/entity/entity.h.html#tm_entity_create_component_interface_name">TM_ENTITY_CREATE_COMPONENT_INTERFACE_NAME</a> to extend our entity model with your own component
types.</p>
<p>The following guides might help you:</p>
<ul>
<li><a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book//gameplay_coding/ecs/write_a_custom_component.html">How to add a new component type</a></li>
<li><a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book//the_truth/custom_truth_type.html">How to create a new Truth Type</a></li>
<li><a href="https://ourmachinery.github.io/themachinery-books/tutorials/">How to write a tab</a></li>
<li><a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/qa_pipeline/how_to_write_unit_tests.html">How to write unit tests</a></li>
<li><a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/qa_pipeline/how_to_write_integration_tests.html">How to write integration tests</a></li>
</ul>
<p>The Engine provides a easy way to create plugins for you via the <strong>File -&gt; New Plugins</strong> menu. There you can choose default plugin templates. They come with default files:</p>
<p><img src="https://www.dropbox.com/s/jhrqv8t8bbhr20u/tm_tut_new_tab.png?dl=1" alt="custom tab folder view" /></p>
<p><em>The folder structure for a custom tab called <code>custom_tab</code>.</em></p>
<ul>
<li><code>premake5.lua</code> - Your build configuration, on Windows it will generate a <code>.sln</code> file for you.</li>
<li><code>libs.json</code> - Defines the binary dependencies of your projects. <code>tmbuild</code> will automatically download them for you.</li>
<li><code>*.c</code> - Your source file. It contains the sample template code to give you some guidance on what is needed.</li>
<li><code>build.bat</code> / <code>build.sh</code> - quick build files to make building simpler for you.</li>
</ul>
<blockquote>
<p><strong>Note:</strong> By default the plugin will not be copied into your Engine's <code>plugins</code> folder. You can modify the <code>premake</code> file or copy it manually in the folder. You can also make use of a Plugin Asset.</p>
</blockquote>
<h3 id="structure-of-a-plugin"><a class="header" href="#structure-of-a-plugin">Structure of a plugin</a></h3>
<p>Every plugin has <code>tm_load_plugin()</code> as its entry point, in there we register everything we need to register to the Engines Plugin System. It is important that you do not execute heavy code in this function or relay on other plugins, since they might not be loaded yet! This function is just there to perform load and register operations.</p>
<h4 id="where-does-my-gameplay-code-live"><a class="header" href="#where-does-my-gameplay-code-live">Where does my gameplay code live?</a></h4>
<p>Your gameplay lives within the <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book//gameplay_coding/ecs/index.html">Systems / Engines</a> of the ECS or in the <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/gameplay_coding/simulate_entry.html">Simulate Entry</a> and they have their own entry points.</p>
<h4 id="how-do-i-update-my-tool--tab-content"><a class="header" href="#how-do-i-update-my-tool--tab-content">How do I update my tool / tab content?</a></h4>
<ul>
<li>The <a href="https://ourmachinery.com/apidoc/plugins/ui/docking.h.html#structtm_tab_vt">tm_tab_vt</a> defines three functions for your tab to be updated:
<ul>
<li><code>tm_tab_vt.ui()</code> - Callback for drawing the content of the tab into the specified rect.</li>
<li><code>tm_tab_vt.ui_serial()</code> - <em>Optional.</em> If implemented, called from the main UI job once all parallel UI rendering (fork/join) has finished. This can be used for parts of the UI that needs to run serially, for example because they call out to non-thread-safe function.</li>
<li><code>tm_tab_vt.hidden_update()</code> - <em>Optional</em>. If the tab wants to do some processing when it is <em>not</em> the selected tab in its tabwell, it can implement this callback. This will be called for all created tabs whose content is currently <em>not</em> visible.</li>
</ul>
</li>
</ul>
<p>For more information follow the <a href="https://ourmachinery.github.io/themachinery-books/tutorials/">&quot;Write a tab&quot;</a> walkthrough.</p>
<h4 id="plugin-callbacks-init-sutdown-tick"><a class="header" href="#plugin-callbacks-init-sutdown-tick">Plugin callbacks (Init, Sutdown, Tick)</a></h4>
<p>The plugin system provides also for plugin callbacks. <strong>It is recommended to rely on these calls as little as possible.</strong> You should not rely on those for your gameplay code!</p>
<ul>
<li><a href="https://ourmachinery.com/apidoc/foundation/plugin_callbacks.h.html#tm_plugin_init_interface_name">TM_PLUGIN_INIT_INTERFACE_NAME</a> - Is typically called as early as possible after all plugins have been loaded.</li>
</ul>
<blockquote>
<p><strong>Note:</strong> It is not called when a plugin is reloaded.</p>
</blockquote>
<ul>
<li><a href="https://ourmachinery.com/apidoc/foundation/plugin_callbacks.h.html#tm_plugin_shutdown_interface_name">TM_PLUGIN_SHUTDOWN_INTERFACE_NAME</a> - Is typically be called as early as possible during the application shutdown sequence</li>
</ul>
<blockquote>
<p><strong>Note:</strong> Is not called when a plugin is reloaded.</p>
</blockquote>
<ul>
<li><a href="https://ourmachinery.com/apidoc/foundation/plugin_callbacks.h.html#tm_plugin_tick_interface_name">TM_PLUGIN_TICK_INTERFACE_NAME</a> - Is typically called as early as possible in the application main loop “tick”.</li>
</ul>
<p>They are stored in the <code>foundation/plugin_callbacks.h</code>.</p>
<h4 id="how-do-i-deal-with-static-variables"><a class="header" href="#how-do-i-deal-with-static-variables">How do I deal with static variables?</a></h4>
<p>The use of static variables in DLLs can be problematic, because when the DLL is reloaded, the new instance of the DLL will get a new freshly initialized static variable, losing whatever content the variable had before reload. The <a href="https://ourmachinery.com/apidoc/foundation/api_registry.h.html#structtm_api_registry_api">tm_api_registry_api</a> provides a way to solve this issue:  <code>tm_api_registry_api.static_variable()</code></p>
<p>By using this function instead of defining it globally, the variable data is saved in permanent memory.</p>
<pre><code class="language-c">uint64_t *count_ptr;

TM_DLL_EXPORT void tm_load_plugin(struct tm_api_registry_api *reg, bool load)
{
    count_ptr = (uint64_t *)reg-&gt;static_variable(TM_STATIC_HASH(&quot;my_count&quot;, 0xa287d4b3ec9c2109ULL),
        sizeof(uint64_t), __FILE__, __LINE__);
}

void f()
{
    ++*count_ptr;
}
</code></pre>
<h3 id="write-your-own-api"><a class="header" href="#write-your-own-api">Write your own API</a></h3>
<p>You can also create your own APIs that other plugins can query for. If you create your own APIs, you
want to define them in your header file, so that other plugins can <code>#include</code> it and know how to
call your APIs. Note that if you are not defining your own APIs, but just implementing some of the
engine's ones, your plugin typically doesn't need a header file:</p>
<p><strong>my_plugin.h:</strong></p>
<pre><code class="language-c">#include &quot;foundation/api_types.h&quot;

#define MY_API_NAME &quot;my_api&quot;

struct my_api
{
    void (*foo)(void);
};
</code></pre>
<p><strong>my_plugin.c:</strong></p>
<pre><code class="language-c">static struct tm_api_registry_api *tm_global_api_registry;
static struct tm_error_api *tm_error_api;
static struct tm_logger_api *tm_logger_api;

#include &quot;my_plugin.h&quot;

#include &quot;foundation/api_registry.h&quot;
#include &quot;foundation/error.h&quot;
#include &quot;foundation/log.h&quot;
#include &quot;foundation/unit_test.h&quot;

static void foo(void)
{
    // ...
}

static struct my_api *my_api = &amp;(struct my_api) {
    .foo = foo,
};

static void my_unit_test(tm_unit_test_runner_i *tr, struct tm_allocator_i *a)
{
    // ...
}

static struct tm_unit_test_i *my_unit_test = &amp;(struct tm_unit_test_i) {
    .name = &quot;my_api&quot;,
    .test = my_unit_test,
};

TM_DLL_EXPORT void tm_load_plugin(struct tm_api_registry_api *reg, bool load)
{
    tm_global_api_registry = reg;

    tm_error_api = reg-&gt;get(TM_ERROR_API_NAME);
    tm_logger_api = reg-&gt;get(TM_LOGGER_API_NAME);

    tm_set_or_remove_api(reg, load, MY_API_NAME, my_api);

    tm_add_or_remove_implementation(reg, load, TM_UNIT_TEST_INTERFACE_NAME, my_unit_test);
}
</code></pre>
<p>When The Machinery loads a plugin DLL, it looks for the <code>tm_load_plugin()</code> function and calls it.
If it can't find the function, it prints an error message.</p>
<p>We store the API registry pointer in a static variable so that we can use it everywhere in our DLL.
We also <code>get()</code> some of the API pointers that we will use frequently and store them in static
variables so that we don’t have to use the registry to query for them every time we want to use
them. Finally, we add our own API to the registry, so others can query for and use it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="write-a-tab"><a class="header" href="#write-a-tab">Write a Tab</a></h1>
<p>This walkthrough shows you how to add a custom Tab to the Engine.</p>
<p>During this walkthrough, we will cover the following topics:</p>
<ul>
<li>How to create a tab from scratch.</li>
<li>Where and how do we register the Tab to the Engine.</li>
</ul>
<p>You should have basic knowledge about how to write a custom plugin. If not, you might want to check this <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/extending_the_machinery/the_plugin_system.html">Guide</a> and the <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/extending_the_machinery/write-a-plugin.html#build-requirements">Write a plugin guide</a>. The goal of this walkthrough is to dissect the Tab plugin provided by the Engine.</p>
<h2 id="where-do-we-start"><a class="header" href="#where-do-we-start">Where do we start?</a></h2>
<p>In this example, we want to create a new plugin, which contains our Tab. We open the Engine go to <strong>file -&gt; New Plugin -&gt; Editor Tab.</strong> The file dialog will pop up and ask us where we want to save our file. Pick a location that suits you.</p>
<blockquote>
<p><strong>Tip:</strong> Maybe store your plugin in a folder next to your game project.</p>
</blockquote>
<p>After this, we see that the Engine created some files for us.</p>
<p><img src="https://www.dropbox.com/s/jhrqv8t8bbhr20u/tm_tut_new_tab.png?dl=1" alt="folder structure new plugin" /></p>
<p>Now we need to ensure that we can build our project. In the root folder (The folder with the premake file), we can run <code>tmbuild</code> and see if there is no issue. We will build our projects once and generate the <code>.sln</code> file (on windows). </p>
<p>If there is an issue, we should ensure we have set up the Environment variables correctly and installed all the needed dependencies. For more information, please read this <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/helper_tools/tmbuild.html">guide</a>.</p>
<p>Now we can open the <code>.c</code> file with our favorite IDE. The file will contain the following content:</p>
<pre><code class="language-c">static struct tm_api_registry_api* tm_global_api_registry;

static struct tm_draw2d_api* tm_draw2d_api;
static struct tm_ui_api* tm_ui_api;

#include &lt;foundation/allocator.h&gt;
#include &lt;foundation/api_registry.h&gt;

#include &lt;plugins/ui/docking.h&gt;
#include &lt;plugins/ui/draw2d.h&gt;
#include &lt;plugins/ui/ui.h&gt;
#include &lt;plugins/ui/ui_custom.h&gt;

#include &lt;the_machinery/the_machinery_tab.h&gt;

#include &lt;stdio.h&gt;

TM_DLL_EXPORT void load_custom_tab_tab(struct tm_api_registry_api* reg, bool load);

#define TM_CUSTOM_TAB_VT_NAME &quot;tm_custom_tab&quot;
#define TM_CUSTOM_TAB_VT_NAME_HASH TM_STATIC_HASH(&quot;tm_custom_tab&quot;, 0xbc4e3e47fbf1cdc1ULL)

struct tm_tab_o {
    tm_tab_i tm_tab_i;
    tm_allocator_i* allocator;
};

static void tab__ui(tm_tab_o* tab, tm_ui_o* ui, const tm_ui_style_t* uistyle_in, tm_rect_t rect)
{
    tm_ui_buffers_t uib = tm_ui_api-&gt;buffers(ui);
    tm_ui_style_t* uistyle = (tm_ui_style_t[]){ *uistyle_in };
    tm_draw2d_style_t* style = &amp;(tm_draw2d_style_t){ 0 };
    tm_ui_api-&gt;to_draw_style(ui, style, uistyle);

    style-&gt;color = (tm_color_srgb_t){ .a = 255, .r = 255 };
    tm_draw2d_api-&gt;fill_rect(uib.vbuffer, *uib.ibuffers, style, rect);
}

static const char* tab__create_menu_name(void)
{
    return &quot;Custom Tab&quot;;
}

static const char* tab__title(tm_tab_o* tab, struct tm_ui_o* ui)
{
    return &quot;Custom Tab&quot;;
}

static tm_tab_i* tab__create(tm_tab_create_context_t* context, tm_ui_o *ui)
{
    tm_allocator_i* allocator = context-&gt;allocator;
    uint64_t* id = context-&gt;id;

    static tm_the_machinery_tab_vt* vt = 0;
    if (!vt)
        vt = tm_global_api_registry-&gt;get(TM_CUSTOM_TAB_VT_NAME);

    tm_tab_o* tab = tm_alloc(allocator, sizeof(tm_tab_o));
    *tab = (tm_tab_o){
        .tm_tab_i = {
            .vt = (tm_tab_vt*)vt,
            .inst = (tm_tab_o*)tab,
            .root_id = *id,
        },
        .allocator = allocator,
    };

    *id += 1000000;
    return &amp;tab-&gt;tm_tab_i;
}

static void tab__destroy(tm_tab_o* tab)
{
    tm_free(tab-&gt;allocator, tab, sizeof(*tab));
}

static tm_the_machinery_tab_vt* custom_tab_vt = &amp;(tm_the_machinery_tab_vt){
    .name = TM_CUSTOM_TAB_VT_NAME,
    .name_hash = TM_CUSTOM_TAB_VT_NAME_HASH,
    .create_menu_name = tab__create_menu_name,
    .create = tab__create,
    .destroy = tab__destroy,
    .title = tab__title,
    .ui = tab__ui
};

TM_DLL_EXPORT void tm_load_plugin(struct tm_api_registry_api* reg, bool load)
{
    tm_global_api_registry = reg;

    tm_draw2d_api = reg-&gt;get(TM_DRAW2D_API_NAME);
    tm_ui_api = reg-&gt;get(TM_UI_API_NAME);

    tm_set_or_remove_api(reg, load, TM_CUSTOM_TAB_VT_NAME, custom_tab_vt);
    tm_add_or_remove_implementation(reg, load, TM_TAB_VT_INTERFACE_NAME, custom_tab_vt);
}

</code></pre>
<h2 id="code-structure"><a class="header" href="#code-structure">Code structure</a></h2>
<p>Let us dissect the code structure and discuss all the points of interest.</p>
<h3 id="api-and-include-region"><a class="header" href="#api-and-include-region">API and include region</a></h3>
<p>The file begins with all includes and API definitions: </p>
<pre><code class="language-c">static struct tm_api_registry_api* tm_global_api_registry;

static struct tm_draw2d_api* tm_draw2d_api;
static struct tm_ui_api* tm_ui_api;

#include &lt;foundation/allocator.h&gt;
#include &lt;foundation/api_registry.h&gt;

#include &lt;plugins/ui/docking.h&gt;
#include &lt;plugins/ui/draw2d.h&gt;
#include &lt;plugins/ui/ui.h&gt;
#include &lt;plugins/ui/ui_custom.h&gt;

#include &lt;the_machinery/the_machinery_tab.h&gt;

#include &lt;stdio.h&gt;

TM_DLL_EXPORT void load_custom_tab_tab(struct tm_api_registry_api* reg, bool load);

#define TM_CUSTOM_TAB_VT_NAME &quot;tm_custom_tab&quot;
#define TM_CUSTOM_TAB_VT_NAME_HASH TM_STATIC_HASH(&quot;tm_custom_tab&quot;, 0xbc4e3e47fbf1cdc1ULL)
</code></pre>
<p>The code will fill the API definitions with life in the <code>tm_load_plugin</code> function.</p>
<p>The most important aspects here are the two defines on the bottom:</p>
<pre><code class="language-c">#define TM_CUSTOM_TAB_VT_NAME &quot;tm_custom_tab&quot;
#define TM_CUSTOM_TAB_VT_NAME_HASH TM_STATIC_HASH(&quot;tm_custom_tab&quot;, 0xbc4e3e47fbf1cdc1ULL)
</code></pre>
<p>The first one defines the name of our Tab and the second one represents its hash value. The hash value can be used later on to access, search the Tab in the <a href="https://ourmachinery.com/apidoc/plugins/ui/docking.h.html#structtm_docking_api">tm_docking_api</a>.</p>
<blockquote>
<p><strong>Note:</strong> If you modify the values, please ensure you ran <code>hash.exe</code> again or <code>tmbuild --gen-hash</code> so the hash value is updated!</p>
</blockquote>
<h3 id="define-your-data"><a class="header" href="#define-your-data">Define your Data</a></h3>
<p>In the next section, we define the data the Tab can hold. It might be any data you need for the Tab to work and do its job. The tab instance owns the data. It is not shared between Tabs instances. Therefore its lifetime is bound to the current instance.</p>
<pre><code class="language-c">struct tm_tab_o {
    tm_tab_i tm_tab_i;
    tm_allocator_i* allocator;
};
</code></pre>
<p>A <a href="https://ourmachinery.com/apidoc/plugins/ui/docking.h.html#structtm_tab_i">tm_tab_i</a> represents a tab object. A tab object is represented as a <code>vtable</code> that defines its function interface and an opaque pointer to the Tab's internal data. This design is used so that the application layer can extend the <code>vtable</code> with its own interface.</p>
<h3 id="define-the-actual-tab"><a class="header" href="#define-the-actual-tab">Define the actual Tab</a></h3>
<p>Every Tab in The Machinery is based on the <a href="https://ourmachinery.com/apidoc/the_machinery/the_machinery_tab.h.html#structtm_the_machinery_tab_vt">tm_the_machinery_tab_vt</a> (which is based on <a href="https://ourmachinery.com/apidoc/plugins/ui/docking.h.html#structtm_tab_vt">tm_tab_vt</a>) and registered to the <a href="https://ourmachinery.com/apidoc/plugins/ui/docking.h.html#tm_tab_vt_interface_name">TM_TAB_VT_INTERFACE_NAME</a> in the <code>tm_load_plugin()</code> function.</p>
<p>The default <a href="https://ourmachinery.com/apidoc/the_machinery/the_machinery_tab.h.html#structtm_the_machinery_tab_vt">tm_the_machinery_tab_vt</a> offers multiple options and settings we can set for our Tab. </p>
<table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="https://ourmachinery.com/apidoc/plugins/ui/docking.h.html#structtm_tab_vt.name">tm_tab_vt.name</a></td><td>Name uniquely identifying this tab type.</td></tr>
<tr><td><a href="https://ourmachinery.com/apidoc/plugins/ui/docking.h.html#structtm_tab_vt.name_hash">tm_tab_vt.name_hash</a></td><td>A hash of the <code>name</code>.</td></tr>
<tr><td><a href="https://ourmachinery.com/apidoc/plugins/ui/docking.h.html#structtm_tab_vt.create_menu_name()">tm_tab_vt.create_menu_name</a>()</td><td>Optional. Returns the (localized) name that should be shown for this tab type in menus that allow you to create new tabs. If this function returns <code>NULL</code>, the tab type won't appear in these menus. This can be used for tabs that should only be accessible when certain feature flags are set.</td></tr>
<tr><td><a href="https://ourmachinery.com/apidoc/plugins/ui/docking.h.html#structtm_tab_vt.create_menu_category()">tm_tab_vt.create_menu_category</a>()</td><td>Optional. Returns the (localized) category that should be shown for this tab type in menus that allow you to create new tabs. If this function returns <code>NULL</code> or is not set, the tab type will appear at the root level of the menu, uncategorized.</td></tr>
<tr><td><a href="https://ourmachinery.com/apidoc/plugins/ui/docking.h.html#structtm_tab_vt.create()">tm_tab_vt.create</a>()</td><td>Creates a new tab of this type and returns a pointer to it. <a href="https://ourmachinery.com/apidoc/plugins/ui/docking.h.html#tm_tab_create_context_t">tm_tab_create_context_t</a> is an application defined type containing all the data a tab needs in order to be created. <code>ui</code> s the UI that the tab will be created in.</td></tr>
<tr><td><a href="https://ourmachinery.com/apidoc/plugins/ui/docking.h.html#structtm_tab_vt.destroy()">tm_tab_vt.destroy</a>()</td><td>Destroys the tab</td></tr>
<tr><td><strong>Object methods</strong></td><td></td></tr>
<tr><td><a href="https://ourmachinery.com/apidoc/plugins/ui/docking.h.html#structtm_tab_vt.ui()">tm_tab_vt.ui</a>()</td><td>Callback for drawing the content of the tab into the specified rect. The <code>uistyle</code> is the <a href="https://ourmachinery.com/apidoc/plugins/ui/ui.h.html#structtm_ui_api.default_style()">tm_ui_api.default_style</a>() with the clipping rect set to <code>rect</code>.</td></tr>
<tr><td><a href="https://ourmachinery.com/apidoc/plugins/ui/docking.h.html#structtm_tab_vt.ui_serial()">tm_tab_vt.ui_serial</a>()</td><td>Optional. If implemented, called from the main UI job once all parallel UI rendering (fork/join) has finished. This can be used for parts of the UI that needs to run serially, for example because they call out to non-thread-safe function.</td></tr>
<tr><td><a href="https://ourmachinery.com/apidoc/plugins/ui/docking.h.html#structtm_tab_vt.hidden_update()">tm_tab_vt.hidden_update</a>()</td><td>This function is o<em>ptional.</em> If the Tab wants to do some processing when it is <em>not</em> the selected Tab in its tabwell, it can implement this callback. This will be called for all created tabs whose content is currently <em>not</em> visible.</td></tr>
<tr><td><a href="https://ourmachinery.com/apidoc/plugins/ui/docking.h.html#structtm_tab_vt.title()">tm_tab_vt.title</a>()</td><td>Returns the localized title to be displayed for the tab. This typically consists of the name of the tab together with the document that is being edited, such as &quot;Scene: Kitchen*&quot;</td></tr>
<tr><td><a href="https://ourmachinery.com/apidoc/plugins/ui/docking.h.html#structtm_tab_vt.set_root()">tm_tab_vt.set_root</a>()</td><td>Optional. Sets the root object of the tab. If a new Truth is loaded, this is called with <code>set_root(inst, new_tt, 0)</code>.</td></tr>
<tr><td><code> tm_tab_vt.root</code>()</td><td>Returns the root object and The Truth that is being edited in the tab. This is used, among other things to determine the undo queue that should be used for Undo/Redo operations when the tab has focus</td></tr>
<tr><td><a href="https://ourmachinery.com/apidoc/plugins/ui/docking.h.html#structtm_tab_vt.restore_settings()">tm_tab_vt.restore_settings</a>()</td><td>Optional. Allow the tab to  restore it's own <em>state</em> to the settings. For example the Asset Browser will use this to save the view size of the assets.</td></tr>
<tr><td><code>  tm_tab_vt.save_settings</code>()</td><td>Optional. Allow the tab to save it's own <em>state</em> to the settings. For example the Asset Browser will use this to save the view size of the assets.</td></tr>
<tr><td><a href="https://ourmachinery.com/apidoc/plugins/ui/docking.h.html#structtm_tab_vt.can_close()">tm_tab_vt.can_close</a>()</td><td>Optional. Returns <em>true</em> if the tab can be closed right now and <em>false</em> otherwise. A tab might not be able to close if it's in the middle of an important operation. Tabs that do not implement this method can be closed at any time.</td></tr>
<tr><td><a href="https://ourmachinery.com/apidoc/plugins/ui/docking.h.html#structtm_tab_vt.focus_event()">tm_tab_vt.focus_event</a>()</td><td><a href="https://ourmachinery.com//apidoc/plugins/ui/docking.h.html#structtm_tab_vt.focus_event()">documentation</a></td></tr>
<tr><td><a href="https://ourmachinery.com/apidoc/plugins/ui/docking.h.html#structtm_tab_vt.feed_events()">tm_tab_vt.feed_events</a>()</td><td>Optional. For feeding events to the tab. Useful for feeding events to UIs that are internal  to a tab.</td></tr>
<tr><td><a href="https://ourmachinery.com/apidoc/plugins/ui/docking.h.html#structtm_tab_vt.process_dropped_os_files()">tm_tab_vt.process_dropped_os_files</a>()</td><td>Optional. If set, the tab will receive the path to the files that were dropped from the OS since the previous frame.</td></tr>
<tr><td><a href="https://ourmachinery.com/apidoc/plugins/ui/docking.h.html#structtm_tab_vt.toolbars()">tm_tab_vt.toolbars</a>()</td><td>Optional. Returns a carray of toolbars to be drawn in the tab, allocated using <code>ta</code>.  <a href="extending_the_machinery/write-a-tab.html#">How to add toolbars</a></td></tr>
<tr><td><a href="https://ourmachinery.com/apidoc/plugins/ui/docking.h.html#structtm_tab_vt.need_update()">tm_tab_vt.need_update</a>()</td><td>Optional. Allow the tab to decide whether it's UI needs an update. Tabs that have animated components like the pong tab will return always true, while other tab may decide to return true only under certain circumstances. If not provided, the assumed default value will be true, so the tab will be updated every frame. If it returns false the UI will be cached. Therefore any call to <code>.ui</code> wont be called.</td></tr>
<tr><td><a href="https://ourmachinery.com/apidoc/plugins/ui/docking.h.html#structtm_tab_vt.hot_reload()">tm_tab_vt.hot_reload</a>()</td><td>Optional. Will be called after any code hot reload has happened.</td></tr>
<tr><td><a href="https://ourmachinery.com/apidoc/plugins/ui/docking.h.html#structtm_tab_vt.entity_context()">tm_tab_vt.entity_context</a>()</td><td>Optional. Should be implemented if tab owns an entity context.</td></tr>
<tr><td><a href="https://ourmachinery.com/apidoc/plugins/ui/docking.h.html#structtm_tab_vt.viewer_render_args()">tm_tab_vt.viewer_render_args</a>()</td><td>Optional. Should be implemented if tab owns an entity context that supports to be rendered outside of it's UI callbacks.</td></tr>
<tr><td><strong>Flags</strong></td><td></td></tr>
<tr><td><a href="https://ourmachinery.com/apidoc/plugins/ui/docking.h.html#structtm_tab_vt.cant_be_pinned">tm_tab_vt.cant_be_pinned</a></td><td>If set to <em>true</em>, the tab can't be pinned even though it has a <em>root</em> function.</td></tr>
<tr><td><a href="https://ourmachinery.com/apidoc/plugins/ui/docking.h.html#structtm_tab_vt.run_as_job">tm_tab_vt.run_as_job</a></td><td>If set to <em>true</em>, the tab's UI will run as a background job, parallel to the rest of the UI  rendering. <strong>Warning:</strong> Setting this to <em>true</em> indicates to the docking system that the <code>ui()</code> function is thread-safe. If the function is not actually thread-safe you will see threading errors.</td></tr>
<tr><td><a href="https://ourmachinery.com/apidoc/plugins/ui/docking.h.html#structtm_tab_vt.dont_restore_at_startup">tm_tab_vt.dont_restore_at_startup</a></td><td>If set to <em>true</em>, the tab will be considered <em>volatile</em>, and it won't be restored when the last opened project is automatically opened at startup, even if the user had the tab opened when the project was closed.</td></tr>
<tr><td><a href="https://ourmachinery.com/apidoc/plugins/ui/docking.h.html#structtm_tab_vt.dont_restore_root_asset_at_startup">tm_tab_vt.dont_restore_root_asset_at_startup</a></td><td>If set to <em>true</em>, the tab will be restored at startup, but the root of the tab won't be set to the one that was set during application shutdown. Basically the project will be restored, but it will be always <em>empty</em>.</td></tr>
</tbody></table>
<p>In this example, we make use of the following options:</p>
<pre><code class="language-c">static tm_the_machinery_tab_vt* custom_tab_vt = &amp;(tm_the_machinery_tab_vt){
    .name = TM_CUSTOM_TAB_VT_NAME,
    .name_hash = TM_CUSTOM_TAB_VT_NAME_HASH,
    .create_menu_name = tab__create_menu_name,
    .create = tab__create,
    .destroy = tab__destroy,
    .title = tab__title,
    .ui = tab__ui
};
</code></pre>
<p>In the cause of the rest of this walkthrough, we will discuss:<code>tab__create_menu_name</code>,  <code>tab__create</code>, <code>tab__destroy</code> , <code>tab__title</code> and <code>tab__ui</code>.</p>
<h3 id="define-the-metadata-functions"><a class="header" href="#define-the-metadata-functions">Define the metadata functions</a></h3>
<p>As we can see in our definition of the <code>custom_tab_vt</code> object we provide the <code>tm_tab_vt.create_menu_name()</code> and the <code>tm_tab_vt.title()</code>. The <code>create_menu_name</code> is an optional function to allow you to provide a name for the create tab menu. In contrast, the <code>title()</code> function is not optional and is needed. It provides the name of the Tab, which the editor shall show in the tab bar.</p>
<pre><code class="language-c">static const char* tab__create_menu_name(void)
{
    return &quot;Custom Tab&quot;;
}

static const char* tab__title(tm_tab_o* tab, struct tm_ui_o* ui)
{
    return &quot;Custom Tab&quot;;
}
</code></pre>
<h3 id="define-create-and-destroy-the-tab"><a class="header" href="#define-create-and-destroy-the-tab">Define create and destroy the Tab</a></h3>
<p>As mentioned before, the data of a tab is bound to its lifetime. Therefore you should create the data on <code>create</code> and let go of it on <code>destroy.</code></p>
<p>The create function provides you the <a href="https://ourmachinery.com/apidoc/plugins/ui/docking.h.html#tm_tab_create_context_t">tm_tab_create_context_t</a> access to many essential things, such as an allocator. This allocator is the one you should use directly or create a child allocator.</p>
<blockquote>
<p><strong>Note:</strong> for more information check <a href="https://ourmachinery.com/apidoc/plugins/ui/docking.h.html#tm_tab_create_context_t">tm_tab_create_context_t</a>'s documentation.</p>
</blockquote>
<pre><code class="language-c">static tm_tab_i* tab__create(tm_tab_create_context_t* context, tm_ui_o *ui)
{
    tm_allocator_i* allocator = context-&gt;allocator;
    static tm_the_machinery_tab_vt* vt = 0;
    if (!vt)
        vt = tm_global_api_registry-&gt;get(TM_CUSTOM_TAB_VT_NAME);

    tm_tab_o* tab = tm_alloc(allocator, sizeof(tm_tab_o));
    *tab = (tm_tab_o){
        .tm_tab_i = {
            .vt = (tm_tab_vt*)vt,
            .inst = (tm_tab_o*)tab,
            .root_id = *id,
        },
        .allocator = allocator,
    };
    return &amp;tab-&gt;tm_tab_i;
}
</code></pre>
<p>As you can notice, we ask the <code>tm_global_api_registry_api</code> if our Tab is already registered. If yes, we use the static local variable. If not, we get it from the registry.</p>
<pre><code class="language-c">    static tm_the_machinery_tab_vt* vt = 0;
    if (!vt)
        vt = tm_global_api_registry-&gt;get(TM_CUSTOM_TAB_VT_NAME);
</code></pre>
<p>After this, we use the provided allocator to allocate the Tab struct, and then we initialize it with the data we deem to be needed. </p>
<pre><code class="language-c">    tm_tab_o* tab = tm_alloc(allocator, sizeof(tm_tab_o));
    *tab = (tm_tab_o){
        .tm_tab_i = {
            .vt = (tm_tab_vt*)vt,
            .inst = (tm_tab_o*)tab,
            .root_id = *id,
        },
        .allocator = allocator,
    };
</code></pre>
<p>Since we have allocated something, we need to keep track of the used allocator! Hence we have it as a member in our Tab struct.</p>
<p>In the end, we pass a pointer to the Tab interface.</p>
<pre><code class="language-c"> return &amp;tab-&gt;tm_tab_i;
</code></pre>
<p>When it comes to free the Tab data, we can just call <code>tm_free()</code> on our Tab:</p>
<pre><code class="language-c">static void tab__destroy(tm_tab_o* tab)
{
    tm_free(tab-&gt;allocator, tab, sizeof(*tab));
}

</code></pre>
<h2 id="define-the-ui-update"><a class="header" href="#define-the-ui-update">Define the UI update</a></h2>
<p>In the default example, we create a Tab that only updates when the Tab is active and visible. Therefore we do not need the <code>tm_tab_vt.hidden_update()</code> function and can just implement the required one: <code>tm_tab_vt.ui()</code>.</p>
<p>The Tab itself shall not be jobifed since <code>run_as_job</code> is not provided (its default value is false). Therefore we know our function itself may contain none thread safe elements.</p>
<p>If we wanted to make our Tab jobifed, we could make use of the <code>tm_tab_vt.hidden_update()</code> function. This function is o<em>ptional.</em> If the Tab wants to do some processing when it is <em>not</em> the selected Tab in its tabwell, it can implement this callback. This will be called for all created tabs whose content is currently <em>not</em> visible.</p>
<p>Let us digest the current code line by line:</p>
<pre><code class="language-c">
static void tab__ui(tm_tab_o* tab, tm_ui_o* ui, const tm_ui_style_t* uistyle_in, tm_rect_t rect)
{
    tm_ui_buffers_t uib = tm_ui_api-&gt;buffers(ui);
    tm_ui_style_t* uistyle = (tm_ui_style_t[]){ *uistyle_in };
    tm_draw2d_style_t* style = &amp;(tm_draw2d_style_t){ 0 };
    tm_ui_api-&gt;to_draw_style(ui, style, uistyle);

    style-&gt;color = (tm_color_srgb_t){ .a = 255, .r = 255 };
    tm_draw2d_api-&gt;fill_rect(uib.vbuffer, *uib.ibuffers, style, rect);
}
</code></pre>
<p>The <a href="https://ourmachinery.com/apidoc/plugins/ui/docking.h.html#structtm_docking_api">tm_docking_api</a>, which will call our Tab's update, provides us with the essential information:</p>
<ul>
<li><code>tm_tab_o* tab</code> our tab data to access any data we need</li>
<li><code>tm_ui_o* ui</code> an instance of the UI, needed to call the <a href="https://ourmachinery.com/apidoc/plugins/ui/ui.h.html#structtm_ui_api">tm_ui_api</a></li>
<li><code>const tm_ui_style_t* uistyle_in</code> an instance of the current UI style, can be used to create a local version of it to modify the UI Style for this Tab.</li>
<li><code>tm_rect_t rect</code> the render surface of the Tab.</li>
</ul>
<p>In the first line of the function body, we create a new instance of the UI Buffers. You may use them to access the underlying buffers for calls to the<code>tm_draw2d_api</code>.Also, this object allows access to the commonly shared metrics and colors.</p>
<pre><code class="language-c">tm_ui_buffers_t uib = tm_ui_api-&gt;buffers(ui);
</code></pre>
<p>After this, we define our local copy of the UI Style. Then we create an empty <code>tm_draw2d_style_t</code> instance. We need to create a Style from the UI Style. You need <code> tm_draw2d_style_t* style</code> later for drawing anything with our draw 2d api.</p>
<pre><code class="language-c">    tm_ui_style_t* uistyle = (tm_ui_style_t[]){ *uistyle_in };
    tm_draw2d_style_t* style = &amp;(tm_draw2d_style_t){ 0 };
    tm_ui_api-&gt;to_draw_style(ui, style, uistyle);
</code></pre>
<p>Now we are set, and we can finally color our tab background to red. You can do this with the <code>tm_draw2d_api.fill_rect()</code> call. Beforehand we need to change our style's color to red and then call the <code>tm_draw2d_api.fill_rect()</code>. We need to pass in the vertex buffer and the index buffer pointer so the function can draw into them.</p>
<pre><code class="language-c">    style-&gt;color = (tm_color_srgb_t){ .a = 255, .r = 255 };
    tm_draw2d_api-&gt;fill_rect(uib.vbuffer, *uib.ibuffers, style, rect);
</code></pre>
<blockquote>
<p><strong>Note:</strong> For more information on the rational behind the UI System please check out this blog post <a href="https://ourmachinery.com/post/one-draw-call-ui/">https://ourmachinery.com/post/one-draw-call-ui/ </a></p>
</blockquote>
<h2 id="register-the-tab"><a class="header" href="#register-the-tab">Register the Tab</a></h2>
<p>The last thing before we can compile our project and test it in the Engine is registering the Tab to the Plugin System. As mentioned before, you need to register the Tab to the: <a href="https://ourmachinery.com/apidoc/plugins/ui/docking.h.html#tm_tab_vt_interface_name">TM_TAB_VT_INTERFACE_NAME</a> and also register an API: <code>TM_CUSTOM_TAB_VT_NAME</code> to which you pass the <code>custom_tab_vt</code>.</p>
<pre><code class="language-c">
TM_DLL_EXPORT void tm_load_plugin(struct tm_api_registry_api* reg, bool load)
{
    tm_global_api_registry = reg;

    tm_draw2d_api = reg-&gt;get(TM_DRAW2D_API_NAME);
    tm_ui_api = reg-&gt;get(TM_UI_API_NAME);

    tm_set_or_remove_api(reg, load, TM_CUSTOM_TAB_VT_NAME, custom_tab_vt);
    tm_add_or_remove_implementation(reg, load, TM_TAB_VT_INTERFACE_NAME, custom_tab_vt);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="plugin-assets"><a class="header" href="#plugin-assets">Plugin assets</a></h1>
<p>When you put a plugin in the <code>plugin</code> folder, it will be loaded every time you start The Machinery
and used by all projects. This is convenient, but sometimes you want plugins that are project
specific, e.g., the gameplay code for a particular game.</p>
<p><strong>Table of Content</strong></p>
<ul>
<li><a href="extending_the_machinery/plugin-assets.html#the-two-ways-of-achieving-plugin-only-assets">The two ways of achieving plugin only assets</a></li>
<li><a href="extending_the_machinery/plugin-assets.html#how-to-create-a-plugin-asset">How to create a plugin asset</a></li>
<li><a href="extending_the_machinery/plugin-assets.html#my-plugin-asset-is-not-updating-after-changes">My plugin asset is not updating after changes?</a></li>
<li><a href="extending_the_machinery/plugin-assets.html#i-have-a-third-party-dll-which-is-needed-for-my-game-project-only-what-do-i-do">I have a third party dll which is needed for my game project only, what do I do?</a></li>
</ul>
<h2 id="the-two-ways-of-achieving-plugin-only-assets"><a class="header" href="#the-two-ways-of-achieving-plugin-only-assets">The two ways of achieving plugin only assets</a></h2>
<p>There are two ways of doing this.</p>
<p>First, you could create a separate The Machinery executable folder for that specific project. Just
make a copy of the The Machinery folder and add any plugins you need. Whenever you want to work on
that project, make sure to start that executable instead of the standard one.</p>
<p>In addition to adding project specific plugins, this method also lets you do additional things,
such as using different versions of The Machinery for different projects and remove any of the
standard plugins that you <em>don't</em> need in your project.</p>
<p>The second method is to store plugins as <em>assets</em> in the project itself. To do this, create a <em>New
Plugin</em> in the <em>Asset Browser</em> and set the DLL path of the plugin to your DLL. We call this a 
<em>Plugin Asset</em>.</p>
<p>The <em>Plugin Assets</em> will be loaded whenever you open the project and unloaded whenever you close
the project. Since the plugin is distributed with the project, if you send the project to someone,
they will automatically get the plugin too -- they don't have to manually install into their
<code>plugin</code> folder. This can be a convenient way of distributing plugins.</p>
<blockquote>
<p><strong>WARNING: Security Warning</strong></p>
<p>Since plugin assets can contain arbitrary code and there is no sandboxing, when you run a
plugin asset, it will have full access to your machine. Therefore, you should only run plugin
assets from trusted sources. When you open a project that contains plugin assets, you will 
be asked if you want to allow the code to run on your machine or not. You should only click
<em>[Allow]</em> if you trust the author of the project.</p>
</blockquote>
<blockquote>
<p><strong>NOTE: Version Issues</strong></p>
<p>Since The Machinery is still in early adopters mode and doesn't have a stable API, plugins will only work
with the specific version they are developed for. If you send a plugin to someone else
(for example as a plugin asset in a project), you must make sure that they use the exact same
version of The Machinery. Otherwise, the plugin will most likely crash.</p>
</blockquote>
<h2 id="how-to-create-a-plugin-asset"><a class="header" href="#how-to-create-a-plugin-asset">How to create a plugin asset</a></h2>
<p>You can create a plugin asset in the Asset Browser. <strong>Righ Click -&gt; New -&gt; New Plugin</strong>. This will create a plugin asset in your asset browser. On its own this is quite useless. When you select it you can set the DLL Path for your plugin on windows or on linux. The moment you have selected the path to the dll. It will be imported and stored in the asset.</p>
<blockquote>
<p><strong>Note:</strong> The asset plugin will store the path absolute.</p>
</blockquote>
<h2 id="my-plugin-asset-is-not-updating-after-changes"><a class="header" href="#my-plugin-asset-is-not-updating-after-changes">My plugin asset is not updating after changes?</a></h2>
<p>You would have to repeat the above described worklfow everytime you change the code of your plugin. This is very annoying, but do not worry hot-reloading comes to resuce!</p>
<p>You can enable hot-reload for plugin assets by checking the <em>Import When Changed</em> checkbox in the plugin
properties. If checked, the editor will monitor the plugin's import path for changes and if it
detects a file change, it will reimport the plugin.</p>
<p><img src="https://www.dropbox.com/s/h2uzbwsf45o28ba/tm_guide_plugin_asset_settings.png?dl=1" alt="plugin asset settings" /></p>
<h2 id="i-have-a-third-party-dll-which-is-needed-for-my-game-project-only-what-do-i-do"><a class="header" href="#i-have-a-third-party-dll-which-is-needed-for-my-game-project-only-what-do-i-do">I have a third party dll which is needed for my game project only, what do I do?</a></h2>
<p>In this case you repeat the above workflow and check the <code>Is Helper</code> checkbox, the magic is done.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gameplay-coding-in-the-machinery"><a class="header" href="#gameplay-coding-in-the-machinery">Gameplay Coding in The Machinery</a></h1>
<p>In this section, you will learn the basics about Gameplay Coding in <em>The Machinery.</em> There are two primary ways of creating a vivid and active world:</p>
<ul>
<li>Using our C APIs <a href="https://ourmachinery.com/apidoc/apidoc.html">API Documentation</a>.</li>
<li>Using the <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/editing_workflows/visual-scripting.html">Visual Scripting Language</a>, which you can extend as well.</li>
</ul>
<h2 id="coding-within-our-entity-component-system"><a class="header" href="#coding-within-our-entity-component-system">Coding within our Entity Component System</a></h2>
<p>The Machinery uses an Entity Component System; therefore, most of your gameplay code will run via Engines or Systems. To learn more about these, please follow this <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book//gameplay_coding/ecs/index.html">link</a>.</p>
<h2 id="coding-independent-from-the-ecs"><a class="header" href="#coding-independent-from-the-ecs">Coding independent from the ECS</a></h2>
<p>The Engine also offers you a Simulation Entry that can be updated every frame and can offer you a place for ECS independent logic. For more information click <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/gameplay_coding/simulate_entry.html">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="simulate-entry-writing-gameplay-code-in-c"><a class="header" href="#simulate-entry-writing-gameplay-code-in-c">Simulate Entry (writing gameplay code in C)</a></h2>
<p>This walkthrough show you how to write a simulate entry and what a simulate entry is.</p>
<p>If you wish to program gameplay using C code, then you need some place where this code execution
enters. This is provided by the Simulate Entry interface. In order to use it, begin by implementing
the the interface <a href="https://ourmachinery.com/apidoc/plugins/simulate/simulate_entry.h.html#structtm_simulate_entry_i">tm_simulate_entry_i</a> (see <a href="https://ourmachinery.com/apidoc/plugins/simulate/simulate_entry.h.html#simulate_entry.h">simulate_entry.h</a>). Make an object of the
<a href="https://ourmachinery.com/apidoc/plugins/simulate/simulate_entry.h.html#structtm_simulate_entry_i">tm_simulate_entry_i</a> struct like this (see any of the gameplay samples for examples with more
context):</p>
<pre><code class="language-c">static tm_simulate_entry_i simulate_entry_i = {
    .id = TM_STATIC_HASH(&quot;tm_my_game_simulate_entry&quot;, 0xe240e2d67a0aa93ULL),
    .display_name = TM_LOCALIZE_LATER(&quot;My Game Simulate Entry&quot;),
    .start = start,
    .stop = stop,
    .tick = tick,
};
</code></pre>
<p>where <code>start()</code>, <code>stop()</code> and <code>tick()</code> are the functions that you want called when the game starts, ends
and each frame respectively. Make sure that <code>id</code> is unique. When your plugin loads, make sure to
register this implementation of <a href="https://ourmachinery.com/apidoc/plugins/simulate/simulate_entry.h.html#structtm_simulate_entry_i">tm_simulate_entry_i</a> on the <a href="https://ourmachinery.com/apidoc/plugins/simulate/simulate_entry.h.html#tm_simulate_entry_interface_name">TM_SIMULATE_ENTRY_INTERFACE_NAME</a>
interface name, like so:</p>
<pre><code class="language-c">tm_add_or_remove_implementation(reg, load, TM_SIMULATE_ENTRY_INTERFACE_NAME, &amp;simulate_entry_i);
</code></pre>
<p>After you've done this, create a <code>Simulate Entry</code> asset in a directory next to one of your scene
entities:</p>
<p><img src="https://www.dropbox.com/s/qchhejkfbbjfw7h/create-new-simulate-entrry.png?dl=1" alt="Creating a Simulate Entry asset" /></p>
<p>When you inspect the the properties of this new <code>Simulate Entry</code> asset, have a look in the
Simulate Entry dropdown menu. Given that you registered your implementation of <a href="https://ourmachinery.com/apidoc/plugins/simulate/simulate_entry.h.html#structtm_simulate_entry_i">tm_simulate_entry_i</a>
correctly, it should appear in this list.</p>
<blockquote>
<p><strong>Note:</strong> In our sample section you can find the &quot;gameplay-interaction-system&quot; sample. This one is a great sample to see this workflow in action.</p>
</blockquote>
<h2 id="how-will-the-engine-determine-which-one-to-pick"><a class="header" href="#how-will-the-engine-determine-which-one-to-pick">How will the Engine determine which one to pick?</a></h2>
<p>Now, whenever you start simulating a certain entity, such as your main game world, the Simulate Tab
will look in the directory next to the entity you're simulating and check if there is a Simulate
Entry asset there. If there is, it will use the referenced <a href="https://ourmachinery.com/apidoc/plugins/simulate/simulate_entry.h.html#structtm_simulate_entry_i">tm_simulate_entry_i</a> implementation in
order to enter into gameplay code. If the Simulate Tab fails to find a Simulate Entry asset in the
same directory, it will look in each parent directory. This makes it possible to put a &quot;catch-all&quot;
Simulate Entry in the root directory of your project. You can also put entities that need different
Simulate Entry code in separate directories, with a Simulate Entry asset next to each, which can
reference different implementations of the the <a href="https://ourmachinery.com/apidoc/plugins/simulate/simulate_entry.h.html#structtm_simulate_entry_i">tm_simulate_entry_i</a> interface.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extending-the-visual-scripting-language"><a class="header" href="#extending-the-visual-scripting-language">Extending the Visual Scripting Language</a></h1>
<p>This walkthrough shows you how to extend the visual scripting language for the entity graph and use the <code>generate-graph-nodes.exe</code>. You will learn about:</p>
<ul>
<li>How to develop the visual scripting language with your nodes.</li>
<li>When to run <code>generate-graph-nodes.exe</code></li>
</ul>
<h2 id="how-to-extend-the-visual-scripting-language"><a class="header" href="#how-to-extend-the-visual-scripting-language"><strong>How to extend the visual scripting language</strong></a></h2>
<p>You can extend the visual scripting language with your nodes. All you need to do is write the code that implements the node's action, together with some macros that specify how to create a visual scripting node from that code. Then you run the <code>generate-graph-nodes.exe</code> executable to generate an <code>*.inl</code> file with glue code.</p>
<ol>
<li><strong>Create the file</strong></li>
</ol>
<p>Our goal is to create a node that computes the square of a floating-point number. We can either add to an existing plugin a new file or create a new plugin. </p>
<blockquote>
<p><strong>Important</strong> is it to make sure that the filename contains the graph_nodes string. Otherwise, the node generator will ignore the file.</p>
<p>For example: <code>my_nodes.c</code> will be ignored by the tool, while <code>my_graph_nodes.c</code> wont be ignored.</p>
</blockquote>
<ol start="2">
<li><strong>Write the code</strong></li>
</ol>
<pre><code class="language-c">GGN_BEGIN(&quot;Sample/Math/Float&quot;);
GGN_NODE_QUERY();
static inline void sample_float_square(float a, float *res)
{
    *res = a * a;
}
GGN_GEN_REGISTER_FUNCTION();
GGN_END();
#include &quot;my_graph_nodes.inl&quot;
</code></pre>
<p>Let us digest the code example above. There are some things to note here:</p>
<ul>
<li>Node functions always return their results in pointer parameters(the reason is that they can have more than one result). Pointer parameters are seen as out parameters if they are mutable by the node-generator.</li>
<li>The function parameter names are also used for the naming of the input/output wires.</li>
<li>Two special macros surround all the code for the node(s): <code>GGN_BEGIN()</code> and <code>GGN_END()</code>.</li>
<li>The Engine will use the function name <code>sample_float_square</code> later: <code>Sample Float Square</code>, and you will find it in the defined category: <code>Sample/Math/Float</code></li>
<li>The <code>GGN_NODE_QUERY()</code> macro marks this node as a Query node. Query nodes are triggered automatically when their output is requested. Nodes that don't just purely modify data need to be triggered by an explicit event. Such as Tick or Init.</li>
<li>The <code>GGN_GEN_REGISTER_FUNCTION()</code> macro automatically creates a register function for registering the node with the visual scripting system. Otherwise, you need to write this function yourself.</li>
<li>The <code>#include &quot;my_graph_nodes.inl&quot;</code> will include the autogenerated graph node implementations. It needs to be somewhere in the file. (before the <code>tm_load_plugin</code> function)</li>
<li>The <code>generate-graph-nodes.exe</code> auto-generates the <code>my_graph_nodes.inl</code> for you. It would be best if you do not edit this file. Otherwise, the generator will overwrite your changes next time.</li>
</ul>
<p>For a full documentation of all <code>GGN_*</code> macros see [plugins/graph_interpreter/graph_node_macros.h](http://#).
The code we write is relatively slight. We need to ensure that we have some header files, including the <a href="https://ourmachinery.com/apidoc/plugins/graph_interpreter/graph_node_macros.h.html#graph_node_macros.h">graph_node_macros.h</a>, which we are using to tell the generator to generate code for us. </p>
<p>The following list makes sure that the nodes work on their own.</p>
<pre><code class="language-c">#include &lt;plugins/editor_views/graph.h&gt;
#include &lt;plugins/graph_interpreter/graph_node_helpers.inl&gt;
#include &lt;plugins/graph_interpreter/graph_node_macros.h&gt;
</code></pre>
<p>If we now think <em>'yeah, we can compile',</em> we are wrong; We need some other header files to ensure that the generated magic in the <code>my_graph_nodes.inl</code> file works. </p>
<p>We need to include the following files as well:</p>
<pre><code class="language-c">#include &lt;foundation/api_registry.h&gt; //Is needed for `GGN_GEN_REGISTER_FUNCTION()`
#include &lt;foundation/localizer.h&gt; // it automatically localizes your category name
#include &lt;foundation/macros.h&gt;
#include &lt;foundation/the_truth_types.h&gt; // is needed for the description of the wire input types
</code></pre>
<p>The next question is, <em><strong>Are we done now?</strong></em>  The answer is <strong>yes nearly</strong>.  What's left is registering our nodes in the plugin load function. It may look than like this:</p>
<pre><code class="language-c">TM_DLL_EXPORT void tm_load_plugin(struct tm_api_registry_api *reg, bool load)
{
    tm_global_api_registry = reg;
    tm_graph_interpreter_api = reg-&gt;get(TM_GRAPH_INTERPRETER_API_NAME);
    // This is auto generated from the graph node generator, you just need to call it.
    generated__register_graph_nodes(reg, load);
}
</code></pre>
<p>Here we just call the <code>generated__register_graph_nodes</code> function, defined in <code>my_graph_nodes.inl</code> and auto-generated. You can find the complete example here <code>samples/plugins/graph_nodes</code>.</p>
<ol start="3">
<li><strong>Run the node generator &amp;</strong>  <code>tmbuild</code></li>
</ol>
<p>The last step before we can compile is to make sure that we run the <code>generate-graph-nodes.exe</code> application. This helper utility processes all <code>GGN_* macros.</code> This program generates glue code that ties your function into the graph system -- creating connectors that correspond to your function parameters, etc. 
The glue code is stored in an <code>.inl</code> file with the same name as the <code>.c</code> file that contains the graph nodes. 
Do not forget that if you have used some new <a href="https://ourmachinery.com/apidoc/foundation/api_types.h.html#tm_static_hash()">TM_STATIC_HASH</a> values, run hash.exe to make sure that those get hashed. 
Then you are ready to run <code>tmbuild</code>. It will compile your plugin, and then when you start the Engine or have it run in hot-reload mode it will show you your new nodes in the editor.</p>
<blockquote>
<p><strong>Note:</strong> You can also run <code>tmbuild</code> with a argument: <code>tmbuild --gen-nodes</code> . This will make sure that <code>tmbuild</code> runs <code>generate-graph-nodes.exe</code> before it builds.</p>
</blockquote>
<p><img src="https://paper-attachments.dropbox.com/s_BE512D5FE8135D0385DC0047FF64445B552F54BFA20F2F17110D3CCE8DFC6050_1608038436418_image.png" alt="Created nodes in the entity graph view" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="entity-component-system"><a class="header" href="#entity-component-system">Entity Component System</a></h1>
<p>The purpose of the entity system is to provide a flexible model for <em>objects in a simulation</em>, that
allows us to compose complex objects from simpler components in a flexible and performant way.</p>
<p>An <em>entity</em> is a game object composed of <em>components</em>. Entities live in a <em>entity context</em> — an
isolated world of entities. </p>
<p>Components are there to hold the needed data while <em>Engines</em>/<em>Systems</em> are there to provide behaviour.</p>
<p>Each context (<em>entity context</em>) can have a number of <em>engines</em> or <em>systems</em> registered. <em>(ECS)</em> Engines updates
are running on subset of entities that posses some set of components. </p>
<blockquote>
<p><strong>Note</strong>: in some entity systems, these are referred to as <em>systems</em> instead, but we choose <em>engine</em>, because it is less ambiguous.</p>
</blockquote>
<p>While Systems are just a update with a provided access to the entity context. When we refer to a context in this chapter we mean the entity context.</p>
<p><strong>Table of Content</strong></p>
<ul>
<li><a href="gameplay_coding/ecs/index.html#entity-context">Entity Context</a></li>
<li><a href="gameplay_coding/ecs/index.html#entities-and-the-truth">Entities and The Truth</a></li>
<li><a href="gameplay_coding/ecs/index.html#entity-data-storage">Entity data storage</a></li>
<li><a href="gameplay_coding/ecs/index.html#entity-types--archetype">Entity types / Archetype</a></li>
<li><a href="gameplay_coding/ecs/index.html#components">Components</a></li>
<li><a href="gameplay_coding/ecs/index.html#component-manager">Component Manager</a></li>
<li><a href="gameplay_coding/ecs/index.html#engines">Engines</a></li>
<li><a href="gameplay_coding/ecs/index.html#systems">Systems</a></li>
<li><a href="gameplay_coding/ecs/index.html#assets">Assets</a></li>
<li><a href="gameplay_coding/ecs/index.html#child-entities">Child entities</a></li>
</ul>
<h2 id="entity-context"><a class="header" href="#entity-context">Entity Context</a></h2>
<p>The Entity Context is the simulation world. It contains all the Entites and Systems/Engines as well owns all the Component Data. There can be multiple Entity Contexts in the Editor. For example the Simulate tag, Preview Tab have both a Entity Context. When you Register A System/Engine you an decide in which context they shall run. The Default is in all contexts. </p>
<h2 id="entities-and-the-truth"><a class="header" href="#entities-and-the-truth">Entities and The Truth</a></h2>
<ul>
<li>Entities <strong>do not live in The Truth</strong>. The truth is for <em>assets</em>, not for <em>simulation.</em></li>
<li>Entity data is owned by the context and thrown away when the context is destroyed.</li>
<li>Entities can be spawned from <em>entity assets</em> in The Truth. Multiple entities can be spawned from
the same asset.</li>
<li>Changes to entity assets can be propagated into a context where those assets are spawned. This is
the main way in which we will provide a “preview” of assets in a simulation context.</li>
<li>An entity always belongs to a specific context and entity IDs are only unique within the contexts. Entity IDs act as weak references. If you have an ID you can ask the context whether that entity is still alive or not. <code>tm_entity_api.is_alive()</code></li>
</ul>
<h2 id="entity-data-storage"><a class="header" href="#entity-data-storage">Entity data storage</a></h2>
<ul>
<li>An entity is a 64-bit value divided into a 32-bit index and a 32-bit generation.</li>
<li>The index points to a slot where entity data is stored.</li>
<li>The generation is increased every time we recycle a slot. This allows us to detect stale entitiy
IDs (i.e., weak referencing through <code>is_alive()</code>.</li>
</ul>
<h2 id="entity-types--archetype"><a class="header" href="#entity-types--archetype">Entity types / Archetype</a></h2>
<ul>
<li>An entity type is shared by all entities with a certain component mask.</li>
<li>When components are added to or removed from an entity, it’s entity type changes, thus its data
must be copied over to the new type.</li>
<li>Pointers to component data are thus not permanent.</li>
</ul>
<h2 id="components"><a class="header" href="#components">Components</a></h2>
<ul>
<li>A component is defined by <a href="https://ourmachinery.com/apidoc/plugins/entity/entity.h.html#structtm_component_i">tm_component_i</a> — it consists of a fixed-size piece of POD data.</li>
<li>This data is stored in a huge buffer for each entity type, and indexed by the index.</li>
<li>In addition, a component can have a <em>manager</em>. The manager is notified when the component is added
or removed.</li>
<li>The manager can store additional data for the component that doesn’t fit in the POD data — such as
lists, strings, buffers, etc.</li>
</ul>
<blockquote>
<p><strong>Note</strong>:  Keep in mind they do not need a Truth Representation. If They do not have one the Engine cannot display them in the Entity Tree View. This is useful for runtime only components.</p>
</blockquote>
<h2 id="component-manager"><a class="header" href="#component-manager">Component Manager</a></h2>
<ul>
<li>Can store persitsent data from the beginning of the Entity Context till the end</li>
<li>Can provide a way to allocate data on adding/removing a component</li>
<li>The manager is notified when the component is added or removed.</li>
</ul>
<h2 id="engines"><a class="header" href="#engines">Engines</a></h2>
<blockquote>
<p>Note: in some entity systems, these are referred to as <em>systems</em> instead, but we choose <em>engine</em>, because it is less ambiguous.</p>
</blockquote>
<ul>
<li>
<p>An engine is an update that runs for all components matching a certain <em>component mask</em>.</p>
</li>
<li>
<p>Engines registered with the context runs automatically on update, in parallel.</p>
</li>
<li>
<p>Parallelization is done automatic, by looking at the components that each engine reads or writes.
Before running, an engine waits for the previous engines that wrote to the components that the
engine is interested in.</p>
</li>
</ul>
<h2 id="systems"><a class="header" href="#systems">Systems</a></h2>
<ul>
<li>General Update loop that has access to the Entity Context.</li>
<li>Can be used for none component specific interactions</li>
<li>Can be used for serial interactions that do not interact with the entity system. (Such as Input)</li>
</ul>
<h2 id="assets"><a class="header" href="#assets">Assets</a></h2>
<ul>
<li>
<p>An entity asset has a list of components and child entities.</p>
</li>
<li>
<p>Parsing of component data is done by a <code>load_asset()</code> function that is registered together with
the component.</p>
</li>
<li>
<p>Component assets may reference other entity assets within the same entity tree.</p>
</li>
</ul>
<p><strong>Important:</strong> A Component representation in The Truth may <strong>not</strong> reflect the runtime ECS representation. This can be used to separate a Truth representation into smaller bits for gameplay programming sake but keep the simplicty for the Front End user.</p>
<p><em>Example:</em></p>
<p>You have a <code>Movement Controller Component</code> that can be used via the UI to determine the Entities movement speed. The actual movement system interacts with a <code>Movement Component</code> which keeps track of the actual current speed and can be influenced by other systems while the Movement Controller is only there to keep the fixed <code>const</code> state and can only be influenced by a Skill Update system or something like this.</p>
<h2 id="child-entities"><a class="header" href="#child-entities">Child entities</a></h2>
<ul>
<li>
<p>Child entities are entities that are spawned and destroyed together with their parent.</p>
<blockquote>
<p><strong>Note</strong>: that we only store child pointers, not parent pointers. Deleting a child entity does not
automatically delete it from its parent — it will remain in the parent as a dead pointer.</p>
</blockquote>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="write-a-custom-component"><a class="header" href="#write-a-custom-component">Write a custom component</a></h1>
<p>This walkthrough shows you how to add a custom component to the Engine. During this walkthrough, we will cover the following topics:</p>
<ul>
<li>How to create a component from scratch.</li>
<li>Where and how do we register a component.</li>
</ul>
<p>You should have basic knowledge about how to write a custom plugin. If not, you might want to check this <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/extending_the_machinery/the_plugin_system.html">Guide</a> and the <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/extending_the_machinery/write-a-plugin.html#build-requirements">Write a plugin guide</a>. The goal of this walkthrough is to dissect the component plugin provided by the Engine.</p>
<p><strong>Table of Content</strong></p>
<ul>
<li><a href="gameplay_coding/ecs/write_a_custom_component.html#where-do-we-start">Where do we start?</a></li>
<li><a href="gameplay_coding/ecs/write_a_custom_component.html#code-structure">Code structure</a>
<ul>
<li><a href="gameplay_coding/ecs/write_a_custom_component.html#api-and-include-region">API and include region</a></li>
<li><a href="gameplay_coding/ecs/write_a_custom_component.html#define-your-data">Define your Data</a></li>
<li><a href="gameplay_coding/ecs/write_a_custom_component.html#add-your-component-to-the-truth">Add your component to the Truth</a></li>
<li><a href="gameplay_coding/ecs/write_a_custom_component.html#define-your-component">Define your component</a></li>
<li><a href="gameplay_coding/ecs/write_a_custom_component.html#define-your-engine-update">Define your engine update</a></li>
<li><a href="gameplay_coding/ecs/write_a_custom_component.html#register-your-engine-to-the-system">Register your Engine to the system</a></li>
<li><a href="gameplay_coding/ecs/write_a_custom_component.html#the-plugin-load-function">The plugin load function</a></li>
</ul>
</li>
</ul>
<h2 id="where-do-we-start-1"><a class="header" href="#where-do-we-start-1">Where do we start?</a></h2>
<p>In this example, we want to create a new plugin, which contains our component. We open the Engine go to <strong>file -&gt; New Plugin -&gt; Entity Component.</strong> The file dialog will pop up and ask us where we want to save our file. Pick a location that suits you.</p>
<blockquote>
<p><strong>Tip:</strong> Maybe store your plugin in a folder next to your game project.</p>
</blockquote>
<p>After this, we see that the Engine created some files for us. Now we need to ensure that we can build our project. In the root folder (The folder with the <code>premake</code> file), we run <code>tmbuild,</code> and if there is no issue, we see that it will build our projects once and generate the <code>.sln</code> file (on windows). If there is an issue, we should ensure we have set up the Environment variables correctly and installed all the needed dependencies. For more information, please read this <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/helper_tools/tmbuild.html">guide</a>.</p>
<p>Now we can open the <code>.c</code> file with our favourite IDE. The file will contain the following content:</p>
<pre><code class="language-c">static struct tm_entity_api* tm_entity_api;
static struct tm_transform_component_api* tm_transform_component_api;
static struct tm_temp_allocator_api* tm_temp_allocator_api;
static struct tm_the_truth_api* tm_the_truth_api;
static struct tm_localizer_api* tm_localizer_api;

#include &lt;plugins/entity/entity.h&gt;
#include &lt;plugins/entity/transform_component.h&gt;
#include &lt;plugins/the_machinery_shared/component_interfaces/editor_ui_interface.h&gt;

#include &lt;foundation/api_registry.h&gt;
#include &lt;foundation/carray.inl&gt;
#include &lt;foundation/localizer.h&gt;
#include &lt;foundation/math.inl&gt;
#include &lt;foundation/the_truth.h&gt;

#define TM_TT_TYPE__CUSTOM_COMPONENT &quot;tm_custom_component&quot;
#define TM_TT_TYPE_HASH__CUSTOM_COMPONENT TM_STATIC_HASH(&quot;tm_custom_component&quot;, 0x355309758b21930cULL)

enum {
    TM_TT_PROP__CUSTOM_COMPONENT__FREQUENCY, // float
    TM_TT_PROP__CUSTOM_COMPONENT__AMPLITUDE, // float
};

struct tm_custom_component_t {
    float y0;
    float frequency;
    float amplitude;
};

static const char* component__category(void)
{
    return TM_LOCALIZE(&quot;Samples&quot;);
}

static tm_ci_editor_ui_i* editor_aspect = &amp;(tm_ci_editor_ui_i){
    .category = component__category
};

static void truth__create_types(struct tm_the_truth_o* tt)
{
    tm_the_truth_property_definition_t custom_component_properties[] = {
        [TM_TT_PROP__CUSTOM_COMPONENT__FREQUENCY] = { &quot;frequency&quot;, TM_THE_TRUTH_PROPERTY_TYPE_FLOAT },
        [TM_TT_PROP__CUSTOM_COMPONENT__AMPLITUDE] = { &quot;amplitude&quot;, TM_THE_TRUTH_PROPERTY_TYPE_FLOAT },
    };

    const tm_tt_type_t custom_component_type = tm_the_truth_api-&gt;create_object_type(tt, TM_TT_TYPE__CUSTOM_COMPONENT, custom_component_properties, TM_ARRAY_COUNT(custom_component_properties));
    const tm_tt_id_t default_object = tm_the_truth_api-&gt;quick_create_object(tt, TM_TT_NO_UNDO_SCOPE, TM_TT_TYPE_HASH__CUSTOM_COMPONENT, TM_TT_PROP__CUSTOM_COMPONENT__FREQUENCY, 1.0f, TM_TT_PROP__CUSTOM_COMPONENT__AMPLITUDE, 1.0f, -1);
    tm_the_truth_api-&gt;set_default_object(tt, custom_component_type, default_object);

    tm_the_truth_api-&gt;set_aspect(tt, custom_component_type, TM_CI_EDITOR_UI, editor_aspect);
}

static bool component__load_asset(tm_component_manager_o* man, tm_entity_t e, void* c_vp, const tm_the_truth_o* tt, tm_tt_id_t asset)
{
    struct tm_custom_component_t* c = c_vp;
    const tm_the_truth_object_o* asset_r = tm_tt_read(tt, asset);
    c-&gt;y0 = 0;
    c-&gt;frequency = tm_the_truth_api-&gt;get_float(tt, asset_r, TM_TT_PROP__CUSTOM_COMPONENT__FREQUENCY);
    c-&gt;amplitude = tm_the_truth_api-&gt;get_float(tt, asset_r, TM_TT_PROP__CUSTOM_COMPONENT__AMPLITUDE);
    return true;
}

static void component__create(struct tm_entity_context_o* ctx)
{
    tm_component_i component = {
        .name = TM_TT_TYPE__CUSTOM_COMPONENT,
        .bytes = sizeof(struct tm_custom_component_t),
        .load_asset = component__load_asset,
    };

    tm_entity_api-&gt;register_component(ctx, &amp;component);
}

// Runs on (custom_component, transform_component)
static void engine_update__custom_component(tm_engine_o* inst, tm_engine_update_set_t* data)
{
    TM_INIT_TEMP_ALLOCATOR(ta);

    tm_entity_t* mod_transform = 0;

    struct tm_entity_context_o* ctx = (struct tm_entity_context_o*)inst;

    double t = 0;
    for (const tm_entity_blackboard_value_t* bb = data-&gt;blackboard_start; bb != data-&gt;blackboard_end; ++bb) {
        if (TM_STRHASH_EQUAL(bb-&gt;id, TM_ENTITY_BB__TIME))
            t = bb-&gt;double_value;
    }

    for (tm_engine_update_array_t* a = data-&gt;arrays; a &lt; data-&gt;arrays + data-&gt;num_arrays; ++a) {
        struct tm_custom_component_t* custom_component = a-&gt;components[0];
        tm_transform_component_t* transform = a-&gt;components[1];

        for (uint32_t i = 0; i &lt; a-&gt;n; ++i) {
            if (!custom_component[i].y0)
                custom_component[i].y0 = transform[i].world.pos.y;
            const float y = custom_component[i].y0 + custom_component[i].amplitude * sinf((float)t * custom_component[i].frequency);

            transform[i].world.pos.y = y;
            ++transform[i].version;
            tm_carray_temp_push(mod_transform, a-&gt;entities[i], ta);
        }
    }

    tm_entity_api-&gt;notify(ctx, data-&gt;engine-&gt;components[1], mod_transform, (uint32_t)tm_carray_size(mod_transform));

    TM_SHUTDOWN_TEMP_ALLOCATOR(ta);
}

static bool engine_filter__custom_component(tm_engine_o* inst, const tm_component_type_t* components, uint32_t num_components, const tm_component_mask_t* mask)
{
    return tm_entity_mask_has_component(mask, components[0]) &amp;&amp; tm_entity_mask_has_component(mask, components[1]);
}

static void component__register_engine(struct tm_entity_context_o* ctx)
{
    const tm_component_type_t custom_component = tm_entity_api-&gt;lookup_component_type(ctx, TM_TT_TYPE_HASH__CUSTOM_COMPONENT);
    const tm_component_type_t transform_component = tm_entity_api-&gt;lookup_component_type(ctx, TM_TT_TYPE_HASH__TRANSFORM_COMPONENT);

    const tm_engine_i custom_component_engine = {
        .ui_name = &quot;Custom Component&quot;,
        .hash  = TM_STATIC_HASH(&quot;CUSTOM_COMPONENT&quot;, 0xe093a8316a6c2d29ULL),
        .num_components = 2,
        .components = { custom_component, transform_component },
        .writes = { false, true },
        .update = engine_update__custom_component,
        .filter = engine_filter__custom_component,
        .inst = (tm_engine_o*)ctx,
    };
    tm_entity_api-&gt;register_engine(ctx, &amp;custom_component_engine);
}

TM_DLL_EXPORT void tm_load_plugin(struct tm_api_registry_api* reg, bool load)
{
    tm_entity_api = reg-&gt;get(TM_ENTITY_API_NAME);
    tm_transform_component_api = reg-&gt;get(TM_TRANSFORM_COMPONENT_API_NAME);
    tm_the_truth_api = reg-&gt;get(TM_THE_TRUTH_API_NAME);
    tm_temp_allocator_api = reg-&gt;get(TM_TEMP_ALLOCATOR_API_NAME);
    tm_localizer_api = reg-&gt;get(TM_LOCALIZER_API_NAME);

    tm_add_or_remove_implementation(reg, load, TM_THE_TRUTH_CREATE_TYPES_INTERFACE_NAME, truth__create_types);
    tm_add_or_remove_implementation(reg, load, TM_ENTITY_CREATE_COMPONENT_INTERFACE_NAME, component__create);
    tm_add_or_remove_implementation(reg, load, TM_ENTITY_SIMULATION_REGISTER_ENGINES_INTERFACE_NAME, component__register_engine);
}

</code></pre>
<h2 id="code-structure-1"><a class="header" href="#code-structure-1">Code structure</a></h2>
<p>Let us dissect the code structure and discuss all the points of interest.</p>
<h3 id="api-and-include-region-1"><a class="header" href="#api-and-include-region-1">API and include region</a></h3>
<p>The file begins with all includes and API definitions: </p>
<pre><code class="language-c">static struct tm_entity_api* tm_entity_api;
static struct tm_transform_component_api* tm_transform_component_api;
static struct tm_temp_allocator_api* tm_temp_allocator_api;
static struct tm_the_truth_api* tm_the_truth_api;
static struct tm_localizer_api* tm_localizer_api;

#include &lt;plugins/entity/entity.h&gt;
#include &lt;plugins/entity/transform_component.h&gt;
#include &lt;plugins/the_machinery_shared/component_interfaces/editor_ui_interface.h&gt;

#include &lt;foundation/api_registry.h&gt;
#include &lt;foundation/carray.inl&gt;
#include &lt;foundation/localizer.h&gt;
#include &lt;foundation/math.inl&gt;
#include &lt;foundation/the_truth.h&gt;
</code></pre>
<p>The code will fill the API definitions with life in the <code>tm_load_plugin</code> function.</p>
<h3 id="define-your-data-1"><a class="header" href="#define-your-data-1">Define your Data</a></h3>
<p>The next part contains the Truth Definition of the component and the plain old data struct (POD). <em>In production, we should separate those aspects into a header file!</em></p>
<blockquote>
<p>Note: All components should be plain old datatypes.</p>
</blockquote>
<pre><code class="language-c">#define TM_TT_TYPE__CUSTOM_COMPONENT &quot;tm_custom_component&quot;
#define TM_TT_TYPE_HASH__CUSTOM_COMPONENT TM_STATIC_HASH(&quot;tm_custom_component&quot;, 0x355309758b21930cULL)

enum {
    TM_TT_PROP__CUSTOM_COMPONENT__FREQUENCY, // float
    TM_TT_PROP__CUSTOM_COMPONENT__AMPLITUDE, // float
};

struct tm_custom_component_t {
    float y0;
    float frequency;
    float amplitude;
};
</code></pre>
<h3 id="add-your-component-to-the-truth"><a class="header" href="#add-your-component-to-the-truth">Add your component to the Truth</a></h3>
<p>After this, we have the region in which we define the category of our component. The Editor will call it to categorize the component into the correct section. </p>
<p>We need to define a <a href="https://ourmachinery.com/apidoc/plugins/the_machinery_shared/component_interfaces/editor_ui_interface.h.html#structtm_ci_editor_ui_i">tm_ci_editor_ui_i</a> object which uses this function.  Later we register this function to the <a href="https://ourmachinery.com/apidoc/plugins/the_machinery_shared/component_interfaces/editor_ui_interface.h.html#tm_ci_editor_ui">TM_CI_EDITOR_UI</a> aspect of our truth type. If you do not add this aspect later to your Truth Type, the Editor will not know that this Component Type exists, and you can not add it via the Editor, but in C.</p>
<blockquote>
<p><strong>Note:</strong> More about aspects you can read in the <a href="gameplay_coding/ecs/write_a_custom_component.html#">aspects guide</a>.</p>
</blockquote>
<pre><code class="language-c">static const char* component__category(void)
{
    return TM_LOCALIZE(&quot;Samples&quot;);
}

static tm_ci_editor_ui_i* editor_aspect = &amp;(tm_ci_editor_ui_i){
    .category = component__category
};
</code></pre>
<p>In this region, we create our component truth type. It is important to remember that the Truth will not reflect the runtime data, just the data you can edit in the Editor. On the other hand, the Entity Context will store your runtime data, the plain old data struct you have defined above. More about how this works later in this section.</p>
<p>Let us take this code apart one more time:</p>
<pre><code class="language-c">static void truth__create_types(struct tm_the_truth_o* tt)
{
    tm_the_truth_property_definition_t custom_component_properties[] = {
        [TM_TT_PROP__CUSTOM_COMPONENT__FREQUENCY] = { &quot;frequency&quot;, TM_THE_TRUTH_PROPERTY_TYPE_FLOAT },
        [TM_TT_PROP__CUSTOM_COMPONENT__AMPLITUDE] = { &quot;amplitude&quot;, TM_THE_TRUTH_PROPERTY_TYPE_FLOAT },
    };

    const tm_tt_type_t custom_component_type = tm_the_truth_api-&gt;create_object_type(tt, TM_TT_TYPE__CUSTOM_COMPONENT, custom_component_properties, TM_ARRAY_COUNT(custom_component_properties));
    const tm_tt_id_t default_object = tm_the_truth_api-&gt;quick_create_object(tt, TM_TT_NO_UNDO_SCOPE, TM_TT_TYPE_HASH__CUSTOM_COMPONENT, TM_TT_PROP__CUSTOM_COMPONENT__FREQUENCY, 1.0f, TM_TT_PROP__CUSTOM_COMPONENT__AMPLITUDE, 1.0f, -1);
    tm_the_truth_api-&gt;set_default_object(tt, custom_component_type, default_object);

    tm_the_truth_api-&gt;set_aspect(tt, custom_component_type, TM_CI_EDITOR_UI, editor_aspect);
}
</code></pre>
<ol>
<li>We define the component's properties.</li>
<li>We create the actual type in the Truth.</li>
<li>We create an object of our type with <code>quick_create_object</code> and provide a default object to our component. It makes sure that when you add the component to an Entity, you have the expected default values. It is not needed, just a nice thing to have.</li>
<li>Add our <a href="https://ourmachinery.com/apidoc/plugins/the_machinery_shared/component_interfaces/editor_ui_interface.h.html#tm_ci_editor_ui">TM_CI_EDITOR_UI</a> aspect to the type. It tells the Editor that you can add the component via the Editor. If you do not provide it, the Editor will not suggest this component to you and cannot store it in the Truth. It does not mean you cannot add this component via C.</li>
</ol>
<h3 id="define-your-component"><a class="header" href="#define-your-component">Define your component</a></h3>
<p>You an register a component to the <a href="https://ourmachinery.com/apidoc/plugins/entity/entity.h.html#tm_entity_create_component_interface_name">TM_ENTITY_CREATE_COMPONENT_INTERFACE_NAME</a> in your plugin load function. This interface expects a function pointer to a create component function of the signature: <code>void tm_entity_create_component_i(struct tm_entity_context_o *ctx)</code>.</p>
<p>The Engine will call this function whenever it creates a new Entity Context to populate the context with all the known components. It usually happens at the beginning of the Simulation.</p>
<p>Within this function, you can define your component and register it to the context. The <a href="https://ourmachinery.com/apidoc/plugins/entity/entity.h.html#structtm_entity_api">tm_entity_api</a> provides a function <code>tm_entity_api.register_component()</code> which expects the current context and a instance of the <a href="https://ourmachinery.com/apidoc/plugins/entity/entity.h.html#structtm_component_i">tm_component_i</a>. We define one in our function and give it the needed information:</p>
<ul>
<li>A name should be the same as the Truth Type</li>
<li>The size of the component struct</li>
<li>A load asset function</li>
</ul>
<pre><code class="language-c">static void component__create(struct tm_entity_context_o* ctx)
{
    tm_component_i component = {
        .name = TM_TT_TYPE__CUSTOM_COMPONENT,
        .bytes = sizeof(struct tm_custom_component_t),
        .load_asset = component__load_asset,
    };

    tm_entity_api-&gt;register_component(ctx, &amp;component);
}
</code></pre>
<p>As mentioned before, the Truth does not reflect the runtime data and only holds the data you can edit in the Editor. This is why there needs to be some translation between The Truth and the ECS. This magic is happening in the <code>tm_component_i.load_asset()</code>. This function allows you to translate a <a href="https://ourmachinery.com/apidoc/foundation/api_types.h.html#structtm_tt_id_t">tm_tt_id_t</a> asset to the plain old data of the component.</p>
<pre><code class="language-c">static bool component__load_asset(tm_component_manager_o* man, tm_entity_t e, void* c_vp, const tm_the_truth_o* tt, tm_tt_id_t asset)
{
    struct tm_custom_component_t* c = c_vp;
    const tm_the_truth_object_o* asset_r = tm_tt_read(tt, asset);
    c-&gt;y0 = 0;
    c-&gt;frequency = tm_the_truth_api-&gt;get_float(tt, asset_r, TM_TT_PROP__CUSTOM_COMPONENT__FREQUENCY);
    c-&gt;amplitude = tm_the_truth_api-&gt;get_float(tt, asset_r, TM_TT_PROP__CUSTOM_COMPONENT__AMPLITUDE);
    return true;
}
</code></pre>
<p>The first step is that we cast the given <code>void*</code> of the component data <code>c_vp</code> to the correct data type. After that, we load the data from the Truth and store it in the component. In the end, we return true because no error occurred.</p>
<h3 id="define-your-engine-update"><a class="header" href="#define-your-engine-update">Define your engine update</a></h3>
<p><em>In the Machinery, gameplay code is mainly driven by Systems and Engines. They define the behaviour while the components the data describes.</em> </p>
<blockquote>
<p><strong>Note:</strong> in some entity systems, these are referred to as <em>systems</em> instead, but we choose <em>Engine</em> because it is less ambiguous.</p>
</blockquote>
<p>This next section of the code is about defining an Engine.</p>
<pre><code class="language-c">// Runs on (custom_component, transform_component)
static void engine_update__custom_component(tm_engine_o* inst, tm_engine_update_set_t* data)
{
    TM_INIT_TEMP_ALLOCATOR(ta);

    tm_entity_t* mod_transform = 0;

    struct tm_entity_context_o* ctx = (struct tm_entity_context_o*)inst;

    double t = 0;
    for (const tm_entity_blackboard_value_t* bb = data-&gt;blackboard_start; bb != data-&gt;blackboard_end; ++bb) {
        if (TM_STRHASH_EQUAL(bb-&gt;id, TM_ENTITY_BB__TIME))
            t = bb-&gt;double_value;
    }

    for (tm_engine_update_array_t* a = data-&gt;arrays; a &lt; data-&gt;arrays + data-&gt;num_arrays; ++a) {
        struct tm_custom_component_t* custom_component = a-&gt;components[0];
        tm_transform_component_t* transform = a-&gt;components[1];

        for (uint32_t i = 0; i &lt; a-&gt;n; ++i) {
            if (!custom_component[i].y0)
                custom_component[i].y0 = transform[i].world.pos.y;
            const float y = custom_component[i].y0 + custom_component[i].amplitude * sinf((float)t * custom_component[i].frequency);

            transform[i].world.pos.y = y;
            ++transform[i].version;
            tm_carray_temp_push(mod_transform, a-&gt;entities[i], ta);
        }
    }

    tm_entity_api-&gt;notify(ctx, data-&gt;engine-&gt;components[1], mod_transform, (uint32_t)tm_carray_size(mod_transform));

    TM_SHUTDOWN_TEMP_ALLOCATOR(ta);
}
</code></pre>
<p>The first thing we do is use a temp allocator for any future allocation that will not leave this function. After that, we cast the <code>tm_engine_o* inst</code> to the <code>tm_entity_context_o*</code> so we have access to the entity context later on.</p>
<p>The next step is to get the time from the Blackboard Values. </p>
<pre><code class="language-c">
double t = 0;
for (const tm_entity_blackboard_value_t* bb = data-&gt;blackboard_start; bb != data-&gt;blackboard_end; ++bb) {
        if (TM_STRHASH_EQUAL(bb-&gt;id, TM_ENTITY_BB__TIME))
            t = bb-&gt;double_value;
    }
</code></pre>
<p>The Engine provides a bunch of useful Blackboard values. They are defined in the <code>plugins/entity/entity.h</code>.</p>
<ul>
<li><a href="https://ourmachinery.com/apidoc/plugins/entity/entity.h.html#tm_entity_bb__simulation_speed">TM_ENTITY_BB__SIMULATION_SPEED</a> - Speed that the simulation is running at. Defaults to 1.0 for normal speed.</li>
<li><a href="https://ourmachinery.com/apidoc/plugins/entity/entity.h.html#tm_entity_bb__delta_time">TM_ENTITY_BB__DELTA_TIME</a> - Blackboard item representing the simulation delta time of the current frame.</li>
<li><a href="https://ourmachinery.com/apidoc/plugins/entity/entity.h.html#tm_entity_bb__time">TM_ENTITY_BB__TIME</a> - Blackboard item representing the total elapsed time in the Simulation.</li>
<li><a href="https://ourmachinery.com/apidoc/plugins/entity/entity.h.html#tm_entity_bb__wall_delta_time">TM_ENTITY_BB__WALL_DELTA_TIME</a> - Blackboard item representing the wall delta time of the current frame. (Wall delta time is not affected by the Simulation being paused or run in slow motion.)</li>
<li><a href="https://ourmachinery.com/apidoc/plugins/entity/entity.h.html#tm_entity_bb__wall_time">TM_ENTITY_BB__WALL_TIME</a> - Blackboard item representing the total elapsed wall time in the Simulation.</li>
<li><a href="https://ourmachinery.com/apidoc/plugins/entity/entity.h.html#tm_entity_bb__camera">TM_ENTITY_BB__CAMERA</a> - Blackboard items for the current camera.</li>
<li><a href="https://ourmachinery.com/apidoc/plugins/entity/entity.h.html#tm_entity_bb__editor">TM_ENTITY_BB__EDITOR</a> - Blackboard item that indicates that we are running in <em>Editor</em> mode. This may disable some components and/or simulation engines.</li>
<li><a href="https://ourmachinery.com/apidoc/plugins/entity/entity.h.html#tm_entity_bb__simulating_in_editor">TM_ENTITY_BB__SIMULATING_IN_EDITOR</a> - Set to non-zero if the Simulation runs from within the Editor, such as running a game in the simulation tab. It will be zero when we run a game from the Runner. Note the distinction from <a href="https://ourmachinery.com//apidoc/plugins/entity/entity.h.html#tm_entity_bb__editor">TM_ENTITY_BB__EDITOR</a>.</li>
</ul>
<p>The <a href="https://ourmachinery.com/apidoc/plugins/entity/entity.h.html#structtm_engine_update_set_t">tm_engine_update_set_t</a> gives us access to the needed data, and we can modify our component. The first important information we get are the number of entity types (also known Archetypes). This number is stored in <code>data-&gt;num_arrays</code>. Now that we know this information we can iterate over them and access the components per entity type. <code>tm_engine_update_array_t a =  data-&gt;arrays</code> (Gives us the current entity type's components). <code>a-&gt;n</code> is the number of matching components / entities of this entity type.</p>
<pre><code class="language-c">
    for (tm_engine_update_array_t* a = data-&gt;arrays; a &lt; data-&gt;arrays + data-&gt;num_arrays; ++a) {
        struct tm_custom_component_t* custom_component = a-&gt;components[0];
        tm_transform_component_t* transform = a-&gt;components[1];

        for (uint32_t i = 0; i &lt; a-&gt;n; ++i) {
            if (!custom_component[i].y0)
                custom_component[i].y0 = transform[i].world.pos.y;
            const float y = custom_component[i].y0 + custom_component[i].amplitude * sinf((float)t * custom_component[i].frequency);

            transform[i].world.pos.y = y;
            ++transform[i].version;
            tm_carray_temp_push(mod_transform, a-&gt;entities[i], ta);
        }
    }
</code></pre>
<blockquote>
<p><strong>Note</strong>: In case you are not that familiar with C this loop:</p>
<pre><code class="language-c"> for (tm_engine_update_array_t* a = data-&gt;arrays; a &lt; data-&gt;arrays + data-&gt;num_arrays; ++a) {
</code></pre>
<p>is kind of the C equivalent to C++'s for each loop: <code>for(auto a : data-&gt;arrays)</code></p>
</blockquote>
<p>As the last step, we add a notifier function call to notify all entities that their components have changed.</p>
<pre><code class="language-c">    tm_entity_api-&gt;notify(ctx, data-&gt;engine-&gt;components[1], mod_transform, (uint32_t)tm_carray_size(mod_transform));
</code></pre>
<h3 id="register-your-engine-to-the-system"><a class="header" href="#register-your-engine-to-the-system">Register your Engine to the system</a></h3>
<p>You an register a component to the <a href="https://ourmachinery.com/apidoc/plugins/entity/entity.h.html#tm_entity_simulation_register_engines_interface_name">TM_ENTITY_SIMULATION_REGISTER_ENGINES_INTERFACE_NAME</a> in your plugin load function. This interface expects a function pointer to a create component function of the signature: <code>void tm_entity_register_engines_i(struct tm_entity_context_o *ctx)</code>. </p>
<p>The function itself looks as follows:</p>
<pre><code class="language-c">static void component__register_engine(struct tm_entity_context_o* ctx)
{
    const tm_component_type_t custom_component = tm_entity_api-&gt;lookup_component_type(ctx, TM_TT_TYPE_HASH__CUSTOM_COMPONENT);
    const tm_component_type_t transform_component = tm_entity_api-&gt;lookup_component_type(ctx, TM_TT_TYPE_HASH__TRANSFORM_COMPONENT);

    const tm_engine_i custom_component_engine = {
        .ui_name = &quot;Custom Component&quot;,
        .hash  = TM_STATIC_HASH(&quot;CUSTOM_COMPONENT&quot;, 0xe093a8316a6c2d29ULL),
        .num_components = 2,
        .components = { custom_component, transform_component },
        .writes = { false, true },
        .update = engine_update__custom_component,
        .filter = engine_filter__custom_component,
        .inst = (tm_engine_o*)ctx,
    };
    tm_entity_api-&gt;register_engine(ctx, &amp;custom_component_engine);
}
</code></pre>
<p>The first thing we do is looking up the component type. Did we register the type? If not, we will not get the correct type. Here we are using the name we defined beforehand in our component create function.</p>
<p>Then we ask for the transform component next because our Engine shall run on those two components.</p>
<p>After this, we define the actual instance of our engine struct</p>
<p><a href="https://ourmachinery.com/apidoc/plugins/entity/entity.h.html#structtm_engine_i">tm_engine_i</a>. </p>
<p>We provide a <code>.ui_name</code> used in the Profiler to identify our Engine. Moreover, we add a unique string hash identifying this engine/system. This is used for scheduling the engine/system concerning other engines and systems, using the<code>before_me</code> and <code>after_me</code> fields.</p>
<p>Then we tell the system how many components the Engine shall operate on and which ones we will modify. This is used for scheduling the engines later one.</p>
<p>At last, we provide the needed update function, which we have discussed earlier, and a filter function.</p>
<pre><code class="language-c">static bool engine_filter__custom_component(tm_engine_o* inst, const tm_component_type_t* components, uint32_t num_components, const tm_component_mask_t* mask)
{
    return tm_entity_mask_has_component(mask, components[0]) &amp;&amp; tm_entity_mask_has_component(mask, components[1]);
}
</code></pre>
<p>The filter function will be called on all entity types to determine if the Engine shall run on them or not.  To provide this function is optional. If present it specifies a filter function called for each entity type (as</p>
<p>represented by its component mask) to determine if the Engine should run on that entity type. If no <code>tm_engine_i.filter()</code> function is supplied and no <code>excludes[]</code> flags are set, the update will run on entity types that have all the components in the <code>components</code> array. If some <code>excludes[]</code> flags are set, the Engine will run on all entity types that <strong>do not</strong> have any of the components whose <code>excludes[]</code> flags are set, but have all the other components in the <code>components</code> array. </p>
<blockquote>
<p><strong>Note:</strong> For more information, check the <a href="https://ourmachinery.com//apidoc/plugins/entity/entity.h.html#structtm_engine_i.filter()">documentation</a>.</p>
</blockquote>
<p>The last thing the register function needs to do is register the Engine to the Entity Context.</p>
<pre><code class="language-c"> tm_entity_api-&gt;register_engine(ctx, &amp;custom_component_engine);
</code></pre>
<h3 id="the-plugin-load-function"><a class="header" href="#the-plugin-load-function">The plugin load function</a></h3>
<p>The most important lines here are the once in which we register our truth types, the component and the engine.</p>
<pre><code class="language-c">TM_DLL_EXPORT void tm_load_plugin(struct tm_api_registry_api* reg, bool load)
{
    tm_entity_api = reg-&gt;get(TM_ENTITY_API_NAME);
    tm_transform_component_api = reg-&gt;get(TM_TRANSFORM_COMPONENT_API_NAME);
    tm_the_truth_api = reg-&gt;get(TM_THE_TRUTH_API_NAME);
    tm_temp_allocator_api = reg-&gt;get(TM_TEMP_ALLOCATOR_API_NAME);
    tm_localizer_api = reg-&gt;get(TM_LOCALIZER_API_NAME);

    tm_add_or_remove_implementation(reg, load, TM_THE_TRUTH_CREATE_TYPES_INTERFACE_NAME, truth__create_types);
    tm_add_or_remove_implementation(reg, load, TM_ENTITY_CREATE_COMPONENT_INTERFACE_NAME, component__create);
    tm_add_or_remove_implementation(reg, load, TM_ENTITY_SIMULATION_REGISTER_ENGINES_INTERFACE_NAME, component__register_engine);
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="how-can-we-implement-interaction-between-entities"><a class="header" href="#how-can-we-implement-interaction-between-entities">How can we implement interaction between entities?</a></h2>
<p>There are two problems in an ECS (Entity Component System) regarding the interaction between Entities: The <strong>read</strong> and the <strong>write</strong> access. </p>
<p>The truth about the interaction between Entities is that interactions do not genuinely exist. They are hidden beneath the implementation of the underlying relationship. A relationship is then nothing else than the transformation of data.</p>
<p>To choose the right tool for creating those transformations, we need to reason about our code (and what we want to achieve) and ask ourselves the following five questions: </p>
<ul>
<li>On what data do we operate? </li>
<li>What is our domain?</li>
<li>What is the possible input for our transformation? </li>
<li>What is the frequency of the data use? </li>
<li>What are we actually transforming?</li>
<li>How could our algorithm look like? </li>
<li>How often do we perform our transformation?</li>
</ul>
<p>For infrequent read access we can easily use the <code>tm_entity_api.get_component()</code> . It allows access to the underlying data directly from a provided entity. It is not recommended to use that for read-access because it is quite slow. You perform a random data access. But again, if it is infrequent of the operation and the number of targets (Entities), which are interesting to choose the right tool.</p>
<blockquote>
<p>Here, you can use a System better than an <code>Engine</code>, since a System doe not run in parallel and provides access to the Entity Context.</p>
</blockquote>
<h2 id="the-problem"><a class="header" href="#the-problem">The problem</a></h2>
<p>When creating interactions between entities, we mainly face two types of problems:</p>
<ol>
<li><strong>Read Access:</strong> It means we have to read specific properties from a particular entity (object) and react based on this. <strong>In terms of games:</strong> An Actor needs to query/know some information from another part of the game. <strong>For example, within a Quest System:</strong> Have all tasks been completed?</li>
<li><strong>Write access:</strong> It means we have to write specific properties to a particular entity (object).</li>
</ol>
<p><strong>The transformation from *Interaction* towards *Relationships*</strong></p>
<p>To start this transformation, we should have a quick look at the first principle of <em>Data-Oriented Design</em>:</p>
<blockquote>
<p>Data is not the problem domain. For some, it would seem that data-oriented design is the antithesis of most other programming paradigms because the data-oriented design is a technique that does not readily allow the problem domain to enter into the software so readily. It does not recognize the concept of an object in any way, as data is consistent without meaning […] The data-oriented design approach doesn’t build the real-world problem into the code. This could be seen as a failing of the data-oriented approach by veteran object-oriented developers, as many examples of the success of object-oriented design come from being able to bring human concepts to the machine. In this middle ground, a solution can be written in this language that is understandable by both humans and computers. The data-oriented approach gives up some of the human readability by leaving the problem domain in the design document but stops the machine from having to handle human concepts at any level by just that same action — <a href="http://www.dataorienteddesign.com/">Data Oriented Design Book Chapter 1.2</a></p>
</blockquote>
<p>This principle helps us recognize that interactions <em>do not truly exist. They hide the implementation of the underlying relationship</em>. A relationship is nothing else than a transformation of data. In the case of an ECS, the Entity Manager (In our case, Entity Context) can be seen as a database and the Entity as a Lookup table key that indexes relationships between components. </p>
<p>The systems (or engines) are just here to interpret those relationships and give them meaning. Therefore, a system and engines should only do one job and do this well. </p>
<p>Systems/Engines perform transformations of data. This understanding allows us to create generic systems which are decoupled and easy to reuse, and as such, we should keep the following in mind:</p>
<p>One of the main design goals for <em>Data-Oriented Design-driven</em> applications is to focus on reusability through decoupling whenever possible. </p>
<blockquote>
<p>Thus, the Unix philosophy <em>Write programs that do one thing and do it well. Write programs to work together — McIlroy</em> is a good way of expressing what a system/engine should do.</p>
</blockquote>
<p>Most ECS's are built with the idea of relationships in mind. When writing systems/engines, we transform data from one state to another to give the data meaning. Therefore systems/engines are defining the purpose of the data relationships. This decoupling provides us with the flexibility we need to design complex software such as video games. </p>
<p>With such a design, we can modify behavior later on without breaking any dependencies.</p>
<blockquote>
<p><em>For example:</em></p>
<p><em>You have one movement engine designed for the Player at first. Later on, you want to reuse it for all entities with a movement controller component. It contains the data provided by the Input System, such as which keys have been pressed. Therefore, an AI system can feed this as well for any other Unit (With the Movement Controller component, not the Player). The Movement Engine does not care about where the data comes from or who has it as long as it is present and the other needed component. (E.g. The Physics Mover or Transform)</em></p>
</blockquote>
<p><strong>How do we design Systems?</strong></p>
<p>To implement the before-mentioned relationships, we have to undertake a couple of steps. </p>
<blockquote>
<p>These steps are also interesting for none programmers who design gameplay systems. Having those flashed out when they design game mechanics can be good and speed up your work. </p>
</blockquote>
<p>We have to ask the following questions:</p>
<p><strong>1.</strong> What data transformations are we going to do and on which data? </p>
<p>This question should lead to “what components do we need to create this relationship?” We should always be able to give a reason why we need this data.</p>
<p><strong>2.</strong> What is our possible domain? (What kind of inputs do we have?)</p>
<p>When we figure this out, we can make the right decision later. Also, we can reason about our code how to implement these relationships?</p>
<p><strong>3.</strong> How often does the data change? </p>
<p>To determine how often we change the data, we go through component by component and discuss how often we change it. This process is vital to pick the right tool. Knowing those numbers or tendencies is great for reasoning about possible performance bottlenecks and where we could apply optimizations.</p>
<p><strong>4.</strong> What are we actually transforming?</p>
<p>Writing down the algorithm (in code or on paper) or the constraints of what we are actually doing with our data is a great solution.  To pick the right tool based on the planned algorithm, we need to consider the <strong>cost</strong> of our algorithm.</p>
<p>What does <strong>cost</strong> mean? It can mean anything from runtime costs to implementation costs. It is essential first to establish what the proper criteria are. The costs at the end enable us to reason about the code.</p>
<p>To pick the right tool, we need to reason about the costs an algorithm costs us. If we take run time performance as a measurement, it is okay to have a slow algorithm if we do not execute this frequently. If this is not the case, you should consider another solution.</p>
<p><strong>5.</strong> How often do we execute the algorithm/transformation?</p>
<p>Based on the information we have already about the data we need for the transformation, it’s pretty easy to determine the execution frequency. The total number of entities/objects is known at this time. (It may be an estimation). Therefore, we can guess how often this might run. Keep in mind that we previously discussed how often we suspect the data to be changed. This leads to transparency, which gives a good idea of the costs of this code.</p>
<p>Keep in mind that the main goal is to keep things simple. A System/Engine should do one job. As the variety of components defines the data type of the Entity. And the combination of System's/Engines defines the actual game behavior. Therefore you do not need to write diagrams, blueprints, pseudo-code, or anything. You maybe even be able just to write the engine in one goal. It is recommended to do those steps even in your mind before you write your system.</p>
<blockquote>
<p><strong>IMPORTANT:</strong> When the data changes, the problem changes. Therefore, we have to properly evaluate with the descriptive method the possible outcome and maybe change the implementation.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-design-a-systems--engines"><a class="header" href="#how-to-design-a-systems--engines">How to design a Systems &amp; Engines</a></h1>
<p>In the Machinery, you provide the behavior for your gameplay code via Engines and Systems. The difference between Engines and Systems is that Engines provide an explicitly defined subset of components while Systems give you only access to the Entity Context.</p>
<p>This separation means that Engines are better used for high-frequency operations on many entities. At the same time, Systems are better used for broader operations such as input on a few Entities / Single entities.</p>
<blockquote>
<p><strong>Documentation:</strong> The difference between <em>engines</em> and <em>systems</em> is that engines are fed component data, where assystems are not. Thus, systems are useful when the data is stored externally from the components (for example to update a physics simulation), whereas <em>engines</em> are more efficient when the data  is stored in the components. (You could use a <em>system</em> to update data in components, but it would be inefficient, because you would have to perform a lot of lookups to access the component data.)</p>
</blockquote>
<p>These are a couple of questions you should ask yourself in advance.</p>
<ul>
<li>On what data do we operate?</li>
<li>What is our domain?</li>
<li>What is the possible input for our transformation?</li>
<li>What is the frequency of the data use?</li>
<li>What are we actually transforming?</li>
<li>How could our algorithm look like?</li>
<li>How often do we perform our transformation?</li>
</ul>
<blockquote>
<p>More details about those questions click here : <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book//gameplay_coding/ecs/how_entites_can_interact.html">How entites can interact.</a></p>
</blockquote>
<p>At the end of this, you should be able to answer the following questions:</p>
<ul>
<li>What kind of data am I going to read?</li>
<li>What kind of data am I going to write?</li>
<li>Should my operation be exclusive? Hence not to be executed in parallel?</li>
<li>In which phase does it run? </li>
<li>What dependencies do I have?</li>
</ul>
<p>Those answers are important for the automatic scheduling of the Systems/Engines. Based on all those inputs, the Entity System can determine when and how to schedule what.</p>
<p><em>Example:</em></p>
<pre><code class="language-c">    const tm_engine_i movement_engine = {
        .ui_name = &quot;movement_engine&quot;,
        .hash = TM_STATIC_HASH(&quot;movement_engine&quot;, 0x336880a23d06646dULL),
        .num_components = 4,
        .components = { keyboard_component, movement_component, transform_component, mover_component },
        .writes = { false, false, true, true },
        .update = movement_update,
        .inst = (tm_engine_o *)ctx,
    };
    tm_entity_api-&gt;register_engine(ctx, &amp;movement_engine);
</code></pre>
<p>This movement engine will operate on:</p>
<ul>
<li><code>keyboard_component</code></li>
<li><code>movement_component</code></li>
<li><code>transform_component</code></li>
<li><code>mover_component</code></li>
</ul>
<p>components. The scheduler can now look for those components in other engines and deterimine based on the .<code>write</code> field how to schedule it efficent.</p>
<p>In this example the scheduler can schedule any engine that writes to the keyboard and the movement component ath the same time as this engine if they do not write to the transfrom and mover component!</p>
<h2 id="what-is-next-3"><a class="header" href="#what-is-next-3">What is next?</a></h2>
<p>More details on writing your own system or engine is explained in the next chapter</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="defining-a-system-and-engines"><a class="header" href="#defining-a-system-and-engines">Defining a System and Engines</a></h1>
<p>You have to pass the  <a href="https://ourmachinery.com/apidoc/plugins/entity/entity.h.html#structtm_entity_system_i">tm_entity_system_i</a> or <a href="https://ourmachinery.com/apidoc/plugins/entity/entity.h.html#structtm_engine_i">tm_engine_i</a> instance in your register function.</p>
<p><strong>Table of Content</strong></p>
<ul>
<li><a href="gameplay_coding/ecs/how_to_define_a_engine_system.html#ask-yourself-those-questions-before-you-design-a-engine--system">Ask yourself those questions before you design a Engine / System</a>
<ul>
<li><a href="gameplay_coding/ecs/how_to_define_a_engine_system.html#how-do-those-questions-translate">How do those questions translate?</a></li>
</ul>
</li>
<li><a href="gameplay_coding/ecs/how_to_define_a_engine_system.html#what-is-next">What is next?</a></li>
</ul>
<h2 id="ask-yourself-those-questions-before-you-design-a-engine--system"><a class="header" href="#ask-yourself-those-questions-before-you-design-a-engine--system">Ask yourself those questions before you design a Engine / System</a></h2>
<p>The following questions are better explain in the chapter: <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book//gameplay_coding/ecs/how_entites_can_interact.html">How entites can interact.</a></p>
<ul>
<li>On what data do we operate?</li>
<li>What is our domain?</li>
<li>What is the possible input for our transformation?</li>
<li>What is the frequency of the data use?</li>
<li>What are we actually transforming?</li>
<li>How could our algorithm look like?</li>
<li>How often do we perform our transformation?</li>
</ul>
<p>and my answers</p>
<ul>
<li>What kind of data am I going to read?</li>
<li>What kind of data am I going to write?</li>
<li>What kind of data do I want to ignore? (<strong>only important for engines</strong>)</li>
<li>Should my operation be exclusive? Hence not to be executed in parallel?</li>
<li>In which phase does it run? </li>
<li>What dependencies do I have?</li>
</ul>
<p>Now it is time to define the dependencies / important items for scheduling.</p>
<h3 id="how-do-those-questions-translate"><a class="header" href="#how-do-those-questions-translate">How do those questions translate?</a></h3>
<p><strong>What kind of data am I going to read?  &amp;&amp; What kind of data am I going to write?</strong></p>
<p>They translate <code>.write</code> and <code>.components.</code> With those fields, we tell the scheduler what components this system operates. From which components it intends to read from and to which one it writes.</p>
<p><strong>What kind of data do I want to ignore?</strong> (only important for engines)</p>
<p>In the <a href="https://ourmachinery.com/apidoc/plugins/entity/entity.h.html#structtm_engine_i">tm_engine_i</a> you can provide a way to filter your component. Thus you can decide on which components the engine shall run.  The field <code>.excluded</code> is used for this in there you can define which components a entity type shall <strong>not</strong> have. This means that when the engine is scheduled all entities will be ignored with those components. </p>
<p>For more information see <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book//gameplay_coding/ecs/tagging_entities.html">Tagging Entities</a> and <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book//gameplay_coding/ecs/filtering_entities.html">Filtering Entities</a></p>
<p><strong>Should my operation be exclusive? Hence not to be executed in parallel?</strong></p>
<p>If we are sure that our system/engine should not run parallel, we need to tell the scheduler by setting the <code>.exclusive</code> flag to true. It will not run in parallel with any other systems or engines in the entity context. If it is <strong>false</strong>, components and writes will be used to determine parallelism.</p>
<p><strong>In which phase does it run?</strong> </p>
<p>We can define the <code>.phase</code> to tell the system in which phase we want our operation to run.</p>
<p><strong>What dependencies do I have?</strong></p>
<p>We can define dependencies by saying: <code>.before_me</code> and <code>.after_me</code>. We just pass the string has of the other engine/system to this, and the scheduler does the rest.</p>
<h2 id="what-is-next-4"><a class="header" href="#what-is-next-4">What is next?</a></h2>
<p>In the next chapter we translate this to actual code!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="registering-a-system-or-an-engine"><a class="header" href="#registering-a-system-or-an-engine">Registering a System or an Engine</a></h1>
<p>To register Systems/Engines, you need to provide a register function to the <a href="https://ourmachinery.com/apidoc/plugins/entity/entity.h.html#tm_entity_simulation_register_engines_interface_name">TM_ENTITY_SIMULATION_REGISTER_ENGINES_INTERFACE_NAME</a> interface. This function has the signature:</p>
<pre><code class="language-c">static void register_or_system_engine(struct tm_entity_context_o *ctx){}
</code></pre>
<p>For more information check the <a href="https://ourmachinery.com/apidoc/plugins/entity/entity.h.html#tm_entity_register_engines_i">tm_entity_register_engines_i</a> .</p>
<p>Whenever the Machinery creates an Entity Context, it calls this function and registers all your Systems / Engines to this context.</p>
<blockquote>
<p>The Entity context is the world in which all your entities exist.</p>
</blockquote>
<p>For Engines, you pass an instance of the <a href="https://ourmachinery.com/apidoc/plugins/entity/entity.h.html#structtm_entity_system_i">tm_entity_system_i</a> to the register function.</p>
<pre><code class="language-c">// example:
static void register_or_system_engine(struct tm_entity_context_o *ctx){
    const tm_engine_i movement_engine = {
        .ui_name = &quot;movement_engine&quot;,
        .hash = TM_STATIC_HASH(&quot;movement_engine&quot;, 0x336880a23d06646dULL),
        .num_components = 4,
        .components = { keyboard_component, movement_component, transform_component, mover_component },
        .writes = { false, false, true, true },
        .excluded = { no_movement },
        .num_excluded = 1,
        .update = movement_update,
        .inst = (tm_engine_o *)ctx,
    };
    tm_entity_api-&gt;register_engine(ctx, &amp;movement_engine);
}
</code></pre>
<p>For Systems, you pass an instance of the <a href="https://ourmachinery.com/apidoc/plugins/entity/entity.h.html#structtm_engine_i">tm_engine_i</a> to the register function.</p>
<pre><code class="language-c">static void register_or_system_engine(struct tm_entity_context_o *ctx){
    const tm_entity_system_i winning_system = {
        .ui_name = &quot;winning_system_update&quot;,
        .hash = TM_STATIC_HASH(&quot;winning_system_update&quot;, 0x8f8676e599ca5c7aULL),
        .update = winning_system_update,
        .before_me[0] = TM_STATIC_HASH(&quot;maze_generation_system&quot;, 0x7f1fcbd9ee85c3cfULL),
        .exclusive = true,
        .inst = (tm_entity_system_o *)tm_entity_api-&gt;component_manager(ctx, tag_component),
    };
    tm_entity_api-&gt;register_system(ctx, &amp;winning_system);
}
</code></pre>
<p>In the above example the scheduler will schedule this system after the <code>maze_generation_system</code> system! Since we did not provide any further information in <code>.writes</code> or in <code>.components</code> the scheduler has no other information to work with. In this case its best to not write to anything!</p>
<p><em>Example load function:</em></p>
<pre><code class="language-c">TM_DLL_EXPORT void tm_load_plugin(struct tm_api_registry_api *reg, bool load)
{
    // other code ...
    tm_add_or_remove_implementation(reg, load, TM_ENTITY_SIMULATION_REGISTER_ENGINES_INTERFACE_NAME, register_or_system_engine);
}
</code></pre>
<h2 id="register-your-system-or-engine-to-the-editor"><a class="header" href="#register-your-system-or-engine-to-the-editor">Register your system or engine to the Editor</a></h2>
<p>You can use the <a href="https://ourmachinery.com/apidoc/plugins/entity/entity.h.html#tm_entity_editor_register_engines_interface_name">TM_ENTITY_EDITOR_REGISTER_ENGINES_INTERFACE_NAME</a> to register your engine or system to a entity context that runs only in the Editor. This might be good for components that shall only be used in the Editor.</p>
<p>The function signature is the same as the for the other interface!</p>
<h3 id="register-systems--engines-outside-of-the-load-function"><a class="header" href="#register-systems--engines-outside-of-the-load-function">Register systems &amp; engines outside of the load function</a></h3>
<p>You also can register your System/Engine outside of the load function where ever you have access to the correct Entity Context.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tagging-entities"><a class="header" href="#tagging-entities">Tagging Entities</a></h1>
<p>The Machinery knows 2 kind of ways to Tag Entities:</p>
<ol>
<li>using the <code>Tag Component</code></li>
<li>using a <code>Tag Component</code> to filter the Entity Type's</li>
</ol>
<p><strong>Table of Content</strong></p>
<ul>
<li><a href="gameplay_coding/ecs/tagging_entities.html#using-the-tag-component">Using the Tag Component</a>
<ul>
<li><a href="gameplay_coding/ecs/tagging_entities.html#adding-them-via-the-editor">Adding them via The Editor</a></li>
<li><a href="gameplay_coding/ecs/tagging_entities.html#adding-and-accessing-tags-via-c">Adding and Accessing Tags via C</a></li>
</ul>
</li>
<li><a href="gameplay_coding/ecs/tagging_entities.html#tag-components---entity-type-filter">Tag Components - Entity Type Filter</a></li>
<li><a href="gameplay_coding/ecs/tagging_entities.html#filtering">Filtering</a></li>
</ul>
<h2 id="using-the-tag-component"><a class="header" href="#using-the-tag-component">Using the Tag Component</a></h2>
<p>The difference is that the first solution can be used via the <code>tag_component_api</code> and you can add Tags via the Editor to any Entity that has a Tag Component. Later on in your System or Engine you can access the Taged Entity.</p>
<blockquote>
<p><strong>Note:</strong> This is not the most performant solution but a easy way for entities which do not exist many times in the world. Its a nice way to identify one or two specifc entities for some specific logic.</p>
</blockquote>
<h3 id="adding-them-via-the-editor"><a class="header" href="#adding-them-via-the-editor">Adding them via The Editor</a></h3>
<p>You need to select a Entity and <strong>Right Click -&gt; Add Component</strong></p>
<p><img src="https://www.dropbox.com/s/x6pntlc4u0vw9pa/tm_guide_entity_tag_add_component.png?dl=1" alt="" /></p>
<p>This will add the <em>Entity Tag</em> Component. When selected you have the chance to add Tags to the Entity by using a simple auto complete text box. </p>
<p><strong>Beaware:</strong> The Engine will create a entity tag folder in your root folder. This is also the place where the Entity Tag API will search for the assets.</p>
<p><img src="https://www.dropbox.com/s/ve5lr0e0qcs221e/tm_guide_entity_tag.png?dl=1" alt="" /></p>
<h3 id="adding-and-accessing-tags-via-c"><a class="header" href="#adding-and-accessing-tags-via-c">Adding and Accessing Tags via C</a></h3>
<p>You can also add tags via the <code>tag_component_api</code> but you need access to the <code>Tag Component Manager</code>. In your System or on Simulate Entry <code>start()</code>:</p>
<pre><code class="language-c">tm_tag_component_manager_o *tag_mgr = (tm_tag_component_manager_o *)tm_entity_api-&gt;component_manager(ctx, tag_component);
tm_tag_component_api-&gt;add_tag(tag_mgr, my_to_tagged_entity, TM_STATIC_HASH(&quot;player&quot;, 0xafff68de8a0598dfULL));
</code></pre>
<p>You can also recive entities like this:</p>
<pre><code class="language-c">tm_tag_component_manager_o *tag_mgr = (tm_tag_component_manager_o *)tm_entity_api-&gt;component_manager(ctx, tag_component);
tm_entity_t upper_bounding_box = tm_tag_component_api-&gt;find_first(tag_mgr, TM_STATIC_HASH(&quot;upper_bounding_box&quot;, 0x1afc9d34ecb740ecULL));
</code></pre>
<p>And than you can read the data from the entity via <code>get_component</code>. This is where you will perform a random look up and this might be slow. Therefore it is mostly recommend to use this for simple interactions where performance is not needed.</p>
<blockquote>
<p><strong>Note:</strong> Tags do not need to exist in the Asset Browser, therefore you can add any label to the entity. Keep in mind that they will <strong>not</strong> be created in the Asset Browser!</p>
</blockquote>
<h2 id="tag-components---entity-type-filter"><a class="header" href="#tag-components---entity-type-filter">Tag Components - Entity Type Filter</a></h2>
<p>On the other hand you can define a <code>Tag</code> Component which should not be confused with the priviously explained <code>Tag Component</code>. A tag component is a simple typedef of a <code>unit64_t</code> (or something else) or an empty struct in C++ to a component without properties. The function of this component is it to modify the Entity Type / Archetype to group entities together with them.</p>
<p><em>Example:</em></p>
<p>You have the following components:</p>
<ul>
<li>Component A</li>
<li>Component B</li>
</ul>
<p>And 2 systems :</p>
<ul>
<li>System A </li>
<li>System B</li>
</ul>
<p>They both shall operate on Component A &amp; B but have different logic based on what the Components represent. To archive this you just add to a Entity a tag component:</p>
<pre><code>#1 Entity:
- Component A
- Component B
- My Tag For System A
#2 Entity:
- Component A
- Component B
- My Tag for System A
</code></pre>
<p>In this example System B would not operate on both Entities if we use the <code>.excluded</code> filter to exclude <code>My Tag For System A</code> from the System.</p>
<h2 id="filtering"><a class="header" href="#filtering">Filtering</a></h2>
<p>To see a realworld application of Tag components to filter entity types checkout the next chapter: <a href="gameplay_coding/ecs/">Filtering</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="filtering-entities"><a class="header" href="#filtering-entities">Filtering Entities</a></h1>
<p>The Machinery knows 2 kind of ways to Tag Entities:</p>
<ol>
<li>using the <code>Tag Component</code></li>
<li>using a <code>Tag Component</code> to filter the Entity Type's</li>
</ol>
<p><strong>Table of Content</strong></p>
<ul>
<li><a href="gameplay_coding/ecs/filtering_entities.html#filtering-entities">Filtering Entities</a></li>
<li><a href="gameplay_coding/ecs/filtering_entities.html#filtering-entities-by-using-tag-components">Filtering Entities by using Tag Components</a></li>
</ul>
<h2 id="filtering-entities-1"><a class="header" href="#filtering-entities-1">Filtering Entities</a></h2>
<p>In a Engine (<a href="https://ourmachinery.com/apidoc/plugins/entity/entity.h.html#structtm_engine_i">tm_engine_i</a>) you can define the <code>.excluded</code> filed. This tells the scheduler that this engine shall <strong>not</strong> run on any entity type that contains these components.</p>
<p>Let us assume we have the following entities:</p>
<pre><code>#1 Entity:
- Component A
- Component B
- Component C
#2 Entity:
- Component A
- Component B
- Component D
</code></pre>
<p>Now we have a Engine that shall operate on <code>(Component A,Component B)</code> but we do not want it to operate on entities with <code>Component D</code> we could just check in our update loop:</p>
<pre><code class="language-c">// Runs on (component a, comnponent b)
static void engine_update__custom_component(tm_engine_o* inst, tm_engine_update_set_t* data)
{
    struct tm_entity_context_o* ctx = (struct tm_entity_context_o*)inst;
// code
    for (tm_engine_update_array_t* a = data-&gt;arrays; a &lt; data-&gt;arrays + data-&gt;num_arrays; ++a) {
//.. code
        for (uint32_t i = 0; i &lt; a-&gt;n; ++i) {
            // if the entity has no component it returns a NULL pointer 
            if(!tm_entity_api-&gt;get_component_by_hash(ctx,a-&gt;entities[i],TM_TYPE_HASH__COMPONENT_D)){
                //..code
            }
        }
    }
//...code
}
</code></pre>
<p>or we could define a component mask and use this to filter but both methods are slow. This is because <code>get_component_by_hash</code> or <code>get_component</code> require us to look up internally the entity + the components and search for them. Its aka a random memory access! </p>
<p>To avoid all of this we can just tell the engine to ignore all entity types which contain the <code>component_d</code> via the <code>.excluded</code> fied in the <a href="https://ourmachinery.com/apidoc/plugins/entity/entity.h.html#structtm_engine_i">tm_engine_i</a>.</p>
<pre><code class="language-c">    const tm_engine_i my_system = {
        .ui_name = &quot;my_system&quot;,
        .hash = TM_STATIC_HASH(&quot;movement_engine&quot;, 0x336880a23d06646dULL),
        .num_components = 2,
        .components = { component_a, component_b },
        .writes = { false, true},
        .excluded = { component_d },
        .num_excluded = 1,
        .update = movement_update,
        .inst = (tm_engine_o *)ctx,
    };
    tm_entity_api-&gt;register_engine(ctx, &amp;movement_engine);
</code></pre>
<h2 id="filtering-entities-by-using-tag-components"><a class="header" href="#filtering-entities-by-using-tag-components">Filtering Entities by using Tag Components</a></h2>
<blockquote>
<p><strong>Note</strong>: You can define a <code>Tag</code> Component which should not be confused with the <code>Tag Component</code>. A tag component is a simple typedef of a <code>unit64_t</code> (or something else) or an empty struct in C++ to a component without properties. The function of this component is it to modify the Entity Type / Archetype to group entities together with them.For more information see the <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book//gameplay_coding/ecs/tagging_entities.html">Tagging Entities</a> Chapter.</p>
</blockquote>
<p>You have a Movement / Input System which should always work. At some point you do not want a entity to receive any input. </p>
<p><em>Solution 1</em></p>
<p>To solve this issue you could remove the Movement Component but that would be annyoing because you would lose it state, which might be important.</p>
<p><em>Better Solution</em></p>
<p>First you define the component:</p>
<pre><code class="language-c">#define TM_TT_TYPE__PLAYER_NO_MOVE_TAG_COMPONENT &quot;tm_player_no_move_t&quot;
#define TM_TT_HASH__PLAYER_NO_MOVE_TAG_COMPONENT TM_STATIC_HASH(&quot;tm_player_no_move_t&quot;, 0xc58cb6ade683ca88ULL)
static void component__create(struct tm_entity_context_o *ctx)
{
       tm_component_i component = (tm_component_i){
        .name = TM_TT_TYPE__PLAYER_NO_MOVE_TAG_COMPONENT,
        .bytes = sizeof(uint64_t), // since we do not care of its content we can just pick any 8 byte type
    };
    tm_entity_api-&gt;register_component(ctx, &amp;component);
}
}
</code></pre>
<p>Then you filter in your update for the Input Engine/ Movement Engine any Entity that has a No Movement Tag:</p>
<pre><code class="language-c">    const tm_engine_i movement_engine = {
        .ui_name = &quot;movement_engine&quot;,
        .hash = TM_STATIC_HASH(&quot;movement_engine&quot;, 0x336880a23d06646dULL),
        .num_components = 3,
        .components = { movement_component, transform_component, mover_component },
        .writes = { false, true, true },
        .excluded = { no_movement_tag_component },
        .num_excluded = 1,
        .update = movement_update,
        .inst = (tm_engine_o *)ctx,
    };
    tm_entity_api-&gt;register_engine(ctx, &amp;movement_engine);
</code></pre>
<p>When ever another <code>engine/system</code> decides that a entity should not move anymore it just adds a <code>no_movement_tag_component</code> to the entity.</p>
<pre><code class="language-c">static void my_other_system(tm_engine_o *inst, tm_engine_update_set_t *data)
{
    // code ..
	for (tm_engine_update_array_t *a = data-&gt;arrays; a &lt; data-&gt;arrays + data-&gt;num_arrays; ++a) {
    // code...
    for (uint32_t x = 0; x &lt; a-&gt;n; ++x) {
        // code...
        if(player_should_not_walk_anymore){
             tm_entity_api-&gt;add_component(ctx, d-&gt;entities[i], no_movement);
        }
    }
    }
}
</code></pre>
<p>As you an see the Movement Engine will now update all other entities in the game which do not have the No Movement Tag.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-use-tmbuild"><a class="header" href="#how-to-use-tmbuild">How to use tmbuild</a></h1>
<p>We described <code>tmbuild</code>'s core idea in our blog-post <a href="https://ourmachinery.com/post/one-button-source-code-builds/"><em>One-button source code builds</em></a>. <code>tmbuild</code> is our custom one-click &quot;build system.&quot; and it is quite a powerful tool. It allows you to do the most important tasks when developing with The Machinery: Building your plugin or the whole engine.</p>
<p>You can execute the tool from any terminal such as PowerShell or the VS Code internal Console window.</p>
<p>The key features are:</p>
<ul>
<li>building</li>
<li>packaging</li>
<li>cleaning the solution/folder</li>
<li>downloading all the dependencies</li>
<li>running our unit tests</li>
</ul>
<p>This walkthrough introduces you to <code>tmbuild</code> and shows you how to use and manipulate The Machinery Projects. You will learn about:</p>
<ul>
<li>How to build with it</li>
<li>How to build a specific project with it</li>
<li>How to package your project</li>
</ul>
<p>Also, you will learn some more advanced topics such as:</p>
<ul>
<li>How to build/manipulate tmbuild</li>
</ul>
<p><strong>Table of Content</strong></p>
<ul>
<li><a href="helper_tools/tmbuild.html#installing-tmbuild">Installing tmbuild</a></li>
<li><a href="helper_tools/tmbuild.html#set-up-our-environment-variables">Set up our environment variables</a></li>
<li><a href="helper_tools/tmbuild.html#let-us-build-a-plugin">Let us Build a plugin.</a></li>
<li><a href="helper_tools/tmbuild.html#let-us-build-a-specific-project">Let us build a specific project.</a></li>
<li><a href="helper_tools/tmbuild.html#how-how-to-package-a-project-via-tmbuild">How how to package a project via tmbuild?</a></li>
<li><a href="helper_tools/tmbuild.html#how-to-build-or-manipulate-tmbuild-from-source">How to build or manipulate tmbuild from source</a></li>
<li><a href="helper_tools/tmbuild.html#how-to-add-tmbuild-globally-accessible">How to add tmbuild globally accessible?</a></li>
</ul>
<h2 id="installing-tmbuild"><a class="header" href="#installing-tmbuild"><strong>Installing tmbuild</strong></a></h2>
<p>When you download and unzip <a href="https://ourmachinery.com/">The Machinery</a> either via the <a href="https://ourmachinery.com/beta.html">website</a> or via the <a href="helper_tools/tmbuild.html#">download tab</a> you can find tmbuild in the bin folder in the root. </p>
<blockquote>
<p>Alternatively, you can build it from source <code>code\utils.</code> We will talk about this later in this walkthrough. </p>
</blockquote>
<p>Before we use tmbuild, we need to ensure that we have installed either <em>build-essentials</em> under Linux, <em>XCode</em> on Mac, or <em>Visual Studio 2017 or 2019</em> (Either the Editor such as the Community Edition or the Build Tools). </p>
<p><strong>Windows Side nodes:</strong></p>
<p>On Windows, it is essential to install the C/C++ Build tools. 
If you run into the issue that tmbuild cannot find Visual Studios 2019 on Windows, it could be because you installed it on a typical path.  No problem, you can just set the environment variable <code>TM_VS2017_DIR</code> or <code>TM_VS2019_DIR</code> to the root <code>C:\Program Files (x86)\Microsoft Visual Studio\2019</code>. The tool will find the right installed version automagically.</p>
<h2 id="set-up-our-environment-variables"><a class="header" href="#set-up-our-environment-variables"><strong>Set up our environment variables</strong></a></h2>
<p>Before we can build any project, we need to set up our environment. You need to set the following environment variable: 
(If this one has not been set the tool will not be able to build)</p>
<ul>
<li><code>TM_SDK_DIR</code> - This is the path to find the folder <code>headers</code> and the folder <code>lib</code></li>
</ul>
<p>If the following variable is not set, the tool will assume that you intend to use the current working directory:</p>
<ul>
<li><code>TM_LIB_DIR</code> - The folder which determines where to download and install all dependencies (besides the build environments)</li>
</ul>
<p><strong>How to add environment variables?</strong></p>
<p><strong>Windows</strong></p>
<p>On Windows all you need to do is you need to add the folder where you installed The Machinery to your environment variables. You can do this like this:
<strong>Start &gt; Edit the system environment variables &gt; environment variables &gt; system varaibles &gt; click New... &gt;</strong> add <code>TM_SDK_DIR</code> or <code>TM_LIB_DIR</code> as the Variable Name and the needed path as the Variable Value.
Close and restart the terminal or Visual Studio / Visual Studio Code.
As an alternative, you can set an environment variable via PowerShell before you execute tmbuild, which will stay alive till the end of the session:
<code>$Env:TM_SDK_DIR=&quot;..PATH&quot;</code></p>
<p><strong>Debian/Ubuntu Linux</strong></p>
<p>You open the terminal or edit with your favorite text editor <code>~/.bashrc</code> and you add the following lines:</p>
<pre><code>#...
export TM_SDK_DIR=path/to/themachinery/
export TM_LIB_DIR=path/to/themachinery/libs
</code></pre>
<p>(e.g. via nano nano <code>~/.bashrc</code>)</p>
<h2 id="let-us-build-a-plugin"><a class="header" href="#let-us-build-a-plugin"><strong>Let us Build a plugin</strong>.</a></h2>
<p>All you need to do is: navigate to the <strong>root folder</strong> of your plugin and run in PowerShell <code>tmbuild.exe</code>. </p>
<blockquote>
<p>If you have not added tmbuild.exe to your global PATH, you need to have the right path to where tmbuild is located. <code>user@machine/home/user/tm/plugins/my_plugin/&gt; ./../../bin/tmbuild</code></p>
</blockquote>
<p>This command does all the magic. tmbuild will automatically download all the needed dependencies etc., for you <em>(Either in the location set in <code>TM_LIB_DIR</code> or in the current working directory)</em>. 
You may have noticed tmbuild will always run unit tests at the end of your build process.</p>
<blockquote>
<p><strong>Note:</strong> tmbuild will only build something when there is a premake5.lua and a libs.json in the current <em>working directory</em>.</p>
</blockquote>
<h2 id="let-us-build-a-specific-project"><a class="header" href="#let-us-build-a-specific-project"><strong>Let us build a specific project</strong>.</a></h2>
<p>Imagine you have been busy and written a bunch of plugins, and they are all connected and managed via the same Lua file (premake5 file). 
Now you do not want to check everything all the time. No problem, you can follow these steps:
If you run <code>tmbuild --help/-h</code>, you will see many options. One of those options is <code>--project</code>. This one allows you to build a specific project.</p>
<pre><code>tmbuild.exe --project my-project-name
</code></pre>
<p>The tool will automatically find the right project and build it. 
On Windows, you can also provide the relative/absolute path to the project with extension: ``</p>
<pre><code>tmbuild --project /path/to/project.vcxproj
</code></pre>
<blockquote>
<p><strong>Note:</strong>
If a project cannot be found it will build all projects.</p>
</blockquote>
<h2 id="how-how-to-package-a-project-via-tmbuild"><a class="header" href="#how-how-to-package-a-project-via-tmbuild">How how to package a project via tmbuild?</a></h2>
<p>To package a project via tmbuild, all you need to do is use the <code>-p [package name]</code> or <code>--package [package name]</code> command. A package file needs to be of type <code>.json</code> and follow our package scheme, which you can find <a href="helper_tools/tmbuild.html#">here</a>.</p>
<h2 id="how-to-build-or-manipulate-tmbuild-from-source"><a class="header" href="#how-to-build-or-manipulate-tmbuild-from-source">How to build or manipulate tmbuild from source</a></h2>
<p>You can find the source code of tmbuild in folder <code>code\utils\tmbuild</code>. In the folder <code>code\utils</code>, you can also find the source code of all the other uses the engine uses.</p>
<p>You can build tmbuild via tmbuild. All you need to do is navigate the <code>code\utils</code> folder and run <code>tmbuild --project tmbuild</code>. </p>
<p>If you do not have access to a build version of tmbuild but to the whole source, you have to follow the following steps:</p>
<p><strong>Windows 10</strong></p>
<p>Make sure you have Visual Studio 19 and the Build Tools installed. Besides, check if you can find <code>msbuild</code> in the terminal. You can install <code>msbuild / vs studio</code> via PowerShell: <a href="https://github.com/Microsoft/vssetup.powershell">https://github.com/Microsoft/vssetup.powershell</a></p>
<p>To check just run:</p>
<pre><code class="language-bash">msbuild
</code></pre>
<p>if you cannot find it just add it to your environment path variables: with e.g.
<code>C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\MSBuild\Current\Bin\</code></p>
<p><strong>To build from source:</strong></p>
<p>Open a PowerShell instance in The Machinery folder and run the following commands:</p>
<pre><code class="language-powershell"># this part can be skiped if you have already downloaded
# all the dependencies and created a highlevel folder to your lib dependencies:
mkdir lib
cd lib
 wget https://ourmachinery.com/lib/bearssl-0.6-r1-win64.zip -OutFile bearssl-0.6-r1-win64.zip
 wget https://ourmachinery.com/lib/premake-5.0.0-alpha14-windows.zip -OutFile premake-5.0.0-alpha14-windows.zip
Expand-Archive -LiteralPath './bearssl-0.6-r1-win64.zip' -DestinationPath &quot;.&quot;
Expand-Archive -LiteralPath './premake-5.0.0-alpha14-windows.zip' -DestinationPath &quot;.&quot;
cd ..
# continue here if the dependencies are already downloaded
# set TM_LIB_DIR if you have not set it already
$env:TM_LIB_DIR=&quot;/path/to/themachinery/lib&quot;
$env:TM_SDK_DIR=&quot;/path/to/themachinery/&quot;
# run premake
./../../lib/premake-5.0.0-alpha14-windows/premake5 [vs2019|vs2017]
# navigate to the highlevel folder of the code (here you find the libs.json and the
# premake5.lua
cd code/utils
msbuild.exe &quot;build/tmbuild/tmbuild.vcxproj&quot; /p:Configuration=&quot;Debug Win64&quot; /p:Platform=x64
</code></pre>
<p><em>Make sure that you either choose vs2019 or vs2017 not</em> [vs2019|vs2017]</p>
<p><strong>On Debian/Ubuntu</strong></p>
<p>Open a terminal instance and run the following commands:</p>
<pre><code class="language-bash"># If you do not have the huild essentials installed make sure you do:
sudo apt install build-essential clang zip -y
# otherweise continue here:
cd your-folder-of-tm
# this part can be skiped if you have already downloaded
# all the dependencies and created a highlevel folder to your lib dependencies:
mkdir lib
cd ./lib
wget https://ourmachinery.com/lib/bearssl-0.6-r1-linux.zip
wget https://ourmachinery.com/lib/premake-5.0.0-alpha15-linux.zip
unzuip bearssl-0.6-r1-linux.zip .
unzip premake-5.0.0-alpha15-linux.zip .
chmod +x ./premake-5.0.0-alpha15-linux/premake5
cd ..
# continue here if the dependencies are already downloaded
# set TM_LIB_DIR if you have not set it already
export TM_LIB_DIR=/path/to/themachinery/lib
export TM_SDK_DIR=/path/to/themachinery/
# run premake
./../../lib/premake-5.0.0-alpha15-linux/premake5 gmake
# navigate to the highlevel folder of the code (here you find the libs.json and the
# premake5.lua
cd code/utils
# run make:
make tmbuild
</code></pre>
<h2 id="how-to-add-tmbuild-globally-accessible"><a class="header" href="#how-to-add-tmbuild-globally-accessible">How to add tmbuild globally accessible?</a></h2>
<p><strong>Windows</strong>
On Windows, all you need to do is you need to add the folder/bin to your environment variables. This can be done like this:
<strong>Start &gt; Edit the system environment variables &gt; environment variables &gt; system variables &gt; search in the list for path &gt; click Edit &gt; click new &gt;</strong> add the absolute path to <code>themachinery/bin</code> in there
re-login or reboot.</p>
<p><strong>Debian/Ubuntu Linux</strong>
You open the terminal or edit with your favorite text editor <code>~/.bashrc</code>, and you add the following lines:
<code>export PATH=path/to/themachinery/bin:$PATH</code>
(e.g. via nano nano <code>~/.bashrc</code>)</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="collaboration"><a class="header" href="#collaboration">Collaboration</a></h2>
<p>The editor has built-in support for real-time collaboration, allowing multiple people to work
together in the same project. All user actions — importing assets, creating and editing entities,
etc, are supported in the collaborative workflow.</p>
<p>In our collaboration model, one of the users always acts as a host. The host
invites others to join her in editing <em>her</em> project. All the changes made by the
participants in the session end up in the host’s project and it’s the host’s
responsibility to save the project, check in the changes into version control, or
do whatever else is needed to make the changes permanent.</p>
<p>To host a collaboration setting, open the collaboration tab from <strong>Tab &gt;
Collaboration</strong> and choose one of the <strong>Host</strong> options.</p>
<ul>
<li>
<p><strong>Host LAN Server</strong>: Host a server on your LAN. The system will choose a free port on your machine
for hosting. Other users on the same LAN can join your session by choosing <em>Join LAN Server</em> and
selecting your machine.</p>
</li>
<li>
<p><strong>Host Internet Server</strong>: Host a server that can be accessed over the internet on a specified port.
If you check the &quot;Use UPnP&quot; checkbox the system will attempt to use UPnP to open the port in your
router, so that external users can access your server. To connect, an external user would choose
<em>Join Internet Server</em> and specify your external IP address.</p>
<p>Note that there is no guarantee that UPnP works with your particular router. If Internet hosting
is not working for you, you may have to manually forward the hosting port in your router.</p>
</li>
<li>
<p><strong>Host Discord Server</strong>: Host a server through Discord. You must have the Discord app running on
your machine to use this option. You can invite friends to your discord editing session by selecting
them in your active friends list and sending them invites.</p>
</li>
</ul>
<p><img src="https://www.dropbox.com/s/md2plg22dfa652u/collaboration-tab.png?dl=1" alt="Collaboration tab when hosting." /></p>
<p>If you just want to try out collaboration on your own, you can run the client and the host on the
same machine (just start two instances of the_machinery.exe) and connect using the LAN option.</p>
<p><img src="https://www.dropbox.com/s/34a8328lt19rqpr/collaboration-session.png?dl=1" alt="Collaboration session running on a single machine." /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="qa-pipeline"><a class="header" href="#qa-pipeline">QA Pipeline</a></h1>
<p>The Machinery comes with some built-in tools to support you in building games.</p>
<ul>
<li><a href="https://ourmachinery.com/apidoc/foundation/unit_test.h.html#unit_test.h">Unit Test Framework</a></li>
<li><a href="https://ourmachinery.com/apidoc/foundation/integration_test.h.html#integration_test.h">Integration Test Framework</a></li>
<li><a href="https://ourmachinery.com/apidoc/foundation/profiler.h.html#profiler.h">Profiler and profiling framework</a></li>
<li><a href="https://ourmachinery.com/apidoc/foundation/memory_tracker.h.html#memory_tracker.h">Memory leak Detection</a></li>
</ul>
<p><strong>Table of Content</strong></p>
<ul>
<li><a href="qa_pipeline/index.html#profiler-tab">Profiler Tab</a></li>
<li><a href="qa_pipeline/index.html#memory-usage-tab">Memory Usage Tab</a></li>
<li><a href="qa_pipeline/index.html#statistic-tab">Statistic Tab</a></li>
</ul>
<h2 id="profiler-tab"><a class="header" href="#profiler-tab">Profiler Tab</a></h2>
<p>The profiler tab will display all scopes that have been added to the profiler API. With the tab, you can record for a few moments all scopes and then afterward analyze them.</p>
<p><img src="https://paper-attachments.dropbox.com/s_5086E710AFB88B222C81207791AF7092731DB9D2900AFABEA044A0AC0B80DFFB_1625602954215_image.png" alt="" /></p>
<p>You can use the profiler API defined in the <a href="https://ourmachinery.com/apidoc/foundation/profiler.h.html#profiler.h">foundation/profiler</a>.h. in your own projects.
After you have loaded the [<a href="https://ourmachinery.com/apidoc/foundation/profiler.h.html#structtm_profiler_api">tm_profiler_api</a>](https://ourmachinery.com/apidoc/foundation/profiler.h.html#structtm_profiler_api) in your plugin load function.</p>
<table><thead><tr><th>Profiler Macros</th></tr></thead><tbody>
<tr><td><strong><a href="https://ourmachinery.com/apidoc/foundation/profiler.h.html#tm_profiler_begin_func_scope()">TM_PROFILER_BEGIN_FUNC_SCOPE()</a> / <a href="https://ourmachinery.com/apidoc/foundation/profiler.h.html#tm_profiler_end_func_scope()">TM_PROFILER_END_FUNC_SCOPE()</a></strong></td></tr>
<tr><td>Starts a profiling scope for the current function. The scope in the profiler will have this name.</td></tr>
<tr><td><strong><a href="https://ourmachinery.com/apidoc/foundation/profiler.h.html#tm_profiler_begin_local_scope()">TM_PROFILER_BEGIN_LOCAL_SCOPE(tag)</a> / <a href="https://ourmachinery.com/apidoc/foundation/profiler.h.html#tm_profiler_end_local_scope()">TM_PROFILER_END_LOCAL_SCOPE(tag)</a></strong></td></tr>
<tr><td>The call to this macro starts a local profiler scope. The scope is tagged with the naked word tag (it gets stringified by the macro). Use a local profiler scope if you need to profile parts of a function.</td></tr>
</tbody></table>
<p><em>Example:</em></p>
<pre><code class="language-c">void my_function(https://ourmachinery.github.io/themachinery-books/the_machinery_book/*some arguments*/){
   TM_PROFILER_BEGIN_FUNC_SCOPE()
   // .. some code
   TM_PROFILER_END_FUNC_SCOPE()
}
</code></pre>
<h2 id="memory-usage-tab"><a class="header" href="#memory-usage-tab">Memory Usage Tab</a></h2>
<p>The memory tab will display all memory consumed via any allocator. Temporary allocators will be listed as well. Besides the memory from the CPU allocators, you can also inspect device memory used and the memory consumed by your assets.</p>
<p><img src="https://paper-attachments.dropbox.com/s_5086E710AFB88B222C81207791AF7092731DB9D2900AFABEA044A0AC0B80DFFB_1625603084539_image.png" alt="" /></p>
<h2 id="statistic-tab"><a class="header" href="#statistic-tab">Statistic Tab</a></h2>
<p>Allows you to visualize different statistics from different sources. </p>
<p><img src="https://paper-attachments.dropbox.com/s_5086E710AFB88B222C81207791AF7092731DB9D2900AFABEA044A0AC0B80DFFB_1625603204224_image.png" alt="" /></p>
<p>The Statistic tab consists of a Property View in which you can define your desired method of display and source. You can choose between Table, Line, or no visualization method. As sources, the engine will offer you any of the profiler scopes.</p>
<p><img src="https://paper-attachments.dropbox.com/s_5086E710AFB88B222C81207791AF7092731DB9D2900AFABEA044A0AC0B80DFFB_1625604230068_image.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="logging"><a class="header" href="#logging">Logging</a></h1>
<p>The Machinery comes with a build in Logger system. The Logger System lives in the <code>foundation/log.h</code> and contains the <a href="https://ourmachinery.com/apidoc/foundation/log.h.html#structtm_logger_api">tm_logger_api</a>. This API provides a few connivance macros. We can use them to log our code from anywhere. Besides this it is super easy to create your own logger and add it to the logger API.</p>
<h2 id="logging-cheat-sheet"><a class="header" href="#logging-cheat-sheet">Logging cheat sheet</a></h2>
<p>You can log custom types. This is enabled via the <a href="https://ourmachinery.com/apidoc/foundation/sprintf.h.html#structtm_sprintf_api">tm_sprintf_api</a>. You can log all primitive types like you are used to from C but as well as the engines API types. Just keep in mind the following syntax: <code>%p{&lt;MY_TYPE&gt;}</code> and the <strong>fact</strong> that you <strong>need</strong> to provide a pointer to the correct type:</p>
<table><thead><tr><th>type</th><th>call</th></tr></thead><tbody>
<tr><td><code>bool</code></td><td><code>TM_LOG(&quot;%p{bool}&quot;,&amp;my_value);</code></td></tr>
<tr><td><code>tm_vec2_t</code></td><td><code>TM_LOG(&quot;%p{tm_vec2_t}&quot;,&amp;my_value);</code></td></tr>
<tr><td><code>tm_vec3_t</code></td><td><code>TM_LOG(&quot;%p{tm_vec2_t}&quot;,&amp;my_value);</code></td></tr>
<tr><td><code>tm_vec4_t</code></td><td><code>TM_LOG(&quot;%p{tm_vec4_t}&quot;,&amp;my_value);</code></td></tr>
<tr><td><code>tm_mat44_t</code></td><td><code>TM_LOG(&quot;%p{tm_mat44_t}&quot;,&amp;my_value);</code></td></tr>
<tr><td><a href="https://ourmachinery.com/apidoc/foundation/api_types.h.html#structtm_transform_t">tm_transform_t</a></td><td><code>TM_LOG(&quot;%p{tm_transform_t}&quot;,&amp;my_value);</code></td></tr>
<tr><td><a href="https://ourmachinery.com/apidoc/foundation/api_types.h.html#structtm_rect_t">tm_rect_t</a></td><td><code>TM_LOG(&quot;%p{tm_rect_t}&quot;,&amp;my_value);</code></td></tr>
<tr><td><a href="https://ourmachinery.com/apidoc/foundation/api_types.h.html#structtm_str_t">tm_str_t</a></td><td><code>TM_LOG(&quot;%p{tm_str_t}&quot;,&amp;my_value);</code></td></tr>
<tr><td><a href="https://ourmachinery.com/apidoc/foundation/api_types.h.html#structtm_uuid_t">tm_uuid_t</a></td><td><code>TM_LOG(&quot;%p{tm_uuid_t}&quot;,&amp;my_value);</code></td></tr>
<tr><td><a href="https://ourmachinery.com/apidoc/foundation/api_types.h.html#structtm_color_srgb_t">tm_color_srgb_t</a></td><td><code>TM_LOG(&quot;%p{tm_color_srgb_t}&quot;,&amp;my_value);</code></td></tr>
<tr><td><a href="https://ourmachinery.com/apidoc/foundation/api_types.h.html#structtm_tt_type_t">tm_tt_type_t</a></td><td><code>TM_LOG(&quot;%p{tm_tt_type_t}&quot;,&amp;my_value);</code></td></tr>
<tr><td><a href="https://ourmachinery.com/apidoc/foundation/api_types.h.html#structtm_tt_id_t">tm_tt_id_t</a></td><td><code>TM_LOG(&quot;%p{tm_tt_id_t}&quot;,&amp;my_value);</code></td></tr>
<tr><td><a href="https://ourmachinery.com/apidoc/foundation/api_types.h.html#structtm_tt_undo_scope_t">tm_tt_undo_scope_t</a></td><td><code>TM_LOG(&quot;%p{tm_tt_undo_scope_t}&quot;,&amp;my_value);</code></td></tr>
<tr><td><a href="https://ourmachinery.com/apidoc/foundation/api_types.h.html#structtm_strhash_t">tm_strhash_t</a></td><td><code>TM_LOG(&quot;%p{tm_strhash_t}&quot;,&amp;my_value);</code></td></tr>
</tbody></table>
<p>You can register a support for your own custom type via the <code>tm_sprintf_api.add_printer()</code>.</p>
<h3 id="more-a-hrefhttpsourmachinerycomapidocfoundationsprintfhhtmlstructtm_sprintf_apitm_sprintf_apia-formatting-cheats"><a class="header" href="#more-a-hrefhttpsourmachinerycomapidocfoundationsprintfhhtmlstructtm_sprintf_apitm_sprintf_apia-formatting-cheats">More <a href="https://ourmachinery.com/apidoc/foundation/sprintf.h.html#structtm_sprintf_api">tm_sprintf_api</a> formatting cheats</a></h3>
<table><thead><tr><th>Fmt</th><th>Value</th><th>Result</th></tr></thead><tbody>
<tr><td><code>%I64d</code></td><td><code>(uint64_t)100</code></td><td><code>100</code></td></tr>
<tr><td><code>%'d</code></td><td><code>12345</code></td><td><code>12,345</code></td></tr>
<tr><td><code>%$d</code></td><td><code>12345</code></td><td><code>12.3 k</code></td></tr>
<tr><td><code>%$d</code></td><td><code>1000</code></td><td><code>1.0 k</code></td></tr>
<tr><td><code>%$.2d</code></td><td><code>2536000</code></td><td><code>2.53 M</code></td></tr>
<tr><td><code>%$$d</code></td><td><code>2536000</code></td><td><code>2.42 Mi</code></td></tr>
<tr><td><code>%$$$d</code></td><td><code>2536000</code></td><td><code>2.42 M</code></td></tr>
<tr><td><code>%_$d</code></td><td><code>2536000</code></td><td><code>2.53M</code></td></tr>
<tr><td><code>%b</code></td><td><code>36</code></td><td><code>100100</code></td></tr>
<tr><td><code>%p{bool}</code></td><td><code>&amp;(bool){true}</code></td><td><code>true</code></td></tr>
<tr><td><code>%p{tm_vec3_t}</code></td><td><code>&amp;(tm_vec3_t){ 1, 2, 3 }</code></td><td><code>{ 1, 2, 3 }</code></td></tr>
<tr><td><code>%p{tm_vec3_t}</code></td><td><code>0</code></td><td><code>(null)</code></td></tr>
<tr><td><code>%p{unknown_type}</code></td><td><code>&amp;(tm_vec3_t){ 1, 2, 3 }</code></td><td><code>%p{unknown_type}</code></td></tr>
<tr><td><code>%p{unknown_type:args}</code></td><td><code>&amp;(tm_vec3_t){ 1, 2, 3 }</code></td><td><code>%p{unknown_type:args}</code></td></tr>
<tr><td><code>%p{tm_vec3_t</code></td><td><code>&amp;(tm_vec3_t){ 1, 2, 3 }</code></td><td><code>(error)</code></td></tr>
<tr><td><code>%p{tm_rect_t}</code></td><td><code>&amp;(tm_rect_t){ 10, 20, 100, 200 })</code></td><td><code>{ 10, 20, 100, 200 }</code></td></tr>
<tr><td><code>%p{tm_color_srgb_t}</code></td><td><code>&amp;TM_RGB(0xff7f00)</code></td><td><code>{ .r = 255, .g = 127, .b = 0, .a = 255 }</code></td></tr>
</tbody></table>
<h2 id="write-a-custom-logger"><a class="header" href="#write-a-custom-logger">Write a custom logger</a></h2>
<p>If you desire to add your own logger sink to the eco system there are a few steps you need to take:</p>
<ol>
<li>You need to include the <code>foundation/log.h</code> header</li>
<li>You need to define a <a href="https://ourmachinery.com/apidoc/foundation/log.h.html#structtm_logger_i">tm_logger_i</a> in your file</li>
<li>You need add a <code>log</code> function to this interface
<ol>
<li>If you need some local data (such as a allocator)  it might be good to define a <code>.inst</code> as well.</li>
</ol>
</li>
<li>After all of this you can call the <code>tm_logger_api.add_logger()</code>  function to register your logger</li>
</ol>
<p><em>Example:</em></p>
<pre><code>#include &lt;foundation/log.h&gt;
// some more code

static void my_log_function(struct tm_logger_o *inst, enum tm_log_type log_type, const char *msg)
{
// do what you feel like doing!
}

tm_logger_i *logger = &amp;(tm_logger_i){
    .log = my_log_function,
};
//.. more code
// This functions gets called at some point and this is the point I would like to register my logger
static void my_custom_api_function(void){
    tm_logger_api-&gt;add_logger(logger);
}
</code></pre>
<blockquote>
<p><strong>Note:</strong> This can be a use case for plugin <a href="https://ourmachinery.com//apidoc/foundation/plugin_callbacks.h.html#plugin_callbacks.h">callbacks</a>. More about this see <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book//extending_the_machinery/write-a-plugin.html#plugin-callbacks-init-sutdown-tick">Write a plugin</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>This walkthrough introduces you to unit-tests.exe and shows you how to use it with The Machinery. You will learn about:</p>
<ul>
<li>How to run tests</li>
<li>How to constantly monitor your changes</li>
<li>How to write tests in your plugin</li>
</ul>
<p>This walkthrough expects basic knowledge on how to create a plugin and how a plugin is structured. If you are missing this knowledge, then you can find out more <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/extending_the_machinery/the_plugin_system.html">here</a>.</p>
<blockquote>
<p><strong>Note:</strong> At this point, the testing framework is in the beginning stage. We are extending its capabilities overtime to meet the needs of modern game development QA pipelines.</p>
</blockquote>
<h2 id="about-unit-tests"><a class="header" href="#about-unit-tests"><strong>About unit-tests</strong></a></h2>
<p>You can find the executable alongside <code>tmbuild</code> or the machinery executable in the <code>bin/ folder.</code> If you wanted to make the unit-tests executable globally accessible, you need to add it to your path environment variable. As you may have noticed, ensuring the quality of your build, <code>tmbuild</code> will run all unit tests of all plugins at the end of its build process. When you add a unit test to your plugin, it is guaranteed that its unit tests run every time you build. This is, of course, only guaranteed if the plugin system can find the plugin and its test.</p>
<blockquote>
<p><strong>Note:</strong> unit-tests will assume that the plugins live in a folder relative to the executable in the standardized folder plugins. If you need to load a plugin that is not in this folder, you need to provide a valid path via <code>-p/--plugin</code> so that unit-tests can find and run your tests.</p>
</blockquote>
<h2 id="how-to-run-tests"><a class="header" href="#how-to-run-tests"><strong>How to run tests</strong></a></h2>
<p>To run all unit tests, execute unit-test, and it will run all tests besides the slow execution path tests. To run all unit tests, including the <em>&quot;slow&quot;</em> ones, you run <code>unit-tests.exe -s/--slow-paths</code></p>
<blockquote>
<p><strong>Note:</strong> You may have noticed that if you run <code>tmbuild</code> regularly, you are lucky and win in the &quot;lottery&quot; from time to time. This means <code>tmbuild</code> will run all unit tests also the slow ones via <code>unit-tests</code>.</p>
</blockquote>
<h2 id="how-to-constantly-monitor-your-changes"><a class="header" href="#how-to-constantly-monitor-your-changes"><strong>How to constantly monitor your changes</strong></a></h2>
<p>Like the editor, <code>unit-tests</code> supports <a href="https://ourmachinery.com/post/dll-hot-reloading-in-theory-and-practice/">hot reloading</a>. In a nutshell, whenever plugins are rebuilt <code>unit-tests</code> can detect this and rerun the tests. To run in hot-reload mode start<code>unit-tests</code> with the <code>-r/--hot-reload</code> argument.</p>
<p><em>When could this be useful?</em>
It can be helpful on CI Server where build and test servers are different. The build server's final build step uploads the generated <code>dlls</code> to the test server if everything works fine. The test server is monitoring the filesystem, and whenever the dlls change, <code>unit-tests</code> would rerun all tests, also the slow ones, to ensure that all works. It could save time on the build server so the build times are faster and the developer knows quicker if the build fails. Also, the build server does not need a graphics card to run eventual graphic pipeline-related tests. The test server, on the other hand, could run such tests.</p>
<h2 id="how-to-write-your-tests"><a class="header" href="#how-to-write-your-tests"><strong>How to write your tests</strong></a></h2>
<p>All that is needed is to write tests is to register them via the <a href="https://ourmachinery.com/apidoc/foundation/unit_test.h.html#tm_unit_test_interface_name">TM_UNIT_TEST_INTERFACE_NAME</a>. You can find the interface in the <a href="https://ourmachinery.com/apidoc/foundation/unit_test.h.html">unit_tests.h</a>. <a href="https://ourmachinery.com/apidoc/foundation/unit_test.h.html#tm_unit_test_interface_name">TM_UNIT_TEST_INTERFACE_NAME</a> expects a pointer of the type <a href="https://ourmachinery.com/apidoc/foundation/unit_test.h.html#structtm_unit_test_i">tm_unit_test_i</a>. This interface expects a name and a function pointer to the test entry function.</p>
<pre><code class="language-c">// Interface for running unit tests. To find all unit test, query the API registry for
// [TM_UNIT_TEST_INTERFACE_NAME](https://ourmachinery.com/apidoc/foundation/unit_test.h.html#tm_unit_test_interface_name) implementations.
typedef struct tm_unit_test_i
{
    // Name of this unit test.
    const char *name;

    // Runs unit tests, using the specified test runner. The supplied allocator can be used for
    // any allocations that the unit test needs to make.
    void (*test)(tm_unit_test_runner_i *tr, struct tm_allocator_i *a);
} tm_unit_test_i;
</code></pre>
<p>At this point, we have not tackled the following possible questions:</p>
<ul>
<li>Where and how do we register the interface?</li>
<li>How could this interface look like?</li>
<li>How does a test itself look like?</li>
</ul>
<p><strong>Let us walk through those questions:</strong></p>
<p><em>Where and how do we register the interface?</em>
We need to register our tests in the same function as everything else that needs to be executed when a plugin loads: in our <code>tm_load_plugin</code>. It may look like this:</p>
<pre><code class="language-c">#include &lt;foundation/unit_test.h&gt;
//...
// my amazing plugin
TM_DLL_EXPORT void tm_load_plugin(struct tm_api_registry_api *reg, bool load)
{
    tm_global_api_registry = reg;
    //...
    tm_add_or_remove_implementation(reg, load, TM_UNIT_TEST_INTERFACE_NAME, my_unit_tests);
}
</code></pre>
<p>Here we register our test interface to the <a href="https://ourmachinery.com/apidoc/foundation/unit_test.h.html#tm_unit_test_interface_name">TM_UNIT_TEST_INTERFACE_NAME</a>.</p>
<p><em>How could this interface look like?</em>
After we have done this, all we need to do is declarer our <code>my_unit_tests</code>. It is as easy as it gets:</p>
<pre><code class="language-c">#include &lt;foundation/unit_test.h&gt;
//...
tm_unit_test_i *entity_unit_test = &amp;(tm_unit_test_i){
    .name = &quot;my_unit_tests&quot;,
    .test = test_function,
};
</code></pre>
<p><em>How does a test itself look like?</em>
All that's left is to write the test. Let us write this test. In its core all we need to do is write a function of the signature: <code>(tm_unit_test_runner_i *tr, struct tm_allocator_i *a)</code>. In its body, we can define our tests.</p>
<pre><code class="language-c">static void test_function(tm_unit_test_runner_i *test_runner, tm_allocator_i *allocator)
{
    //.. code
}
</code></pre>
<p>The test runner variable test_runner is needed to communicate back to the test suite about failures etc. The following <a href="https://ourmachinery.com/apidoc/foundation/unit_test.h.html#tm_unit_test()">macros</a> will help you write tests. They are the heart of the actual tests.</p>
<table><thead><tr><th><strong>Macro</strong></th><th><strong>Arguments</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>TM_UNIT_TEST</td><td>(test_runner, assertion)</td><td>Unit test macro. Tests the <code>assertion</code> using the test runner <code>test_runner</code>.</td></tr>
<tr><td>TM_UNIT_TESTF</td><td>(test_runner, assertion, format, ...)</td><td>As <code>TM_UNIT_TEST()</code> but records a formatted string in case of error.</td></tr>
<tr><td>TM_EXPECT_ERROR</td><td>(test_runner, error)</td><td>Expect the error message <code>error</code>. If the error message doesn't appear before the next call to <code>record()</code>, or if another error message appears before it, this will be considered a unit test failure.<br><br>Note that for <a href="https://ourmachinery.com/apidoc/foundation/unit_test.h.html#tm_expect_error()">TM_EXPECT_ERROR</a> to work properly, you must redirect error messages to go through the test runner, so that it can check that the error message matches what's expected.</td></tr>
</tbody></table>
<p>It's time for some tests. Let us write some tests for <a href="https://ourmachinery.com/apidoc/foundation/carray.inl.html#carray.inl">carrays</a></p>
<pre><code class="language-c">#include &lt;foundation/unit_test.h&gt;
#include &lt;foundation/carray.inl&gt;
//.. other code
static void test_function(tm_unit_test_runner_i *test_runner, tm_allocator_i *allocator)
{
    /*carray*/ int32_t *a = 0;
    TM_UNIT_TEST(test_runner, tm_carray_size(a) == 0);
    TM_UNIT_TEST(test_runner, tm_carray_capacity(a) == 0);
    TM_UNIT_TEST(test_runner, a == 0);
    tm_carray_push(a, 1, &amp;allocator);

    TM_UNIT_TEST(test_runner, tm_carray_size(a) == 1);
    TM_UNIT_TEST(test_runner, tm_carray_capacity(a) == 16);
    TM_UNIT_TEST(test_runner, a);
    TM_UNIT_TEST(test_runner, a[0] == 1);

    tm_carray_header(a)-&gt;size--;

    TM_UNIT_TEST(test_runner, tm_carray_size(a) == 0);
    TM_UNIT_TEST(test_runner, tm_carray_capacity(a) == 16);

    tm_carray_grow(a, 20, &amp;allocator);
    tm_carray_header(a)-&gt;size = 20;

    TM_UNIT_TEST(test_runner, tm_carray_size(a) == 20);
    TM_UNIT_TEST(test_runner, tm_carray_capacity(a) == 32);
}
</code></pre>
<p>All that's left is to build via <code>tmbuild</code> our plugin and watch the console output if our tests fail. This is how you integrate your tests into the whole build pipeline. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-write-integration-tests"><a class="header" href="#how-to-write-integration-tests">How to write integration tests</a></h1>
<p>This walkthrough shows you how to write integration tests with our integration test framework. You will learn about:</p>
<ul>
<li>How an integration test differs from a unit test.</li>
<li>Where to find the integration test framework and how to write a test</li>
<li>How to run an integration test.</li>
</ul>
<h2 id="about-integration-tests"><a class="header" href="#about-integration-tests"><strong>About integration tests</strong></a></h2>
<p>Integration testing is the phase in testing software in which individual software modules are combined and tested as a group. Integration testing is conducted to evaluate a system's compliance or its interaction as a whole within specified functional requirements. 
Its generally used after unit testing to ensure that the composition of the software works. It is a potent tool to validate certain bugs that are hard to reproduce only after using software extensively. You can simulate this with integration tests. Besides, it is a very powerful tool validating that a bug fix was successful.</p>
<p>By their very nature, integration tests are slower and more fragile than unit tests, but they can also find issues that are hard to detect with regular unit tests. Each integration test runs in a specific &quot;context&quot;, identified by a string hash. The context specifies the &quot;scaffolding&quot; is set up before the unit test runs.</p>
<h2 id="how-to-write-integration-tests-1"><a class="header" href="#how-to-write-integration-tests-1"><strong>How to write integration tests</strong></a></h2>
<p><strong>Where to find the integration test framework?</strong></p>
<p>The integration test framework can be found in the <a href="https://ourmachinery.com/apidoc/foundation/integration_test.h.html">integration_test.h</a> ,and is part of the foundation library. We need to include this header file, and then we can start writing our tests.</p>
<pre><code>#include &lt;foundation/integration_test.h&gt;
</code></pre>
<p>To write a test you need to register it via the <a href="https://ourmachinery.com/apidoc/foundation/integration_test.h.html#tm_integration_test_interface_name">TM_INTEGRATION_TEST_INTERFACE_NAME</a>. It expects a pointer of the type <a href="https://ourmachinery.com/apidoc/foundation/integration_test.h.html#structtm_integration_test_i">tm_integration_test_i</a>. This interface expects a name and a function pointer to the test function (tick). Also, it expects a context. The context is a string hash. For example: <a href="https://ourmachinery.com/apidoc/foundation/integration_test.h.html#tm_integration_test_context__the_machinery_editor">TM_INTEGRATION_TEST_CONTEXT__THE_MACHINERY_EDITOR</a>.</p>
<pre><code class="language-c">// Interface for integration tests.
typedef struct tm_integration_test_i
{
    // Name of the test.
    const char *name;
    // Context that this test will run in. Tests will only be run in contexts that match their
    // `context` setting.
    tm_strhash_t context;
    // Ticks the test. The `tick()` function will be called repeatedly until all it's `wait()` calls
    // have completed.
    void (*tick)(tm_integration_test_runner_i *);
} tm_integration_test_i;
</code></pre>
<p>At this point, we have not tackled the following possible questions:</p>
<ul>
<li>Where and how do we register the interface?</li>
<li>How could this interface look like?</li>
<li>How does a test itself look like?</li>
</ul>
<p><strong>Let us walk those questions through:</strong></p>
<p><em>Where and how do we register the interface?</em></p>
<p>We need to register our tests in the same function as everything else that needs to be executed when a plugin loads: in our <code>tm_load_plugin</code>.</p>
<pre><code class="language-c">// my amazing plugin
TM_DLL_EXPORT void tm_load_plugin(struct tm_api_registry_api *reg, bool load)
{
    tm_global_api_registry = reg;
    //...
    tm_add_or_remove_implementation(reg, load, TM_INTEGRATION_TEST_INTERFACE_NAME, my_integration_tests);
}
</code></pre>
<p>Here we register our test interface to the <a href="https://ourmachinery.com/apidoc/foundation/integration_test.h.html#tm_integration_test_interface_name">TM_INTEGRATION_TEST_INTERFACE_NAME</a>.</p>
<p><em>How could this interface look like?</em></p>
<p>After we have done this, we need to declare our <code>my_integration_tests.</code> </p>
<pre><code class="language-c">tm_integration_test_i my_integration_tests = {
    .name = &quot;stress-test&quot;,
    //Context that specifies a running The Machinery editor application
    .context = TM_INTEGRATION_TEST_CONTEXT__THE_MACHINERY_EDITOR,
    .tick = my_test_tick,
};
</code></pre>
<p>The name field is important because, later on, we need to use this name when we want to run the test. The context makes sure that it runs and boots up the Editor. <a href="https://ourmachinery.com/apidoc/foundation/integration_test.h.html#tm_integration_test_context__the_machinery_editor">TM_INTEGRATION_TEST_CONTEXT__THE_MACHINERY_EDITOR</a> is defined in <code>#include &lt;foundation/integration_test.h&gt;</code>. The function <code>my_test_tick</code> gets called and the magic can happen.</p>
<p><em>How does a test itself look like?</em></p>
<p>Let us write this test. We need to write a function of the signature: <code>(tm_integration_test_runner_i *)</code>.  In its body, we can define our tests.</p>
<pre><code class="language-c">static void my_test_tick(tm_integration_test_runner_i *test_runner)
{
  //.. code
}
</code></pre>
<p>The test runner variable <code>test_runner</code> is needed to communicate back to the test suite about failures etc.  The following <a href="https://ourmachinery.com/apidoc/foundation/integration_test.h.html">macros</a> will help you write tests. They are the heart of the tests.</p>
<table><thead><tr><th><strong>Macro</strong></th><th><strong>Arguments</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>TM_WAIT</td><td>test_runner, second</td><td>Waits for the specified time inside an integration test.</td></tr>
<tr><td>TM_WAIT_LOOP</td><td>test_runner, second, i</td><td>Since <code>TM_WAIT()</code> uses the <code>__LINE__</code> macro to uniquely identify wait points, it doesn't work when called in a loop. In this case you can use <code>TM_WAIT_LOOP()</code> instead. It takes an iteration parameter <code>i</code> that uniquely identifies this iteration of the loop (typically it would just be the iteration index). This together with <code>__LINE__</code> gives a unique identifier for the wait point.</td></tr>
</tbody></table>
<blockquote>
<p><strong><a href="https://ourmachinery.com/apidoc/foundation/integration_test.h.html#tm_wait_loop()">TM_WAIT_LOOP()</a> WARNING</strong></p>
<p>If you have multiple nested loops, be aware that using just the inner loop index j is not enough to uniquely identify the wait point since it is repeated for each outer loop iteration. Instead, you want to combine the outer and inner indexes.</p>
</blockquote>
<p>Lets write some example:</p>
<pre><code class="language-c">#include &lt;foundation/integration_test.h&gt;
static void my_test_tick(tm_integration_test_runner_i *test_runner)
{
    const float step_time = 0.5f;
    if (TM_WAIT(tr, step_time))
    open(tr, &quot;C:\\work\\sample-projects\\modular-dungeon-kit\\project.the_machinery_dir&quot;);
    if (TM_WAIT(tr, step_time))
    save_to_asset_database(tr, &quot;C:\\work\\sample-projects\\modular-dungeon-kit\\modular-dungeon-kit.the_machinery_db&quot;);
    // ...
}
</code></pre>
<h2 id="how-do-we-run-an-integration-test"><a class="header" href="#how-do-we-run-an-integration-test"><strong>How do we run an integration test?</strong></a></h2>
<p>To run your newly created integration test, we need to build the project via tmbuild. Then start The Machinery with the <code>-t/--test [NAME]</code> parameter. It runs the specified integration test. </p>
<blockquote>
<p>You can use multiple --test arguments to run multiple tests. This will boot up the engine and run your integration tests.</p>
</blockquote>
<p><em>Example:</em></p>
<pre><code>./bin/the-machinery.exe --test stress-test
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="helper-tools"><a class="header" href="#helper-tools">Helper Tools</a></h1>
<p>The Machinery comes with a few tools to make your daily life easier. There are tools for:</p>
<ul>
<li>Generating Static Hash Values: <code>hash</code></li>
<li>Generate Graph Nodes for you:<code>generate-graph-nodes</code></li>
<li>To generate the solution files of The Engine or your plugin: <code>tmbuild</code></li>
<li>Execute your unit tests: <code>unit-test</code></li>
<li>Generate your Localization tables: <code>localize</code></li>
<li>Free your Plugins from unneeded includes: <code>trim-includes.exe</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-use-tmbuild-1"><a class="header" href="#how-to-use-tmbuild-1">How to use tmbuild</a></h1>
<p>We described <code>tmbuild</code>'s core idea in our blog-post <a href="https://ourmachinery.com/post/one-button-source-code-builds/"><em>One-button source code builds</em></a>. <code>tmbuild</code> is our custom one-click &quot;build system.&quot; and it is quite a powerful tool. It allows you to do the most important tasks when developing with The Machinery: Building your plugin or the whole engine.</p>
<p>You can execute the tool from any terminal such as PowerShell or the VS Code internal Console window.</p>
<p>The key features are:</p>
<ul>
<li>building</li>
<li>packaging</li>
<li>cleaning the solution/folder</li>
<li>downloading all the dependencies</li>
<li>running our unit tests</li>
</ul>
<p>This walkthrough introduces you to <code>tmbuild</code> and shows you how to use and manipulate The Machinery Projects. You will learn about:</p>
<ul>
<li>How to build with it</li>
<li>How to build a specific project with it</li>
<li>How to package your project</li>
</ul>
<p>Also, you will learn some more advanced topics such as:</p>
<ul>
<li>How to build/manipulate tmbuild</li>
</ul>
<p><strong>Table of Content</strong></p>
<ul>
<li><a href="helper_tools/tmbuild.html#installing-tmbuild">Installing tmbuild</a></li>
<li><a href="helper_tools/tmbuild.html#set-up-our-environment-variables">Set up our environment variables</a></li>
<li><a href="helper_tools/tmbuild.html#let-us-build-a-plugin">Let us Build a plugin.</a></li>
<li><a href="helper_tools/tmbuild.html#let-us-build-a-specific-project">Let us build a specific project.</a></li>
<li><a href="helper_tools/tmbuild.html#how-how-to-package-a-project-via-tmbuild">How how to package a project via tmbuild?</a></li>
<li><a href="helper_tools/tmbuild.html#how-to-build-or-manipulate-tmbuild-from-source">How to build or manipulate tmbuild from source</a></li>
<li><a href="helper_tools/tmbuild.html#how-to-add-tmbuild-globally-accessible">How to add tmbuild globally accessible?</a></li>
</ul>
<h2 id="installing-tmbuild-1"><a class="header" href="#installing-tmbuild-1"><strong>Installing tmbuild</strong></a></h2>
<p>When you download and unzip <a href="https://ourmachinery.com/">The Machinery</a> either via the <a href="https://ourmachinery.com/beta.html">website</a> or via the <a href="helper_tools/tmbuild.html#">download tab</a> you can find tmbuild in the bin folder in the root. </p>
<blockquote>
<p>Alternatively, you can build it from source <code>code\utils.</code> We will talk about this later in this walkthrough. </p>
</blockquote>
<p>Before we use tmbuild, we need to ensure that we have installed either <em>build-essentials</em> under Linux, <em>XCode</em> on Mac, or <em>Visual Studio 2017 or 2019</em> (Either the Editor such as the Community Edition or the Build Tools). </p>
<p><strong>Windows Side nodes:</strong></p>
<p>On Windows, it is essential to install the C/C++ Build tools. 
If you run into the issue that tmbuild cannot find Visual Studios 2019 on Windows, it could be because you installed it on a typical path.  No problem, you can just set the environment variable <code>TM_VS2017_DIR</code> or <code>TM_VS2019_DIR</code> to the root <code>C:\Program Files (x86)\Microsoft Visual Studio\2019</code>. The tool will find the right installed version automagically.</p>
<h2 id="set-up-our-environment-variables-1"><a class="header" href="#set-up-our-environment-variables-1"><strong>Set up our environment variables</strong></a></h2>
<p>Before we can build any project, we need to set up our environment. You need to set the following environment variable: 
(If this one has not been set the tool will not be able to build)</p>
<ul>
<li><code>TM_SDK_DIR</code> - This is the path to find the folder <code>headers</code> and the folder <code>lib</code></li>
</ul>
<p>If the following variable is not set, the tool will assume that you intend to use the current working directory:</p>
<ul>
<li><code>TM_LIB_DIR</code> - The folder which determines where to download and install all dependencies (besides the build environments)</li>
</ul>
<p><strong>How to add environment variables?</strong></p>
<p><strong>Windows</strong></p>
<p>On Windows all you need to do is you need to add the folder where you installed The Machinery to your environment variables. You can do this like this:
<strong>Start &gt; Edit the system environment variables &gt; environment variables &gt; system varaibles &gt; click New... &gt;</strong> add <code>TM_SDK_DIR</code> or <code>TM_LIB_DIR</code> as the Variable Name and the needed path as the Variable Value.
Close and restart the terminal or Visual Studio / Visual Studio Code.
As an alternative, you can set an environment variable via PowerShell before you execute tmbuild, which will stay alive till the end of the session:
<code>$Env:TM_SDK_DIR=&quot;..PATH&quot;</code></p>
<p><strong>Debian/Ubuntu Linux</strong></p>
<p>You open the terminal or edit with your favorite text editor <code>~/.bashrc</code> and you add the following lines:</p>
<pre><code>#...
export TM_SDK_DIR=path/to/themachinery/
export TM_LIB_DIR=path/to/themachinery/libs
</code></pre>
<p>(e.g. via nano nano <code>~/.bashrc</code>)</p>
<h2 id="let-us-build-a-plugin-1"><a class="header" href="#let-us-build-a-plugin-1"><strong>Let us Build a plugin</strong>.</a></h2>
<p>All you need to do is: navigate to the <strong>root folder</strong> of your plugin and run in PowerShell <code>tmbuild.exe</code>. </p>
<blockquote>
<p>If you have not added tmbuild.exe to your global PATH, you need to have the right path to where tmbuild is located. <code>user@machine/home/user/tm/plugins/my_plugin/&gt; ./../../bin/tmbuild</code></p>
</blockquote>
<p>This command does all the magic. tmbuild will automatically download all the needed dependencies etc., for you <em>(Either in the location set in <code>TM_LIB_DIR</code> or in the current working directory)</em>. 
You may have noticed tmbuild will always run unit tests at the end of your build process.</p>
<blockquote>
<p><strong>Note:</strong> tmbuild will only build something when there is a premake5.lua and a libs.json in the current <em>working directory</em>.</p>
</blockquote>
<h2 id="let-us-build-a-specific-project-1"><a class="header" href="#let-us-build-a-specific-project-1"><strong>Let us build a specific project</strong>.</a></h2>
<p>Imagine you have been busy and written a bunch of plugins, and they are all connected and managed via the same Lua file (premake5 file). 
Now you do not want to check everything all the time. No problem, you can follow these steps:
If you run <code>tmbuild --help/-h</code>, you will see many options. One of those options is <code>--project</code>. This one allows you to build a specific project.</p>
<pre><code>tmbuild.exe --project my-project-name
</code></pre>
<p>The tool will automatically find the right project and build it. 
On Windows, you can also provide the relative/absolute path to the project with extension: ``</p>
<pre><code>tmbuild --project /path/to/project.vcxproj
</code></pre>
<blockquote>
<p><strong>Note:</strong>
If a project cannot be found it will build all projects.</p>
</blockquote>
<h2 id="how-how-to-package-a-project-via-tmbuild-1"><a class="header" href="#how-how-to-package-a-project-via-tmbuild-1">How how to package a project via tmbuild?</a></h2>
<p>To package a project via tmbuild, all you need to do is use the <code>-p [package name]</code> or <code>--package [package name]</code> command. A package file needs to be of type <code>.json</code> and follow our package scheme, which you can find <a href="helper_tools/tmbuild.html#">here</a>.</p>
<h2 id="how-to-build-or-manipulate-tmbuild-from-source-1"><a class="header" href="#how-to-build-or-manipulate-tmbuild-from-source-1">How to build or manipulate tmbuild from source</a></h2>
<p>You can find the source code of tmbuild in folder <code>code\utils\tmbuild</code>. In the folder <code>code\utils</code>, you can also find the source code of all the other uses the engine uses.</p>
<p>You can build tmbuild via tmbuild. All you need to do is navigate the <code>code\utils</code> folder and run <code>tmbuild --project tmbuild</code>. </p>
<p>If you do not have access to a build version of tmbuild but to the whole source, you have to follow the following steps:</p>
<p><strong>Windows 10</strong></p>
<p>Make sure you have Visual Studio 19 and the Build Tools installed. Besides, check if you can find <code>msbuild</code> in the terminal. You can install <code>msbuild / vs studio</code> via PowerShell: <a href="https://github.com/Microsoft/vssetup.powershell">https://github.com/Microsoft/vssetup.powershell</a></p>
<p>To check just run:</p>
<pre><code class="language-bash">msbuild
</code></pre>
<p>if you cannot find it just add it to your environment path variables: with e.g.
<code>C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\MSBuild\Current\Bin\</code></p>
<p><strong>To build from source:</strong></p>
<p>Open a PowerShell instance in The Machinery folder and run the following commands:</p>
<pre><code class="language-powershell"># this part can be skiped if you have already downloaded
# all the dependencies and created a highlevel folder to your lib dependencies:
mkdir lib
cd lib
 wget https://ourmachinery.com/lib/bearssl-0.6-r1-win64.zip -OutFile bearssl-0.6-r1-win64.zip
 wget https://ourmachinery.com/lib/premake-5.0.0-alpha14-windows.zip -OutFile premake-5.0.0-alpha14-windows.zip
Expand-Archive -LiteralPath './bearssl-0.6-r1-win64.zip' -DestinationPath &quot;.&quot;
Expand-Archive -LiteralPath './premake-5.0.0-alpha14-windows.zip' -DestinationPath &quot;.&quot;
cd ..
# continue here if the dependencies are already downloaded
# set TM_LIB_DIR if you have not set it already
$env:TM_LIB_DIR=&quot;/path/to/themachinery/lib&quot;
$env:TM_SDK_DIR=&quot;/path/to/themachinery/&quot;
# run premake
./../../lib/premake-5.0.0-alpha14-windows/premake5 [vs2019|vs2017]
# navigate to the highlevel folder of the code (here you find the libs.json and the
# premake5.lua
cd code/utils
msbuild.exe &quot;build/tmbuild/tmbuild.vcxproj&quot; /p:Configuration=&quot;Debug Win64&quot; /p:Platform=x64
</code></pre>
<p><em>Make sure that you either choose vs2019 or vs2017 not</em> [vs2019|vs2017]</p>
<p><strong>On Debian/Ubuntu</strong></p>
<p>Open a terminal instance and run the following commands:</p>
<pre><code class="language-bash"># If you do not have the huild essentials installed make sure you do:
sudo apt install build-essential clang zip -y
# otherweise continue here:
cd your-folder-of-tm
# this part can be skiped if you have already downloaded
# all the dependencies and created a highlevel folder to your lib dependencies:
mkdir lib
cd ./lib
wget https://ourmachinery.com/lib/bearssl-0.6-r1-linux.zip
wget https://ourmachinery.com/lib/premake-5.0.0-alpha15-linux.zip
unzuip bearssl-0.6-r1-linux.zip .
unzip premake-5.0.0-alpha15-linux.zip .
chmod +x ./premake-5.0.0-alpha15-linux/premake5
cd ..
# continue here if the dependencies are already downloaded
# set TM_LIB_DIR if you have not set it already
export TM_LIB_DIR=/path/to/themachinery/lib
export TM_SDK_DIR=/path/to/themachinery/
# run premake
./../../lib/premake-5.0.0-alpha15-linux/premake5 gmake
# navigate to the highlevel folder of the code (here you find the libs.json and the
# premake5.lua
cd code/utils
# run make:
make tmbuild
</code></pre>
<h2 id="how-to-add-tmbuild-globally-accessible-1"><a class="header" href="#how-to-add-tmbuild-globally-accessible-1">How to add tmbuild globally accessible?</a></h2>
<p><strong>Windows</strong>
On Windows, all you need to do is you need to add the folder/bin to your environment variables. This can be done like this:
<strong>Start &gt; Edit the system environment variables &gt; environment variables &gt; system variables &gt; search in the list for path &gt; click Edit &gt; click new &gt;</strong> add the absolute path to <code>themachinery/bin</code> in there
re-login or reboot.</p>
<p><strong>Debian/Ubuntu Linux</strong>
You open the terminal or edit with your favorite text editor <code>~/.bashrc</code>, and you add the following lines:
<code>export PATH=path/to/themachinery/bin:$PATH</code>
(e.g. via nano nano <code>~/.bashrc</code>)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-use-hashexe"><a class="header" href="#how-to-use-hashexe">How to use hash.exe</a></h1>
<p>This walkthrough introduces you to hash.exe and shows you how to use it with The Machinery. </p>
<p>You will learn about:</p>
<ul>
<li>How to use <code>hash.exe</code> and  <a href="https://ourmachinery.com/apidoc/foundation/api_types.h.html#tm_static_hash()">TM_STATIC_HASH</a></li>
</ul>
<h2 id="how-to-use-hashexe-and-tm_static_hash"><a class="header" href="#how-to-use-hashexe-and-tm_static_hash">How to use hash.exe and TM_STATIC_HASH</a></h2>
<p>While working with The Machinery, you will have surely noticed that its systems often expect a hashed version of a string as input. In this document, we will be dealing with static hashes defined with <a href="https://ourmachinery.com/apidoc/foundation/api_types.h.html#tm_static_hash()">TM_STATIC_HASH</a> to identify, for example, a type in our data model, <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/the_truth/index.html">The Truth</a>. If you are searching documentation on runtime hashes, you’ll want to check out the <a href="https://ourmachinery.com/apidoc/foundation/murmurhash64a.inl.html#murmurhash64a.inl">murmurhash64a.inl</a> files.</p>
<p>In this document, we will be using hash.exe to generate new hash values or update the changed ones. The hash.exe utility checks the entire source code and makes sure that wherever you use <a href="https://ourmachinery.com/apidoc/foundation/api_types.h.html#tm_static_hash()">TM_STATIC_HASH</a>, the numeric value v matches the actual hash of the string s (if not, the code is updated). If you do not run the executable before you build, you will have compile errors. </p>
<blockquote>
<p><strong>Note</strong>: <code>tmbuild</code> has the option to run hash.exe before it builds. <code>tmbuild --gen-hash</code>.</p>
</blockquote>
<p>Let us look at where this tool is useful and is being used a lot:  In <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/the_truth/index.html">The Truth</a>.</p>
<p>For example, When defining Truth Objects or Types, we are using this tool to hash the name of the type statically</p>
<pre><code class="language-c">//...

#define TM_TT_TYPE__ASSET &quot;tm_asset&quot;

#define TM_TT_TYPE_HASH__ASSET TM_STATIC_HASH(&quot;tm_asset&quot;, 0xca71127abbb72960ULL)

enum {

 TM_TT_PROP__ASSET__NAME = 0, // string

 TM_TT_PROP__ASSET__DIRECTORY, // reference(ASSET_DIRECTORY)

 TM_TT_PROP__ASSET__UUID_TAGS, // subobject_set(UINT64_T) storing the UUID of the associated tag.

 TM_TT_PROP__ASSET__OBJECT, // subobject(*)

};

//...
</code></pre>
<p>In the above example we have the definition of the Truth Type tm_asset. The <code>#define TM_TT_TYPE_HASH__ASSET TM_STATIC_HASH(&quot;tm_asset&quot;, 0xca71127abbb72960ULL)</code> was generated by the hash utility. Before the tool ran the code looked similar to this: <code>#define TM_TT_TYPE_HASH__ASSET TM_STATIC_HASH(&quot;tm_asset&quot;)</code></p>
<p>For example later on we can use it  to create a object of this type. If we do not have the corresponding type id <a href="https://ourmachinery.com/apidoc/foundation/api_types.h.html#structtm_tt_type_t">tm_tt_type_t</a> we need to ask The Truth: </p>
<pre><code class="language-c">tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__ASSET);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tmbuild-package-json-reference"><a class="header" href="#tmbuild-package-json-reference">tmbuild package json Reference</a></h1>
<p>The <code>tmbuild</code> can package a project based rules set in a <code>.json</code> file. This file needs to adhere the here described scheme.
Every package <code>json</code> file is structured in its core like this:</p>
<pre><code>{
    &quot;name&quot;:&quot;package name&quot;,
    &quot;steps&quot;: []
}
</code></pre>
<p>The name will be used to determine the name of the package folder in <code>tm root/build</code> directory. The steps are the key in the system they will be executed linearly after each other and the next step only will be executed if the previous step was successful.
Steps are defined as a normal <code>json</code> object. The following list displays all the functions which can be used plus adequate examples.</p>
<p><strong>Table of Content</strong></p>
<ul>
<li><a href="helper_tools/tmbuild_package_reference.html#utilities">Utilities</a>
<ul>
<li><a href="helper_tools/tmbuild_package_reference.html#logging">Logging</a></li>
<li><a href="helper_tools/tmbuild_package_reference.html#change-directory">Change directory</a></li>
<li><a href="helper_tools/tmbuild_package_reference.html#platforms">Platforms</a></li>
</ul>
</li>
<li><a href="helper_tools/tmbuild_package_reference.html#actions">Actions</a></li>
<li><a href="helper_tools/tmbuild_package_reference.html#filesystem-operations">Filesystem operations</a>
<ul>
<li><a href="helper_tools/tmbuild_package_reference.html#build"><code>build</code></a></li>
<li><a href="helper_tools/tmbuild_package_reference.html#copy-files"><code>copy-files</code></a></li>
<li><a href="helper_tools/tmbuild_package_reference.html#copy-file-patterns"><code>copy-file-patterns</code></a></li>
<li><a href="helper_tools/tmbuild_package_reference.html#delete-dirs"><code>delete-dirs</code></a></li>
<li><a href="helper_tools/tmbuild_package_reference.html#delete-file-patterns"><code>delete-file-patterns</code></a></li>
<li><a href="helper_tools/tmbuild_package_reference.html#docgen"><code>docgen</code></a></li>
<li><a href="helper_tools/tmbuild_package_reference.html#localize"><code>localize</code></a></li>
<li><a href="helper_tools/tmbuild_package_reference.html#set-sdk-dir"><code>set-sdk-dir</code></a></li>
<li><a href="helper_tools/tmbuild_package_reference.html#zip"><code>zip</code></a></li>
</ul>
</li>
</ul>
<h2 id="utilities"><a class="header" href="#utilities">Utilities</a></h2>
<h3 id="logging-1"><a class="header" href="#logging-1">Logging</a></h3>
<table><thead><tr><th>Setting Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>log</td><td>string</td><td>Takes a string as value and will on execution print this string to the output log</td></tr>
</tbody></table>
<p>Example</p>
<pre><code>{
    &quot;name&quot;:&quot;example-plugin&quot;,
    &quot;steps&quot;: [
    {
        &quot;log&quot;:&quot;Example Plugin&quot;
    }
    ]
}
</code></pre>
<h3 id="change-directory"><a class="header" href="#change-directory">Change directory</a></h3>
<table><thead><tr><th>Setting Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>chdir</td><td>string</td><td>Takes a string and tries to change directory to this path.</td></tr>
</tbody></table>
<p>Example</p>
<pre><code>{
    &quot;name&quot;:&quot;example-plugin&quot;,
    &quot;steps&quot;: [
    {
        &quot;log&quot;:&quot;change dir&quot;,
        &quot;chdir&quot;:&quot;utils&quot;
    }
    ]
}
</code></pre>
<h3 id="platforms"><a class="header" href="#platforms">Platforms</a></h3>
<table><thead><tr><th>Setting Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>platforms</td><td>string array</td><td>Takes a list of possible platforms this step shall be executed on</td></tr>
</tbody></table>
<pre><code>{
   &quot;action&quot;:&quot;delete-dirs&quot;,
   &quot;root&quot;:&quot;build/tmbuild/&quot;,
   &quot;dirs&quot;:[
      &quot;vs2017&quot;
   ],
   &quot;platforms&quot;:[
      &quot;windows&quot;
   ]
}
</code></pre>
<h2 id="actions"><a class="header" href="#actions">Actions</a></h2>
<p>A action defines what the current step shall do.</p>
<table><thead><tr><th>Setting Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>action</td><td>string</td><td>Takes a string as value which will determine what kind of action this step shall do</td></tr>
</tbody></table>
<h2 id="filesystem-operations"><a class="header" href="#filesystem-operations">Filesystem operations</a></h2>
<h3 id="build"><a class="header" href="#build"><code>build</code></a></h3>
<p>Will build the current directory unless changed via <code>chdir</code> in release and debug setting.  Optional it has a project field if you only want to build one project. One can also modify the build tool and specify that in a extra field.</p>
<table><thead><tr><th>Setting Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>project</td><td>string</td><td>Takes the name of the project it shall build</td></tr>
<tr><td>build-tool</td><td>string</td><td>Takes the name of the premake build tool which shall be used.</td></tr>
</tbody></table>
<pre><code>{
   &quot;log&quot;:&quot;Build Lib&quot;,
   &quot;action&quot;:&quot;build&quot;,
   &quot;project&quot;:&quot;lib_static&quot;,
   &quot;build-tool&quot;:&quot;vs2017&quot;,
   &quot;platforms&quot;:[
      &quot;windows&quot;
   ]
}
</code></pre>
<h3 id="copy-files"><a class="header" href="#copy-files"><code>copy-files</code></a></h3>
<p>Will copy files which are specified in a <code>files</code> field. Also the location is needed to where those files should be copied. This location needs to be specified in the field<code>to-dir</code></p>
<table><thead><tr><th>Setting Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>files</td><td>string array</td><td>A list of relative paths to the files the step shall copy</td></tr>
<tr><td>to-dir</td><td>string</td><td>The destination directory</td></tr>
</tbody></table>
<h3 id="copy-file-patterns"><a class="header" href="#copy-file-patterns"><code>copy-file-patterns</code></a></h3>
<p>Will copy files based on file patterns to a set location.</p>
<table><thead><tr><th>Setting Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>from-dir</td><td>string</td><td>Sets the location from where files shall be copied</td></tr>
<tr><td>to-dir</td><td>string</td><td>The destination directory of the action</td></tr>
<tr><td>dir-patterns</td><td>string array</td><td>What folders shall be copied. Patterns used in gitignore files can be used e.g. <code>*.zip</code></td></tr>
<tr><td>file-patterns</td><td>string array</td><td>What files shall be copied. Patterns used in gitignore files can be used e.g. <code>*.zip</code></td></tr>
</tbody></table>
<pre><code>{
   &quot;action&quot;:&quot;copy-file-patterns&quot;,
   &quot;from-dir&quot;:&quot;plugins/my-plugin&quot;,
   &quot;to-dir&quot;:&quot;dest/folder/plugins/my-plugin&quot;,
   &quot;dir-patterns&quot;:[
      &quot;*&quot;
   ],
   &quot;file-patterns&quot;:[
      &quot;*.c&quot;,
      &quot;*.h&quot;,
      &quot;*.inl&quot;
   ]
}
</code></pre>
<h3 id="delete-dirs"><a class="header" href="#delete-dirs"><code>delete-dirs</code></a></h3>
<p>Will delete folders which are specified in <code>dirs</code> but taking the <code>root</code> field into account.</p>
<table><thead><tr><th>Setting Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>dirs</td><td>string array</td><td>A list of relative paths to the files the step shall delete</td></tr>
<tr><td>root</td><td>string</td><td>The root directory</td></tr>
</tbody></table>
<h3 id="delete-file-patterns"><a class="header" href="#delete-file-patterns"><code>delete-file-patterns</code></a></h3>
<p>Will delete files based on a patter.</p>
<table><thead><tr><th>Setting Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>dir</td><td>string</td><td>A folder in the package folder</td></tr>
<tr><td>dir-patterns</td><td>string array</td><td>What folders shall be deleted. Patterns used in gitignore files can be used e.g. <code>*.zip</code></td></tr>
<tr><td>file-patterns</td><td>string array</td><td>What files shall be deleted. Patterns used in gitignore files can be used e.g. <code>*.zip</code></td></tr>
</tbody></table>
<pre><code>{
   &quot;action&quot;:&quot;delete-file-patterns&quot;,
   &quot;dir&quot;:&quot;bin/plugins&quot;,
   &quot;dir-patterns&quot;:[
      &quot;*&quot;
   ],
   &quot;file-patterns&quot;:[
      &quot;*.pdb&quot;,
      &quot;*.lib&quot;,
      &quot;*.exp&quot;
   ]
},
</code></pre>
<h3 id="docgen"><a class="header" href="#docgen"><code>docgen</code></a></h3>
<p>Will generate documentation based on the provided arguments in the arguments field.</p>
<table><thead><tr><th>Setting Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>args</td><td>string</td><td>Arguments for <code>docgen.exe</code> to generate documentation</td></tr>
</tbody></table>
<h3 id="localize"><a class="header" href="#localize"><code>localize</code></a></h3>
<p>Will check if all localization are present if not fail.</p>
<h3 id="set-sdk-dir"><a class="header" href="#set-sdk-dir"><code>set-sdk-dir</code></a></h3>
<p>Will set the SDK if not set dir to the current build directory <code>[cwd]/build/[package-name]</code>. Has no other fields.</p>
<h3 id="zip"><a class="header" href="#zip"><code>zip</code></a></h3>
<p>Will zip the package folder and if the field <code>add-time-stamp</code> is set to true it will add the time stamp to the name of the zipped file.</p>
<table><thead><tr><th>Setting Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>add-time-stamp</td><td>bool</td><td>If set to true the zipped file will contain the timestamp</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="writing-an-executable"><a class="header" href="#writing-an-executable">Writing an executable</a></h2>
<p>Writing a stand-alone executable is similar to writing a plugin except that you need to write
initialization code for booting up all the systems that you want to use as well as the main loop
code that runs the executable.</p>
<p><code>bin/simple-draw.exe</code> is a sample executable that uses the UI / Draw2D interfaces of The Machinery
to implement a simple drawing program:</p>
<p><img src="https://www.dropbox.com/s/bilirde9yud4rn3/simple-draw.png?dl=1" alt="Simple Draw executable." /></p>
<p>The source code of this sample program is available in the <code>samples</code> directory. By playing with
and modifying this, you can see how to build your own applications on top of <em>The Machinery</em>.</p>
<p>Note that just as when writing plugins, you need a Visual Studio installation (2019) to build an
executable. You need to set <code>TM_SDK_DIR</code> to the location of The Machinery SDK you are using, and you
use <code>tmbuild.exe</code> to build the executable.</p>
<p><code>bin/simple-3d.exe</code> is a sample executable that uses the full 3D API.</p>
<p><img src="https://www.dropbox.com/s/oz9zob150yksnhr/simple-3d.png?dl=1" alt="Simple 3D executable." /></p>
<p>You will find the source code for this too in the samples directory.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
