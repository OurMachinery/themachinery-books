# Glossary

The following list provides the most common terms used in The Machinery.

| Term                                                         | Description                                                  |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [The Truth]({{the_machinery_book}}the_truth/index.html)      | The Truth is a system that holds an authoritative data state and allows it to be shared between various systems. In particular, it supports the following features:<br><br>- Objects with properties (bools, ints, floats, strings).<br>- Buffer properties for holding big chunks of binary data.<br>- Subobjects (objects of other types belonging to this object).<br>- References to other objects.<br>- Sets of subobjects and references.<br>- Prototypes and inheritance.<br>- Change notifications.<br>- Safe multi-threaded access.<br>- Undo/redo operations (from multiple streams).<br><br>More information is available in the [documentation]({{docs}}foundation/the_truth.h.html#the_truth.h). |
| [Truth Aspect]({{the_machinery_book}}/the_truth/aspects.html) | An “aspect” is an interface (struct of function pointers) identified by a unique identifier. The Truth allows you to associate aspects with object types. This lets you extend The Truth with new functionality. |
| [Creation Graph]({{the_machinery_book}}creation_graphs/concept.html) | The creation graph is (as the name implies) a graph based tool for creating assets. It allows developers to define and alter various types of assets using visual scripting. More broadly speaking, the creation graph can be used for arbitrary data processing tasks. [More]({{the_machinery_book}}creation_graphs/concept.html) |
| [Creation Graph GPU Nodes]({{the_machinery_book}}creation_graphs/node_types.html) | Creation Graphs contain nodes that can execute on both the CPU and GPU. The GPU nodes usually become part of a shader program when the creation graph is compiled. There are nodes to transition from the CPU to GPU. |
| [Entity Graph]({{the_machinery_book}}editing_workflows/visual-scripting.html) | The Machinery’s Visual Scripting Language for game play. [More]({{the_machinery_book}}editing_workflows/visual-scripting.html) |
| [Prototype]({{the_machinery_book}}editing_workflows/prototypes.html) | Our prototype system allows entity assets to be used inside other entities. Therefore, you can create an entity asset that represents a room and then creates a house entity that has a bunch of these room entities placed into it. For more information on Prototypes, check out its [Prototypes]({{the_machinery_book}}editing_workflows/prototypes.html). (Also called Prefabs in other Engines) |
| [Properties Tab]({{the_machinery_book}}the_editor/properties_tab.html) | Whenever an object gets focused in the asset browser or entity tree, properties of it can be edited from the properties tab. |
| [Asset Browser]({{the_machinery_book}}the_editor/asset_browser.html) | Shows all assets in your project in an explorer-style fashion. An asset can be thought of as the equivalent of a file in the OS. Some assets such as entities can be dragged and dropped from the asset browser into the scene tab. |
| Graph Tab/View                                               | A tab that can either represent a Entity Graph or a Creation Graph. |
| [Entity Tree]({{the_machinery_book}}the_editor/entity_tree_tab.html) | Hierarchical view of the Entity currently being edited.<br>In The Machinery, every entity has a parent except for the root entity of the world. (which is generally called “world”).<br>This Tab Allows the user to quickly reason and re-organize the hierarchy by adding, removing, expanding and reordering entities. |
| [Simulation Entry]({{the_machinery_book}}/gameplay_coding/simulation_entry.html) | Is a generic concept to provide functionality for the game play to start, stop and update (tick). This concept consists out of two components: The Simulation Entry Interface (tm_simulation_entry_i) as simulation entry component. The interface is there to provide functionality, while the component is the connection with the simulation. |
| [Engine (ECS)]({{the_machinery_book}}/gameplay_coding/ecs/index.html) | An *engine* is an update function that runs on all entities that have certain components. (Jobified) |
| [System (ECS)]({{the_machinery_book}}/gameplay_coding/ecs/index.html) | A *system* is an update function that runs on the entire entity context. |
| [Entity Context]({{the_machinery_book}}/gameplay_coding/ecs/index.html) | It’s the core runtime Entity-Component-System of The Machinery.<br>It’s main two components are:<br><br>- Entities (see Entity)<br>- Systems and Engines |
| [Entity]({{the_machinery_book}}/gameplay_coding/ecs/index.html) | In The Machinery a game world is build out of different entities which are defined through different components. Those components create the building blocks of each entity and give them their meaning. |
| [Components]({{the_machinery_book}}/gameplay_coding/ecs/what_are_components.html) | A building block for entities.  Moreover a *component* is a type of data that can be associated with an entity. |
| DCC Asset                                                    | Digital Content Creation Assets. Any type of assets created by any digital content creation tool such as Blender or Maya. |
| [Plugin]({{the_machinery_book}}/extending_the_machinery/the_plugin_system.html) | The Machinery is built around a plugin model. All features, even the built-in ones, are provided through plugins. You can extend The Machinery by writing your own plugins. When The Machinery launches, it loads all the plugins named `tm_*.dll` in its `plugins/` folder. If you write your own plugins, name them so that they start with `tm_` and put them in this folder, they will be loaded together with the built-in plugins. |
| [Plugin assets]({{the_machinery_book}}/extending_the_machinery/plugin-assets.html) | A special type of asset that contains the library (executable code) for a plugin. This makes it possible to add compiled plugins without have to copy the DLL into a specific folder, instead you can just drag n drop DLLs into the project. The user will be asked for consent to run the code in the plugin. |
| [Project]({{the_machinery_book}}/getting_started/new_project.html) | It is a self-contained directory or database file that holds all the game data used during the development. |
| `tmsl`                                                       | `.tmsl` stands for `The Machinery Shader Language` and is essentially a data-driven json front-end to create a `tm_shader_declaration_o`. The `tm_shader_declaration_o` can be anything from a complete shader configuration (all needed shader stages, any states and input/output it needs, etc) that can be compiled and used when rendering a draw call (or dispatching a compute job), to just fragments of that. Typically a `.tmsl` file only contains fragments of what's needed and our shader compiler combines a bunch of them to build a functional shader. |

