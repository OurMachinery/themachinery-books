<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Open Asset in Tab - The Machinery Tutorial Book</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="../favicon.svg">
                        <link rel="shortcut icon" href="../favicon.png">
                <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
                <link rel="stylesheet" href="../css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="../fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="../index.html"><strong aria-hidden="true">1.</strong> Welcome</a></li><li class="chapter-item "><a href="../workflows/how_to_create_prototypes.html"><strong aria-hidden="true">2.</strong> How to Create Prototypes</a></li><li class="chapter-item "><a href="../workflows/how_to_instantiate_prototypes.html"><strong aria-hidden="true">3.</strong> How to Instantiate Prototypes</a></li><li class="chapter-item "><a href="../creation_graph/index.html"><strong aria-hidden="true">4.</strong> Creation Graph</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../creation_graph/introduction_walkthrough/index.html"><strong aria-hidden="true">4.1.</strong> Creation Graph Introduction Series</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../creation_graph/introduction_walkthrough/texture_compression.html"><strong aria-hidden="true">4.1.1.</strong> Simple Texture Compression</a></li><li class="chapter-item "><a href="../creation_graph/introduction_walkthrough/creation_graph_prototype.html"><strong aria-hidden="true">4.1.2.</strong> Creation Graph Prototype</a></li><li class="chapter-item "><a href="../creation_graph/introduction_walkthrough/custom_import_settings.html"><strong aria-hidden="true">4.1.3.</strong> Custom Import Settings</a></li></ol></li><li class="chapter-item "><a href="../creation_graph/custom_gpu_nodes.html"><strong aria-hidden="true">4.2.</strong> Creating Custom GPU Nodes</a></li><li class="chapter-item "><a href="../creation_graph/custom_cpu_nodes.html"><strong aria-hidden="true">4.3.</strong> Creating Custom CPU Nodes</a></li><li class="chapter-item "><a href="../creation_graph/custom_geometry_node.html"><strong aria-hidden="true">4.4.</strong> Creating Custom Geometry Nodes</a></li><li class="chapter-item "><a href="../creation_graph/from_code.html"><strong aria-hidden="true">4.5.</strong> Calling Creation Graphs from Code</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../creation_graph/raymarch_output_node.html"><strong aria-hidden="true">4.5.1.</strong> Creating a Custom Raymarching Output Node</a></li></ol></li></ol></li><li class="chapter-item "><a href="../post_processing/index.html"><strong aria-hidden="true">5.</strong> Post Processing</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../post_processing/aa.html"><strong aria-hidden="true">5.1.</strong> Anti-Aliasing</a></li><li class="chapter-item "><a href="../post_processing/exposure.html"><strong aria-hidden="true">5.2.</strong> Exposure</a></li><li class="chapter-item "><a href="../post_processing/bloom.html"><strong aria-hidden="true">5.3.</strong> Bloom</a></li><li class="chapter-item "><a href="../post_processing/color_grading.html"><strong aria-hidden="true">5.4.</strong> Color Grading</a></li></ol></li><li class="chapter-item "><a href="../physics/index.html"><strong aria-hidden="true">6.</strong> Physics</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../physics/triggers.html"><strong aria-hidden="true">6.1.</strong> Triggers</a></li></ol></li><li class="chapter-item expanded "><a href="../the_truth/index.html"><strong aria-hidden="true">7.</strong> The Truth</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../the_truth/custom_asset/index.html"><strong aria-hidden="true">7.1.</strong> Creating a Custom Asset Type</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../the_truth/custom_asset/part1.html"><strong aria-hidden="true">7.1.1.</strong> Part 1 - Create an Asset Truth Type, Addable via Asset Browser</a></li><li class="chapter-item "><a href="../the_truth/custom_asset/part2.html"><strong aria-hidden="true">7.1.2.</strong> Part 2 - Custom UI</a></li><li class="chapter-item "><a href="../the_truth/custom_asset/part3.html"><strong aria-hidden="true">7.1.3.</strong> Part 3 - Custom Importer</a></li></ol></li><li class="chapter-item "><a href="../the_truth/drag_and_drop.html"><strong aria-hidden="true">7.2.</strong> Adding Drag and Drop to Assets</a></li><li class="chapter-item expanded "><a href="../the_truth/open_asset.html" class="active"><strong aria-hidden="true">7.3.</strong> Open Asset in Tab</a></li></ol></li><li class="chapter-item "><a href="../gameplay_coding/index.html"><strong aria-hidden="true">8.</strong> Gameplay Coding</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../gameplay_coding/extend_the_entity_graph.html"><strong aria-hidden="true">8.1.</strong> Extending the Entity Graph</a></li><li class="chapter-item "><a href="../gameplay_coding/provide_custom_data_type_to_the_entity_graph.html"><strong aria-hidden="true">8.2.</strong> Custom Data Type for the Entity Graph</a></li></ol></li><li class="chapter-item "><a href="../network/index.html"><strong aria-hidden="true">9.</strong> Network</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../network/animation_sample/network_assets.html"><strong aria-hidden="true">9.1.</strong> Part 1: Network Asset</a></li><li class="chapter-item "><a href="../network/animation_sample/multiple_network_instances.html"><strong aria-hidden="true">9.2.</strong> Part 2: Multiple Instances</a></li><li class="chapter-item "><a href="../network/animation_sample/entity_control.html"><strong aria-hidden="true">9.3.</strong> Part 3: Entity Control</a></li><li class="chapter-item "><a href="../network/animation_sample/support_multiple_players.html"><strong aria-hidden="true">9.4.</strong> Part 4: Multiple Players</a></li><li class="chapter-item "><a href="../network/animation_sample/basic_graph_variables.html"><strong aria-hidden="true">9.5.</strong> Part 5: Variable Replication (Graph)</a></li><li class="chapter-item "><a href="../network/animation_sample/smooth_animation.html"><strong aria-hidden="true">9.6.</strong> Part 6: Smooth Animation</a></li><li class="chapter-item "><a href="../network/animation_sample/spawning_entities.html"><strong aria-hidden="true">9.7.</strong> Part 7: Spawning Entities</a></li></ol></li><li class="chapter-item "><a href="../ui/index.html"><strong aria-hidden="true">10.</strong> UI</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../ui/build_custom_ui_controls/index.html"><strong aria-hidden="true">10.1.</strong> Build Custom UI Controls</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../ui/build_custom_ui_controls/part1.html"><strong aria-hidden="true">10.1.1.</strong> Part 1</a></li></ol></li><li class="chapter-item "><a href="../ui/toolbars-overlays.html"><strong aria-hidden="true">10.2.</strong> Toolbars and Overlays</a></li><li class="chapter-item "><a href="../ui/custom_layouts.html"><strong aria-hidden="true">10.3.</strong> Custom Tab Layouts</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">The Machinery Tutorial Book</h1>

                    <div class="right-buttons">
                                                <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/OurMachinery/themachinery-books" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="open-a-special-tab-for-an-asset"><a class="header" href="#open-a-special-tab-for-an-asset">Open a special tab for an Asset</a></h1>
<p>This walkthrough shows you how to enable an asset to open a specific tab. You should have basic knowledge about how to write a custom plugin. If not, you might want to check this <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/extending_the_machinery/the_plugin_system.html">Guide</a>. This walkthrough aims to enable you to double-click an asset and open it in a specific tab.</p>
<p>You will learn:</p>
<ul>
<li>Create a basic tab</li>
<li>Open an asset</li>
<li>How to use a temporary temporray allocator</li>
</ul>
<p>This walkthrough will refer to the text asset example as the asset we want to extend! If you have not followed it, here is the link: <a href="https://ourmachinery.github.io/themachinery-books/tutorials//the_truth/custom_asset/index.html">Custom Asset</a>.</p>
<p><strong>Table of Content</strong></p>
<ul>
<li><a href="#new-tab">New Tab</a>
<ul>
<li><a href="#implementing-the-functions">Implementing the functions</a>
<ul>
<li><a href="#the-create-function">The Create Function</a></li>
<li><a href="#the-update-function">The Update Function</a></li>
<li><a href="#the-set-root--root-function">The set root / root function</a></li>
</ul>
</li>
<li><a href="#let-us-test-the-tab">Let us test the Tab</a></li>
<li><a href="#source-code">Source Code</a></li>
</ul>
</li>
<li><a href="#open-the-tab">Open the Tab</a>
<ul>
<li><a href="#contributors">Contributors</a></li>
</ul>
</li>
</ul>
<h2 id="new-tab"><a class="header" href="#new-tab">New Tab</a></h2>
<p>The first cause of action is to create the Tab we want to open. </p>
<blockquote>
<p><strong>Note:</strong> We can use the basic tab Template from the Engine: <strong>File -&gt; New Plugin -&gt; New Tab.</strong> </p>
</blockquote>
<p>In this walkthrough, we aim to have a simple tab that shows the content of our text file.</p>
<p>The Steps of creating a tab are similar to the ones of a standard plugin:</p>
<ol>
<li>We create a new file. For example: <code>txt_tab.c</code></li>
<li>We make use of the default tab template provided by the engine:</li>
</ol>
<pre><code class="language-c">static struct tm_api_registry_api *tm_global_api_registry;

static struct tm_draw2d_api *tm_draw2d_api;
static struct tm_ui_api *tm_ui_api;
static struct tm_allocator_api *tm_allocator_api;

#include &lt;foundation/allocator.h&gt;
#include &lt;foundation/api_registry.h&gt;

#include &lt;plugins/ui/docking.h&gt;
#include &lt;plugins/ui/draw2d.h&gt;
#include &lt;plugins/ui/ui.h&gt;
#include &lt;plugins/ui/ui_custom.h&gt;

#include &lt;the_machinery/the_machinery_tab.h&gt;

#include &lt;stdio.h&gt;
#define TM_CUSTOM_TAB_VT_NAME &quot;tm_custom_tab&quot;
#define TM_CUSTOM_TAB_VT_NAME_HASH TM_STATIC_HASH(&quot;tm_custom_tab&quot;, 0xbc4e3e47fbf1cdc1ULL)
struct tm_tab_o
{
    tm_tab_i tm_tab_i;
    tm_allocator_i allocator;
};
static void tab__ui(tm_tab_o *tab, tm_ui_o *ui, const tm_ui_style_t *uistyle_in, tm_rect_t rect)
{
    tm_ui_buffers_t uib = tm_ui_api-&gt;buffers(ui);
    tm_ui_style_t *uistyle = (tm_ui_style_t[]) { *uistyle_in };
    tm_draw2d_style_t *style = &amp;(tm_draw2d_style_t) { 0 };
    tm_ui_api-&gt;to_draw_style(ui, style, uistyle);
    style-&gt;color = (tm_color_srgb_t) { .a = 255, .r = 255 };
    tm_draw2d_api-&gt;fill_rect(uib.vbuffer, *uib.ibuffers, style, rect);
}
static const char *tab__create_menu_name(void)
{
    return &quot;Custom Tab&quot;;
}

static const char *tab__title(tm_tab_o *tab, struct tm_ui_o *ui)
{
    return &quot;Custom Tab&quot;;
}
static tm_tab_vt *custom_tab_vt;

static tm_tab_i *tab__create(tm_tab_create_context_t *context, tm_ui_o *ui)
{
    tm_allocator_i allocator = tm_allocator_api-&gt;create_child(context-&gt;allocator, &quot;Custom Tab&quot;);
    uint64_t *id = context-&gt;id;
    tm_tab_o *tab = tm_alloc(&amp;allocator, sizeof(tm_tab_o));
    *tab = (tm_tab_o) {
        .tm_tab_i = {
            .vt = custom_tab_vt,
            .inst = (tm_tab_o *)tab,
            .root_id = *id,
        },
        .allocator = allocator,
    };
    *id += 1000000;
    return &amp;tab-&gt;tm_tab_i;
}
static void tab__destroy(tm_tab_o *tab)
{
    tm_allocator_i a = tab-&gt;allocator;
    tm_free(&amp;a, tab, sizeof(*tab));
    tm_allocator_api-&gt;destroy_child(&amp;a);
}
static tm_tab_vt *custom_tab_vt = &amp;(tm_tab_vt) {
    .name = TM_CUSTOM_TAB_VT_NAME,
    .name_hash = TM_CUSTOM_TAB_VT_NAME_HASH,
    .create_menu_name = tab__create_menu_name,
    .create = tab__create,
    .destroy = tab__destroy,
    .title = tab__title,
    .ui = tab__ui
};
TM_DLL_EXPORT void tm_load_plugin(struct tm_api_registry_api *reg, bool load)
{
    tm_global_api_registry = reg;

    tm_draw2d_api = tm_get_api(reg, tm_draw2d_api);
    tm_ui_api = tm_get_api(reg, tm_ui_api);
    tm_allocator_api = tm_get_api(reg, tm_allocator_api);

    tm_add_or_remove_implementation(reg, load, tm_tab_vt, custom_tab_vt);
}

</code></pre>
<p>We modify the following parts of the sample:</p>
<ul>
<li><code>tab__create_menu_name</code> &amp; <code>tab__title</code> they shall return: <code>&quot;Text Tab&quot;</code></li>
<li>We remove the <code>TM_DLL_EXPORT void tm_load_plugin(struct tm_api_registry_api *reg, bool load)</code> function since we replace it in the next step.</li>
<li>To the <a href="https://ourmachinery.com/apidoc/plugins/ui/docking.h.html#tm_tab_o">tm_tab_o</a> we add: a pointer to the Truth and a asset entry:</li>
</ul>
<pre><code class="language-c">struct tm_tab_o
{
    tm_tab_i tm_tab_i;
    tm_allocator_i *allocator;

    tm_tt_id_t asset;
    tm_the_truth_o *tt;
};

</code></pre>
<p>The most important fields here are the <strong>asset</strong> and <strong>tt</strong> filed. They will store the currently used asset and truth. Those fields allow us to access both in various functions.</p>
<ul>
<li>
<p>We also change the defines to:</p>
<pre><code class="language-c">#define TM_TXT_TAB_VT_NAME &quot;tm_txt_tab&quot;
#define TM_TXT_TAB_VT_NAME_HASH TM_STATIC_HASH(&quot;tm_txt_tab&quot;, 0x2cd261be98a99bc3ULL)
</code></pre>
</li>
</ul>
<p>After those adjustments we continue with creating a new load function on the bottom of the file:</p>
<pre><code class="language-c">tm_global_api_registry = reg;

tm_ui_api = tm_get_api(reg, tm_ui_api);
tm_temp_allocator_api = tm_get_api(reg, tm_temp_allocator_api);

tm_add_or_remove_implementation(reg, load, tm_tab_vt, tab_vt);

</code></pre>
<p>In our main file the <code>txt.c</code> we need to add this function and call it:</p>
<pre><code class="language-c">extern void load_txt_tab(struct tm_api_registry_api *reg, bool load);

// -- load plugin
TM_DLL_EXPORT void tm_load_plugin(struct tm_api_registry_api *reg, bool load)
{
    load_txt_tab(reg, load);
}

</code></pre>
<h3 id="implementing-the-functions"><a class="header" href="#implementing-the-functions">Implementing the functions</a></h3>
<p>Now that we have done all the boilerplate code, let us focus on the three functions that count:</p>
<ul>
<li>The create function</li>
<li>The UI Update</li>
<li>The Set Root function</li>
</ul>
<h4 id="the-create-function"><a class="header" href="#the-create-function">The Create Function</a></h4>
<pre><code class="language-c">static const char *tab__create_menu_name(void)
{
    return &quot;Text Tab&quot;;
}

static const char *tab__title(tm_tab_o *tab, struct tm_ui_o *ui)
{
    return &quot;Text Tab&quot;;
}

static tm_tab_vt *tab_vt;

static tm_tab_i *tab__create(tm_tab_create_context_t *context, tm_ui_o *ui)
{
    tm_allocator_i *allocator = context-&gt;allocator;
    uint64_t *id = context-&gt;id;
    tm_tab_o *tab = tm_alloc(allocator, sizeof(tm_tab_o));
    *tab = (tm_tab_o) {
        .tm_tab_i = {
            .vt = (tm_tab_vt *)tab_vt,
            .inst = (tm_tab_o *)tab,
            .root_id = *id,
        },
        .allocator = allocator,
    };

    *id += 1000000;
    return &amp;tab-&gt;tm_tab_i;
}

</code></pre>
<p>In this function, we store the allocator first. </p>
<blockquote>
<p><strong>Tipp:</strong> if you wanted to create a child allocator, you could do this for your Tab. A child allocator may be very useful when doing many allocations: <code>tm_allocator_api.create_child()</code>.</p>
</blockquote>
<p>We need to initialize the tab interface so other engine parts can communicate with a generic interface to the Tab. We store a pointer to our Tab within this interface so other callers of the standard generic interface can access this instance and pass it along to the functions. After this, we allocate the Tab itself.</p>
<pre><code class="language-c">tm_tab_o *tab = tm_alloc(allocator, sizeof(tm_tab_o));
*tab = (tm_tab_o) {
    .tm_tab_i = {
        .vt = (tm_tab_vt *)tab_vt,
        .inst = (tm_tab_o *)tab,
        .root_id = *id,
    },
    .allocator = allocator,
};

</code></pre>
<p>In the end, we return the pointer to the interface, so the docking system has it</p>
<h4 id="the-update-function"><a class="header" href="#the-update-function">The Update Function</a></h4>
<pre><code class="language-c">static void tab__ui(tm_tab_o *tab, tm_ui_o *ui, const tm_ui_style_t *uistyle_in, tm_rect_t rect)
{
    tm_ui_style_t *uistyle = (tm_ui_style_t[]) { *uistyle_in };
    if (tab-&gt;asset.u64) {
        TM_INIT_TEMP_ALLOCATOR(ta);
        tm_tt_buffer_t buffer = tm_the_truth_api-&gt;get_buffer(tab-&gt;tt, tm_tt_read(tab-&gt;tt, tab-&gt;asset), TM_TT_PROP__MY_ASSET__DATA);
        char *content = tm_temp_alloc(ta, buffer.size + 1);
        tm_strncpy_safe(content, buffer.data, buffer.size);
        tm_ui_text_t *text = &amp;(tm_ui_text_t) { .text = content, .rect = rect };
        tm_ui_api-&gt;wrapped_text(ui, uistyle, text);
        TM_SHUTDOWN_TEMP_ALLOCATOR(ta);
    } else {
        rect.h = 20;
        tm_ui_text_t *text = &amp;(tm_ui_text_t) { .align = TM_UI_ALIGN_CENTER, .text = &quot;Please open a .txt asset.&quot;, .rect = rect };
        tm_ui_api-&gt;text(ui, uistyle, text);
    }
}

</code></pre>
<p>At first, we create a copy of the UI Style. With this copy, we can do what we want since the input style is a const pointer. After this, we check if the asset is present. If not, we print a message on the Tab that the user must select a <code>txt</code> asset.</p>
<pre><code class="language-c">static void tab__ui(tm_tab_o *tab, tm_ui_o *ui, const tm_ui_style_t *uistyle_in, tm_rect_t rect)
{
    tm_ui_style_t *uistyle = (tm_ui_style_t[]) { *uistyle_in };
    if (tab-&gt;asset.u64) {
    } else {
        rect.h = 20;
        tm_ui_text_t *text = &amp;(tm_ui_text_t) { .align = TM_UI_ALIGN_CENTER, .text = &quot;Please open a .txt asset.&quot;, .rect = rect };
        tm_ui_api-&gt;text(ui, uistyle, text);
    }
}

</code></pre>
<p>We need an allocator to copy the data of the buffer into a proper string. The allocator is needed since we never added a null terminator to the end of the string when we save it into the buffer.</p>
<p>In this case, we need a temporary allocator. Since we do not want to keep the memory forever, we need to initialize a temp allocator with <a href="https://ourmachinery.com/apidoc/foundation/temp_allocator.h.html#tm_init_temp_allocator()">TM_INIT_TEMP_ALLOCATOR</a> and provide a name. Do not forget to free the memory at the end. </p>
<pre><code class="language-c">static void tab__ui(tm_tab_o *tab, tm_ui_o *ui, const tm_ui_style_t *uistyle_in, tm_rect_t rect)
{
    tm_ui_style_t *uistyle = (tm_ui_style_t[]) { *uistyle_in };
    if (tab-&gt;asset.u64) {
        TM_INIT_TEMP_ALLOCATOR(ta);
        TM_SHUTDOWN_TEMP_ALLOCATOR(ta);
    } else {
        rect.h = 20;
        tm_ui_text_t *text = &amp;(tm_ui_text_t) { .align = TM_UI_ALIGN_CENTER, .text = &quot;Please open a .txt asset.&quot;, .rect = rect };
        tm_ui_api-&gt;text(ui, uistyle, text);
    }
}


</code></pre>
<blockquote>
<p><strong>Note:</strong> If the memory is smaller than 1024 bytes, the memory is allocated to the stack. Moreover, an alternative is the frame allocator in which the memory is freed every frame.</p>
</blockquote>
<p>The next step is it to ask the truth for the buffer and allocate the right amount of memory. Since we want to copy the data into a null-terminated string, we should add 1 to the data size.</p>
<pre><code class="language-c">tm_tt_buffer_t buffer = tm_the_truth_api-&gt;get_buffer(tab-&gt;tt, tm_tt_read(tab-&gt;tt, tab-&gt;asset), TM_TT_PROP__MY_ASSET__DATA);
char *content = tm_temp_alloc(ta, buffer.size + 1);
tm_strncpy_safe(content, buffer.data, buffer.size);

</code></pre>
<p>To ensure our string is clean and filled with nulls, we use the inline string file (hence we add the <code>foundation/string.inl</code> to our includes). We have the <a href="https://ourmachinery.com/apidoc/foundation/string.inl.html#tm_strncpy_safe()">tm_strncpy_safe</a> within this header file, which fills up a string with null terminator.</p>
<pre><code class="language-c">tm_strncpy_safe(content, buffer.data, buffer.size);

</code></pre>
<p>The last step before we are done is actually to make the text appear on the screen. We make use of the <code>tm_ui_api.wrapped_text()</code> since this function will print the string in multiple lines if need be.</p>
<pre><code class="language-c">tm_ui_text_t *text = &amp;(tm_ui_text_t) { .text = content, .rect = rect };
tm_ui_api-&gt;wrapped_text(ui, uistyle, text);

</code></pre>
<h4 id="the-set-root--root-function"><a class="header" href="#the-set-root--root-function">The set root / root function</a></h4>
<p>The last function which we need is the set root function. This function allows us to set a root object of the Tab from the outside. Its code is quite straightforward:</p>
<pre><code class="language-c">{{insert_code(env.TM_BOOK_CODE_SNIPPETS/custom_assets/open_asset/tab.c,root}}
</code></pre>
<blockquote>
<p><strong>Note</strong>: The root function is also called when ever the current &quot;main&quot; Truth changes. This can be used to swap the truth.</p>
</blockquote>
<h3 id="let-us-test-the-tab"><a class="header" href="#let-us-test-the-tab">Let us test the Tab</a></h3>
<p>Let us open the Tab from the <strong>Tabs</strong> menu!</p>
<p>[image]</p>
<h3 id="source-code"><a class="header" href="#source-code">Source Code</a></h3>
<pre><code class="language-c">static struct tm_api_registry_api *tm_global_api_registry;

static struct tm_ui_api *tm_ui_api;
static struct tm_temp_allocator_api *tm_temp_allocator_api;

extern struct tm_the_truth_api *tm_the_truth_api;
static struct tm_localizer_api *tm_localizer_api;

#include &lt;foundation/allocator.h&gt;
#include &lt;foundation/api_registry.h&gt;
#include &lt;foundation/string.inl&gt;
#include &lt;foundation/temp_allocator.h&gt;
#include &lt;foundation/the_truth.h&gt;

#include &lt;plugins/ui/docking.h&gt;
#include &lt;plugins/ui/ui.h&gt;

#include &lt;the_machinery/the_machinery_tab.h&gt;

#include &quot;txt.h&quot;

struct tm_tab_o
{
    tm_tab_i tm_tab_i;
    tm_allocator_i *allocator;

    tm_tt_id_t asset;
    tm_the_truth_o *tt;
};
static void tab__ui(tm_tab_o *tab, tm_ui_o *ui, const tm_ui_style_t *uistyle_in, tm_rect_t rect)
{
    tm_ui_style_t *uistyle = (tm_ui_style_t[]) { *uistyle_in };
    if (tab-&gt;asset.u64) {
        TM_INIT_TEMP_ALLOCATOR(ta);
        tm_tt_buffer_t buffer = tm_the_truth_api-&gt;get_buffer(tab-&gt;tt, tm_tt_read(tab-&gt;tt, tab-&gt;asset), TM_TT_PROP__MY_ASSET__DATA);
        char *content = tm_temp_alloc(ta, buffer.size + 1);
        tm_strncpy_safe(content, buffer.data, buffer.size);
        tm_ui_text_t *text = &amp;(tm_ui_text_t) { .text = content, .rect = rect };
        tm_ui_api-&gt;wrapped_text(ui, uistyle, text);
        TM_SHUTDOWN_TEMP_ALLOCATOR(ta);
    } else {
        rect.h = 20;
        tm_ui_text_t *text = &amp;(tm_ui_text_t) { .align = TM_UI_ALIGN_CENTER, .text = &quot;Please open a .txt asset.&quot;, .rect = rect };
        tm_ui_api-&gt;text(ui, uistyle, text);
    }
}
static const char *tab__create_menu_name(void)
{
    return &quot;Text Tab&quot;;
}

static const char *tab__title(tm_tab_o *tab, struct tm_ui_o *ui)
{
    return &quot;Text Tab&quot;;
}

static tm_tab_vt *tab_vt;

static tm_tab_i *tab__create(tm_tab_create_context_t *context, tm_ui_o *ui)
{
    tm_allocator_i *allocator = context-&gt;allocator;
    uint64_t *id = context-&gt;id;
    tm_tab_o *tab = tm_alloc(allocator, sizeof(tm_tab_o));
    *tab = (tm_tab_o) {
        .tm_tab_i = {
            .vt = (tm_tab_vt *)tab_vt,
            .inst = (tm_tab_o *)tab,
            .root_id = *id,
        },
        .allocator = allocator,
    };

    *id += 1000000;
    return &amp;tab-&gt;tm_tab_i;
}

static void tab__destroy(tm_tab_o *tab)
{
    tm_free(tab-&gt;allocator, tab, sizeof(*tab));
}
void tab__set_root(tm_tab_o *inst, struct tm_the_truth_o *tt, tm_tt_id_t root)
{
    inst-&gt;asset = root;
    inst-&gt;tt = tt;
}

static tm_tab_vt_root_t tab__root(tm_tab_o *tab)
{
    return (tm_tab_vt_root_t) { tab-&gt;tt, tab-&gt;asset };
}

static tm_tab_vt *tab_vt = &amp;(tm_tab_vt) {
    .name = TM_TXT_TAB_VT_NAME,
    .name_hash = TM_TXT_TAB_VT_NAME_HASH,
    .create_menu_name = tab__create_menu_name,
    .create = tab__create,
    .destroy = tab__destroy,
    .title = tab__title,
    .ui = tab__ui,
    .set_root = tab__set_root,
    .root = tab__root,
};

void load_txt_tab(struct tm_api_registry_api *reg, bool load)
{
    tm_global_api_registry = reg;

    tm_ui_api = tm_get_api(reg, tm_ui_api);
    tm_temp_allocator_api = tm_get_api(reg, tm_temp_allocator_api);

    tm_add_or_remove_implementation(reg, load, tm_tab_vt, tab_vt);
}
</code></pre>
<h2 id="open-the-tab"><a class="header" href="#open-the-tab">Open the Tab</a></h2>
<p>After all the previous steps, we can finally make our Text Asset open this Tab!</p>
<p>At first, we need to remove the static of our truth API since we require it in the <code>txt_tab.c</code>.</p>
<pre><code class="language-c">struct tm_the_truth_api *tm_the_truth_api;
</code></pre>
<p>When that is done, we need to include two more files and get two  more APIs.</p>
<pre><code class="language-c">// open asset
static struct tm_the_machinery_api* tm_the_machinery_api;
static struct tm_docking_api* tm_docking_api;
//...

extern void load_txt_tab(struct tm_api_registry_api *reg, bool load);

// -- load plugin
TM_DLL_EXPORT void tm_load_plugin(struct tm_api_registry_api *reg, bool load)
{
    tm_the_truth_api = tm_get_api(reg, tm_the_truth_api);
    tm_properties_view_api = tm_get_api(reg, tm_properties_view_api);
    tm_os_api = tm_get_api(reg, tm_os_api);
    tm_path_api = tm_get_api(reg, tm_path_api);
    tm_temp_allocator_api = tm_get_api(reg, tm_temp_allocator_api);
    tm_allocator_api = tm_get_api(reg, tm_allocator_api);
    tm_logger_api = tm_get_api(reg, tm_logger_api);
    tm_localizer_api = tm_get_api(reg, tm_localizer_api);
    tm_asset_io_api = tm_get_api(reg, tm_asset_io_api);
    task_system = tm_get_api(reg, tm_task_system_api);
    tm_sprintf_api = tm_get_api(reg, tm_sprintf_api);
    tm_entity_api = tm_get_api(reg, tm_entity_api);
    tm_scene_common_api = tm_get_api(reg, tm_scene_common_api);
    tm_global_api_registry = reg;
    if (load)
        tm_asset_io_api-&gt;add_asset_io(&amp;txt_asset_io);
    else
        tm_asset_io_api-&gt;remove_asset_io(&amp;txt_asset_io);

    // loads the txt tab!
    tm_the_machinery_api = tm_get_api(reg, tm_the_machinery_api);
    tm_docking_api = tm_get_api(reg, tm_docking_api);
    load_txt_tab(reg, load);
    tm_add_or_remove_implementation(reg, load, tm_entity_create_component_i, component__create);
    tm_add_or_remove_implementation(reg, load, tm_the_truth_create_types_i, create_truth_types);
    tm_add_or_remove_implementation(reg, load, tm_asset_browser_create_asset_i, &amp;asset_browser_create_my_asset);
}

</code></pre>
<p>To open an asset, we need to add another aspect to our type. It is the <code>TM_TT_ASPECT__ASSET_OPEN</code> aspect! This aspect requires a implementation of the <a href="https://ourmachinery.com/apidoc/plugins/the_machinery_shared/asset_aspects.h.html#structtm_asset_open_aspect_i">tm_asset_open_aspect_i</a>. </p>
<pre><code class="language-c">// -- create truth type
static void create_truth_types(struct tm_the_truth_o *tt)
{
    tm_the_truth_api-&gt;set_aspect(tt, type, TM_TT_ASPECT__ASSET_OPEN, open_i);
}

</code></pre>
<p>We add this implementation of the <a href="https://ourmachinery.com/apidoc/plugins/the_machinery_shared/asset_aspects.h.html#structtm_asset_open_aspect_i">tm_asset_open_aspect_i</a> above the <code>create_truth_types</code> function.</p>
<pre><code class="language-c">void open_asset(struct tm_application_o *app, struct tm_ui_o *ui, struct tm_tab_i *from_tab,
    tm_the_truth_o *tt, tm_tt_id_t asset, enum tm_asset_open_mode open_mode)
{
    const tm_docking_find_tab_opt_t opt = {
        .from_tab = from_tab,
        .in_ui = ui,
        .exclude_pinned = true,
    };
    const bool pin = open_mode == TM_ASSET_OPEN_MODE_CREATE_TAB_AND_PIN;
    tm_tab_i *tab = tm_the_machinery_api-&gt;create_or_select_tab(app, ui, TM_TXT_TAB_VT_NAME, &amp;opt);
    if (pin)
        tm_docking_api-&gt;pin_object(tab, tt, asset);
    else
        tab-&gt;vt-&gt;set_root(tab-&gt;inst, tt, asset);
}

static tm_asset_open_aspect_i *open_i = &amp;(tm_asset_open_aspect_i) {
    .open = open_asset,
};

</code></pre>
<p>The open function gives us all the important information:</p>
<ol>
<li>The App data</li>
<li>The UI</li>
<li>Which Tab requested this action</li>
<li>The current Truth</li>
<li>the asset</li>
<li>How we will open the Tab.</li>
</ol>
<p>At first, we define the search criteria for the <code>create_or_select_tab</code> of the Machinery API. In this case we want to exclude pinned tabs since the user might have a reason for why they are pinned!</p>
<pre><code class="language-c">tm_tab_i *tab = tm_the_machinery_api-&gt;create_or_select_tab(app, ui, TM_TXT_TAB_VT_NAME, &amp;opt);

</code></pre>
<p>Now we can create or select a tab by calling the <code>create_or_select_tab</code> function.</p>
<pre><code class="language-c">const tm_docking_find_tab_opt_t opt = {
    .from_tab = from_tab,
    .in_ui = ui,
    .exclude_pinned = true,
};

</code></pre>
<p>The last step is actually to pass some data along! In this case, we need to check if something is pinned or not! Hence we check if the <code>open_mode</code> is equal to pinning. If yes, we ask the docking API to pin our Tab.</p>
<pre><code class="language-c">const bool pin = open_mode == TM_ASSET_OPEN_MODE_CREATE_TAB_AND_PIN;
//...
if (pin)
    tm_docking_api-&gt;pin_object(tab, tt, asset);
else
    tab-&gt;vt-&gt;set_root(tab-&gt;inst, tt, asset);

</code></pre>
<h3 id="contributors"><a class="header" href="#contributors">Contributors</a></h3>
<p><a href="mailto:simon@ourmachinery.com"><img src="https://www.gravatar.com/avatar/b83de4c1812480cc09310470ca2949a9?s=32" alt="Simon Renger" /> Simon Renger</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="../the_truth/drag_and_drop.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="../gameplay_coding/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="../the_truth/drag_and_drop.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="../gameplay_coding/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        
    </body>
</html>
