<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Part 3 - Custom Importer - The Machinery Tutorial Book</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="../../favicon.svg">
                        <link rel="shortcut icon" href="../../favicon.png">
                <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
                <link rel="stylesheet" href="../../css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="../../fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="../../index.html"><strong aria-hidden="true">1.</strong> Welcome</a></li><li class="chapter-item "><a href="../../workflows/how_to_create_prototypes.html"><strong aria-hidden="true">2.</strong> How to create prototypes</a></li><li class="chapter-item "><a href="../../workflows/how_to_instantiate_prototypes.html"><strong aria-hidden="true">3.</strong> How to instantiate prototypes</a></li><li class="chapter-item "><a href="../../creation_graph/index.html"><strong aria-hidden="true">4.</strong> Creation Graph</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../creation_graph/custom_gpu_nodes.html"><strong aria-hidden="true">4.1.</strong> Creating custom GPU nodes</a></li><li class="chapter-item "><a href="../../creation_graph/custom_cpu_nodes.html"><strong aria-hidden="true">4.2.</strong> Creating custom CPU nodes</a></li><li class="chapter-item "><a href="../../creation_graph/from_code.html"><strong aria-hidden="true">4.3.</strong> Calling Creation Graphs from code</a></li><li class="chapter-item "><a href="../../creation_graph/raymarch_output_node.html"><strong aria-hidden="true">4.4.</strong> Creating a custom raymarching output node</a></li></ol></li><li class="chapter-item "><a href="../../post_processing/index.html"><strong aria-hidden="true">5.</strong> Post Processing</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../post_processing/aa.html"><strong aria-hidden="true">5.1.</strong> Anti-Aliasing</a></li><li class="chapter-item "><a href="../../post_processing/exposure.html"><strong aria-hidden="true">5.2.</strong> Exposure</a></li><li class="chapter-item "><a href="../../post_processing/color_grading.html"><strong aria-hidden="true">5.3.</strong> Color Grading</a></li></ol></li><li class="chapter-item "><a href="../../physics/index.html"><strong aria-hidden="true">6.</strong> Physics</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../physics/triggers.html"><strong aria-hidden="true">6.1.</strong> Triggers</a></li></ol></li><li class="chapter-item expanded "><a href="../../the_truth/index.html"><strong aria-hidden="true">7.</strong> The Truth</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../the_truth/custom_asset/index.html"><strong aria-hidden="true">7.1.</strong> Creating a custom asset</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../the_truth/custom_asset/part1.html"><strong aria-hidden="true">7.1.1.</strong> Part 1 - Create an Asset Truth Type, Addable via Asset Browser</a></li><li class="chapter-item "><a href="../../the_truth/custom_asset/part2.html"><strong aria-hidden="true">7.1.2.</strong> Part 2 - Custom UI</a></li><li class="chapter-item expanded "><a href="../../the_truth/custom_asset/part3.html" class="active"><strong aria-hidden="true">7.1.3.</strong> Part 3 - Custom Importer</a></li></ol></li><li class="chapter-item "><a href="../../the_truth/drag_and_drop.html"><strong aria-hidden="true">7.2.</strong> Adding Drag and Drop to Assets</a></li><li class="chapter-item "><a href="../../the_truth/open_asset.html"><strong aria-hidden="true">7.3.</strong> Open Asset in Tab</a></li></ol></li><li class="chapter-item "><a href="../../gameplay_coding/index.html"><strong aria-hidden="true">8.</strong> Gameplay Coding</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../gameplay_coding/extend_the_visual_scripting_language.html"><strong aria-hidden="true">8.1.</strong> Extending the Visual Scripting Language</a></li></ol></li><li class="chapter-item "><a href="../../ui/index.html"><strong aria-hidden="true">9.</strong> UI</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../ui/build_custom_ui_controls/index.html"><strong aria-hidden="true">9.1.</strong> Build Custom UI Controls</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../ui/build_custom_ui_controls/part1.html"><strong aria-hidden="true">9.1.1.</strong> Part 1</a></li></ol></li><li class="chapter-item "><a href="../../ui/toolbars-overlays.html"><strong aria-hidden="true">9.2.</strong> Toolbars and Overlays</a></li><li class="chapter-item "><a href="../../ui/custom_layouts.html"><strong aria-hidden="true">9.3.</strong> Custom Tab Layouts</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">The Machinery Tutorial Book</h1>

                    <div class="right-buttons">
                                                <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/OurMachinery/themachinery-books" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="create-a-custom-asset-part-3"><a class="header" href="#create-a-custom-asset-part-3">Create a custom asset part 3</a></h1>
<p>This walkthrough shows you how to add a custom asset to the Engine. You should have basic knowledge about how to write a custom plugin. If not, you might want to check this <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/extending_the_machinery/the_plugin_system.html">Guide</a>. The goal for this walkthrough is to write a text file asset.</p>
<p>This part will cover the following topics:</p>
<ul>
<li>How to write an importer</li>
</ul>
<blockquote>
<p>You can find the whole source code in its git repo: <a href="https://github.com/simon-ourmachinery/example-text-file-asset">example-text-file-asset</a></p>
</blockquote>
<p><strong>Table of Content</strong></p>
<ul>
<li><a href="#custom-importer-for-text-files">Custom importer for text files</a></li>
<li><a href="#import-task-set-up">Import Task set up</a></li>
<li><a href="#import-task-implementation">Import task implementation</a></li>
<li><a href="#enabling-reimport">Enabling reimport</a></li>
<li><a href="#refactor-the-custom-ui-import-functionality">Refactor the Custom UI import functionality</a></li>
<li><a href="#the-end">The end</a>
<ul>
<li><a href="#full-example-of-basic-asset">Full example of basic asset</a></li>
</ul>
</li>
</ul>
<h2 id="custom-importer-for-text-files"><a class="header" href="#custom-importer-for-text-files">Custom importer for text files</a></h2>
<p>In this part, we are adding the ability to import a text file into the Engine. To implement an importer, we need the following APIs:</p>
<table><thead><tr><th><strong>Name</strong></th><th><strong>header file</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>tm_asset_io_api</td><td>foundation/asset_io.h</td><td>This api provides us with the interface for the actual importer.</td></tr>
<tr><td>tm_temp_allocator_api</td><td>foundation/temp_allocator.h</td><td>Provides a easy way to allocate temporary memory.</td></tr>
<tr><td>tm_allocator_api</td><td>foundation/allocator.h</td><td>Allows us access to different kind of allocators. For example to the system allocator. We need this one later when we rewrite our reimport.</td></tr>
<tr><td>tm_path_api</td><td>foundation/path.h</td><td>Allows us to split a path.</td></tr>
<tr><td>tm_api_registry_api</td><td>foundation/api_registry.h</td><td>Allows us to retrive a API from the registry.</td></tr>
<tr><td>tm_task_system_api</td><td>foundation/task_system.h</td><td>Allowes us to spawm tasks</td></tr>
</tbody></table>
<p>After we have included all the needed header files and retrieved all the APIs from the registry, we can start to write an importer.</p>
<blockquote>
<p>Note: <a href="https://ourmachinery.com/apidoc/foundation/api_registry.h.html#structtm_api_registry_api">tm_api_registry_api</a> can be retrived from the reg parameter in the <code>tm_load_plugin</code> function. <code>tm_global_api_registry = reg;</code></p>
</blockquote>
<p>The Machinery has a generic interface for asset importers. It requires a bunch of functions to be able to work as intended. The struct we need to implement is called <a href="https://ourmachinery.com/apidoc/foundation/asset_io.h.html#structtm_asset_io_import">tm_asset_io_i</a>. It requires us to set the following members:</p>
<table><thead><tr><th>Member</th><th>Description</th></tr></thead><tbody>
<tr><td>enabled</td><td>A function ptr that returns a bool. If the return value is true the importer is active.</td></tr>
<tr><td>can_import</td><td>A function ptr that returns <code>true</code> if this asset IO interface can import archives with the file extension <code>extension</code>. This can be achieved by comparing the file extesions.<br><br>Optional, if not implemented, nothing can be imported.</td></tr>
<tr><td>can_reimport</td><td>A function ptr that returns <code>true</code> if this asset IO interface can re-import the specified truth asset (of type <code>TM_TT_TYPE_ASSET</code>). Optional, if not implemented, nothing can be re-importe</td></tr>
<tr><td>importer_extensions_string</td><td>A function ptr that shall append the correct file extention string to the list of possible file extenstions</td></tr>
<tr><td>importer_description_string</td><td>A function ptr that shall append the correct file extention descriptions string to the list of possible file extenstions descriptions.</td></tr>
<tr><td>import_asset</td><td>The actual function that starts a import task. If non-zero, the return value is the ID of the background task from <a href="https://ourmachinery.com/apidoc/foundation/task_system.h.html#structtm_task_system_api">tm_task_system_api</a> that does the import.</td></tr>
</tbody></table>
<p>All these members expect a function pointer. Therefore, we need to provide the functionality.</p>
<p>To implement the first functions, we need to do the following steps:</p>
<pre><code class="language-c">//... other includes
#include &lt;foundation/carray_print.inl&gt;
#include &lt;foundation/string.inl&gt;
#include &lt;foundation/localizer.h&gt;
//... other code
static bool asset_io__enabled(struct tm_asset_io_o *inst)
{
    return true;
}
static bool asset_io__can_import(struct tm_asset_io_o *inst, const char *extension)
{
    return tm_strcmp_ignore_case(extension, &quot;txt&quot;) == 0;
}
static bool asset_io__can_reimport(struct tm_asset_io_o *inst, struct tm_the_truth_o *tt, tm_tt_id_t asset)
{
    const tm_tt_id_t object = tm_the_truth_api-&gt;get_subobject(tt, tm_tt_read(tt, asset), TM_TT_PROP__ASSET__OBJECT);
    return object.type == tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__MY_ASSET).u64;
}
static void asset_io__importer_extensions_string(struct tm_asset_io_o *inst, char **output, struct tm_temp_allocator_i *ta, const char *separator)
{
    tm_carray_temp_printf(output, ta, &quot;txt&quot;);
}
static void asset_io__importer_description_string(struct tm_asset_io_o *inst, char **output, struct tm_temp_allocator_i *ta, const char *separator)
{
    tm_carray_temp_printf(output, ta, &quot;.txt&quot;);
}
</code></pre>
<p>Let us go through them:</p>
<ul>
<li>The <code>enabled</code> function returns true because we want the importer to work. </li>
<li>The <code>asset_io__can_import</code> will compare the given extension with the one we want to support.</li>
</ul>
<blockquote>
<p>Note: <a href="https://ourmachinery.com/apidoc/foundation/string.inl.html#tm_strcmp_ignore_case()">tm_strcmp_ignore_case</a> requires a localizer. That is why we need the localizer API and the localizer header file. It is not needed if the importer shall be case-sensitive.</p>
</blockquote>
<ul>
<li>The <code>asset_io__can_reimport</code> compares the object type of the given object with the object of our type. </li>
</ul>
<blockquote>
<p><a href="https://ourmachinery.com/apidoc/foundation/the_truth_assets.h.html#enumtm_tt_prop__asset">TM_TT_PROP__ASSET__OBJECT</a> is the property of the <a href="https://ourmachinery.com/apidoc/foundation/the_truth_assets.h.html#tm_tt_type__asset">TM_TT_TYPE__ASSET</a> type which holds the object associated with the asset.</p>
</blockquote>
<p>The last two functions will append the file extension <code>.txt</code> to the file extensions and description. Note that the argument output is a <a href="https://ourmachinery.com/apidoc/foundation/carray.inl.html#carray.inl">carray</a>. That is why we can use the <a href="https://ourmachinery.com/apidoc/foundation/carray_print.inl.html#tm_carray_temp_printf()">tm_carray_temp_printf</a> function.</p>
<blockquote>
<p>Note: The <code>carray_print.h</code> requires the <a href="https://ourmachinery.com/apidoc/foundation/sprintf.h.html#structtm_sprintf_api">tm_sprintf_api</a>. Therefore, we need to include the right header here.</p>
</blockquote>
<h2 id="import-task-set-up"><a class="header" href="#import-task-set-up">Import Task set up</a></h2>
<p>The importer function <code>asset_io__import_asset</code> can spawn a task with the task system and pass through the needed information. We need to create a data structure to hold all our data.</p>
<p><em>What data does our task need?</em> </p>
<p>This task needs to know where to find the file. Moreover it needs to access some essential types such as the Truth and allocator. The struct could look like this:</p>
<pre><code class="language-c">struct task__import_txt
{
    uint64_t bytes;
    struct tm_asset_io_import args;
    char file[8];
};
</code></pre>
<p>The <code>asset_io</code> header has a nice utility struct predefined the <a href="https://ourmachinery.com/apidoc/foundation/asset_io.h.html#structtm_asset_io_import">tm_asset_io_import</a>. When an asset is being imported the caller of the  <code>asset_io__import_asset()</code> will hand through all the needed details: </p>
<ul>
<li>The right Truth object</li>
<li>the correct allocator. </li>
</ul>
<p>The function itself looks like this:</p>
<pre><code class="language-c">static uint64_t asset_io__import_asset(struct tm_asset_io_o *inst, const char *file, const struct tm_asset_io_import *args)
{
    const uint64_t bytes = sizeof(struct task__import_txt) + strlen(file);
    struct task__import_txt *task = tm_alloc(args-&gt;allocator, bytes);
    *task = (struct task__import_txt){
        .bytes = bytes,
        .args = *args,
    };
    strcpy(task-&gt;file, file);
    return task_system-&gt;run_task(task__import_txt, task, &quot;Import Text File&quot;);
}
</code></pre>
<blockquote>
<p><strong>Important</strong>: The task is the memory owner and needs to clean it up at the end of the execution!</p>
</blockquote>
<p>This line <code>task_system-&gt;run_task(task__import_txt, task, &quot;Import Text File&quot;);</code> will run a task and return its id. The actual task is the function <code>task__import_txt()</code>. </p>
<blockquote>
<p>Info: For more information on the task system check the <a href="https://ourmachinery.com/apidoc/foundation/task_system.h.html#structtm_task_system_api.run_task()">documentation</a>.</p>
</blockquote>
<h2 id="import-task-implementation"><a class="header" href="#import-task-implementation">Import task implementation</a></h2>
<p>The import task has the function to import data and clean up afterward.</p>
<p>It may look like this:</p>
<pre><code class="language-c">static void task__import_txt(void *data, uint64_t task_id)
{
// all our work
}
</code></pre>
<p>The data <code>ptr</code> needs to be cast into our defined data type: <code>task__import_txt</code>. You could use the task id to update its progress. We do not need to do it in this example.</p>
<blockquote>
<p>For more information on how to update the status of a task. It will be shown in the editor check out the <a href="https://ourmachinery.com/apidoc/foundation/progress_report.h.html#structtm_progress_report_api">documentation</a>.</p>
</blockquote>
<p>We are left with the following steps:</p>
<ul>
<li>Implement the actual importing (similar to the previous chapter).</li>
<li>Implement the reimport.</li>
</ul>
<p>First, we need to retrieve the basic information from the task data:</p>
<pre><code class="language-c">static void task__import_txt(void *data, uint64_t task_id)
{
    struct task__import_txt *task = (struct task__import_txt *)data;
    const struct tm_asset_io_import *args = &amp;task-&gt;args;
    const char *txt_file = task-&gt;file;
    tm_the_truth_o *tt = args-&gt;tt;
//.. more
}
</code></pre>
<p>After that, we implement the same code as in the previous chapter. We need to open the file, allocate a buffer and add the buffer to the object, either a new one (import) or an existing one (reimport).</p>
<p><strong>An important note is to do this time error checking</strong>: </p>
<ul>
<li>Does the file exist? </li>
<li>Does the file size match with the read file? </li>
</ul>
<p>To ask those questions is vital because we are in the async territory. In case of an error, we want to inform the user. Therefore, we need to get the logging API (<code>tm_logger_api = reg-&gt;get(TM_LOGGER_API_NAME);</code>) as well. You can find it in the <code>foundation/log.h</code> file.</p>
<p>The subsequent step is to check if the file exists. You can do this through the filesystem API:</p>
<pre><code class="language-c">static void task__import_txt(void *data, uint64_t task_id)
{
    struct task__import_txt *task = (struct task__import_txt *)data;
    const struct tm_asset_io_import *args = &amp;task-&gt;args;
    const char *txt_file = task-&gt;file;
    tm_the_truth_o *tt = args-&gt;tt;
    tm_file_stat_t stat = tm_os_api-&gt;file_system-&gt;stat(txt_file);
    if (stat.exists)
    {
    // .. code
    else
    {
        tm_logger_api-&gt;printf(TM_LOG_TYPE_INFO, &quot;import txt:cound not find %s \n&quot;, txt_file);
    }
}
</code></pre>
<p>Now we combine all the knowledge from this chapter and the previous chapter. We need to create a new asset via code for the import, and for the reimport, we need to update an existing file. 
Before we do all of this, let us first read the file and create the buffer.</p>
<pre><code class="language-c">static void task__import_txt(void *data, uint64_t task_id)
{
    struct task__import_txt *task = (struct task__import_txt *)data;
    const struct tm_asset_io_import *args = &amp;task-&gt;args;
    const char *txt_file = task-&gt;file;
    tm_the_truth_o *tt = args-&gt;tt;
    tm_file_stat_t stat = tm_os_api-&gt;file_system-&gt;stat(txt_file);
    if (stat.exists)
    {
        tm_buffers_i *buffers = tm_the_truth_api-&gt;buffers(tt);
        void *buffer = buffers-&gt;allocate(buffers-&gt;inst, stat.size, false);
        tm_file_o f = tm_os_api-&gt;file_io-&gt;open_input(txt_file);
        const int64_t read = tm_os_api-&gt;file_io-&gt;read(f, buffer, stat.size);
        tm_os_api-&gt;file_io-&gt;close(f);
// ..code
    else
    {
        tm_logger_api-&gt;printf(TM_LOG_TYPE_INFO, &quot;import txt:cound not find %s \n&quot;, txt_file);
    }
}
</code></pre>
<p>After this, we should ensure that the file size matches the size of the read data.</p>
<pre><code class="language-c">static void task__import_txt(void *data, uint64_t task_id)
{
    struct task__import_txt *task = (struct task__import_txt *)data;
    const struct tm_asset_io_import *args = &amp;task-&gt;args;
    const char *txt_file = task-&gt;file;
    tm_the_truth_o *tt = args-&gt;tt;
    tm_file_stat_t stat = tm_os_api-&gt;file_system-&gt;stat(txt_file);
    if (stat.exists)
    {
        tm_buffers_i *buffers = tm_the_truth_api-&gt;buffers(tt);
        void *buffer = buffers-&gt;allocate(buffers-&gt;inst, stat.size, false);
        tm_file_o f = tm_os_api-&gt;file_io-&gt;open_input(txt_file);
        const int64_t read = tm_os_api-&gt;file_io-&gt;read(f, buffer, stat.size);
        tm_os_api-&gt;file_io-&gt;close(f);
        if (read == (int64_t)stat.size)
//..
        }
        else
        {
            tm_logger_api-&gt;printf(TM_LOG_TYPE_INFO, &quot;import txt:cound not read %s\n&quot;, txt_file);
        }
    else
    {
        tm_logger_api-&gt;printf(TM_LOG_TYPE_INFO, &quot;import txt:cound not find %s \n&quot;, txt_file);
    }
}
</code></pre>
<p>With this out of the way, we can use our knowledge from the last part.</p>
<ul>
<li>How to add an asset via code.</li>
</ul>
<p>The first step was to create the new object and add the data to it.</p>
<pre><code class="language-c">            const uint32_t buffer_id = buffers-&gt;add(buffers-&gt;inst, buffer, stat.size, 0);
            const tm_tt_type_t plugin_asset_type = tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__MY_ASSET);
            const tm_tt_id_t asset_id = tm_the_truth_api-&gt;create_object_of_type(tt, plugin_asset_type, TM_TT_NO_UNDO_SCOPE);
            tm_the_truth_object_o *asset_obj = tm_the_truth_api-&gt;write(tt, asset_id);
            tm_the_truth_api-&gt;set_buffer(tt, asset_obj, TM_TT_PROP__MY_ASSET__DATA, buffer_id);
            tm_the_truth_api-&gt;set_string(tt, asset_obj, TM_TT_PROP__MY_ASSET__FILE, txt_file);
                tm_the_truth_api-&gt;commit(tt, asset_obj, args-&gt;undo_scope);
</code></pre>
<p>After that, we are using the <a href="https://ourmachinery.com/apidoc/plugins/editor_views/asset_browser.h.html#structtm_asset_browser_add_asset_api">tm_asset_browser_add_asset_api</a> to add the asset to the asset browser. </p>
<pre><code class="language-c">                struct tm_asset_browser_add_asset_api *add_asset = tm_get_api(tm_global_api_registry, tm_asset_browser_add_asset_api);
</code></pre>
<p>We are getting the API first, because we do not need it anywhere else than in this case. Then we need to extract the file name of the imported file. You can do this with the <em>path API</em>'s <code> tm_path_api-&gt;base()</code> function. Be aware this function requires a <a href="https://ourmachinery.com/apidoc/foundation/api_types.h.html#structtm_str_t">tm_str_t</a> which you an create from a normal c string (<code>const char*</code>) via <code>tm_str()</code>. To access the underlaying c string again just call <code>.data</code> on the <a href="https://ourmachinery.com/apidoc/foundation/api_types.h.html#structtm_str_t">tm_str_t</a>.</p>
<blockquote>
<p>Used to represent a string slice with pointer and length.</p>
<p>This lets you reason about parts of a string, which you are not able to do with standard NULL-terminated strings.</p>
<p><a href="https://ourmachinery.com/apidoc/foundation/api_types.h.html#structtm_str_t">documentation</a></p>
</blockquote>
<p>After this step we need to get the current folder. Therefore we are asking the <a href="https://ourmachinery.com/apidoc/plugins/editor_views/asset_browser.h.html#structtm_asset_browser_add_asset_api">tm_asset_browser_add_asset_api</a> what the current folder is. Then we decide if want to select the file. At the end we are calling add function of the <code>tm_asset_browser_add_asset_api-&gt;add()</code>. </p>
<blockquote>
<p><strong>Note:</strong> We do not have any asset labels for our current asset therefore we do not pass them to the add function, otherwise the last 2 arguments would be different than <code>0</code> and <code>0</code>.</p>
</blockquote>
<pre><code class="language-c">                const char *asset_name = tm_path_api-&gt;base(tm_str(txt_file)).data;
                struct tm_asset_browser_add_asset_api *add_asset = tm_get_api(tm_global_api_registry, tm_asset_browser_add_asset_api);
                const tm_tt_id_t current_dir = add_asset-&gt;current_directory(add_asset-&gt;inst, args-&gt;ui);
                const bool should_select = args-&gt;asset_browser.u64 &amp;&amp; tm_the_truth_api-&gt;version(tt, args-&gt;asset_browser) == args-&gt;asset_browser_version_at_start;
                add_asset-&gt;add(add_asset-&gt;inst, current_dir, asset_id, asset_name, args-&gt;undo_scope, should_select, args-&gt;ui, 0, 0);
</code></pre>
<p>That's it for the import.  Before we move on, we need to clean up! No Allocation without deallocation!</p>
<pre><code class="language-c">    tm_free(args-&gt;allocator, task, task-&gt;bytes);
</code></pre>
<blockquote>
<p>Info:  If you don't do this, the Engine will inform you that there is a memory leak in the logs/terminal.</p>
</blockquote>
<p>Now bringing it all together:</p>
<pre><code class="language-c">static void task__import_txt(void *data, uint64_t task_id)
{
    struct task__import_txt *task = (struct task__import_txt *)data;
    const struct tm_asset_io_import *args = &amp;task-&gt;args;
    const char *txt_file = task-&gt;file;
    tm_the_truth_o *tt = args-&gt;tt;
    tm_file_stat_t stat = tm_os_api-&gt;file_system-&gt;stat(txt_file);
    if (stat.exists)
    {
        tm_buffers_i *buffers = tm_the_truth_api-&gt;buffers(tt);
        void *buffer = buffers-&gt;allocate(buffers-&gt;inst, stat.size, false);
        tm_file_o f = tm_os_api-&gt;file_io-&gt;open_input(txt_file);
        const int64_t read = tm_os_api-&gt;file_io-&gt;read(f, buffer, stat.size);
        tm_os_api-&gt;file_io-&gt;close(f);
        if (read == (int64_t)stat.size)
            const uint32_t buffer_id = buffers-&gt;add(buffers-&gt;inst, buffer, stat.size, 0);
            const tm_tt_type_t plugin_asset_type = tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__MY_ASSET);
            const tm_tt_id_t asset_id = tm_the_truth_api-&gt;create_object_of_type(tt, plugin_asset_type, TM_TT_NO_UNDO_SCOPE);
            tm_the_truth_object_o *asset_obj = tm_the_truth_api-&gt;write(tt, asset_id);
            tm_the_truth_api-&gt;set_buffer(tt, asset_obj, TM_TT_PROP__MY_ASSET__DATA, buffer_id);
            tm_the_truth_api-&gt;set_string(tt, asset_obj, TM_TT_PROP__MY_ASSET__FILE, txt_file);
                tm_the_truth_api-&gt;commit(tt, asset_obj, args-&gt;undo_scope);
        }
        else
        {
            tm_logger_api-&gt;printf(TM_LOG_TYPE_INFO, &quot;import txt:cound not read %s\n&quot;, txt_file);
        }
    else
    {
        tm_logger_api-&gt;printf(TM_LOG_TYPE_INFO, &quot;import txt:cound not find %s \n&quot;, txt_file);
    }
}
</code></pre>
<h2 id="enabling-reimport"><a class="header" href="#enabling-reimport">Enabling reimport</a></h2>
<p>The previous import task would never be able to reimport an asset. Let us fix this quickly!
The <a href="https://ourmachinery.com/apidoc/foundation/asset_io.h.html#structtm_asset_io_import">tm_asset_io_import</a> has a field called <code>reimport_into</code> of type <a href="https://ourmachinery.com/apidoc/foundation/api_types.h.html#structtm_tt_id_t">tm_tt_id_t</a>, which we did not set. If the current context is an import, otherwise a valid the truth id. It enables us to check if the current context is an import or reimport. To achieve this, we need to update the <code>reimport_into</code> object with the newly created object asset_obj, and you can do this via The Truth API function <code>retarget_write.</code> It takes an object and updates it with the new content. Commit the change and destroy the temporary object (asset_obj).</p>
<pre><code class="language-c">            if (args-&gt;reimport_into.u64)
            {
                tm_the_truth_api-&gt;retarget_write(tt, asset_obj, args-&gt;reimport_into);
                tm_the_truth_api-&gt;commit(tt, asset_obj, args-&gt;undo_scope);
                tm_the_truth_api-&gt;destroy_object(tt, asset_id, args-&gt;undo_scope);
            }
</code></pre>
<p>This changes the source code as following:</p>
<pre><code class="language-c">static void task__import_txt(void *data, uint64_t task_id)
{
    struct task__import_txt *task = (struct task__import_txt *)data;
    const struct tm_asset_io_import *args = &amp;task-&gt;args;
    const char *txt_file = task-&gt;file;
    tm_the_truth_o *tt = args-&gt;tt;
    tm_file_stat_t stat = tm_os_api-&gt;file_system-&gt;stat(txt_file);
    if (stat.exists)
    {
        tm_buffers_i *buffers = tm_the_truth_api-&gt;buffers(tt);
        void *buffer = buffers-&gt;allocate(buffers-&gt;inst, stat.size, false);
        tm_file_o f = tm_os_api-&gt;file_io-&gt;open_input(txt_file);
        const int64_t read = tm_os_api-&gt;file_io-&gt;read(f, buffer, stat.size);
        tm_os_api-&gt;file_io-&gt;close(f);
        if (read == (int64_t)stat.size)
        {
            const uint32_t buffer_id = buffers-&gt;add(buffers-&gt;inst, buffer, stat.size, 0);
            const tm_tt_type_t plugin_asset_type = tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__MY_ASSET);
            const tm_tt_id_t asset_id = tm_the_truth_api-&gt;create_object_of_type(tt, plugin_asset_type, TM_TT_NO_UNDO_SCOPE);
            tm_the_truth_object_o *asset_obj = tm_the_truth_api-&gt;write(tt, asset_id);
            tm_the_truth_api-&gt;set_buffer(tt, asset_obj, TM_TT_PROP__MY_ASSET__DATA, buffer_id);
            tm_the_truth_api-&gt;set_string(tt, asset_obj, TM_TT_PROP__MY_ASSET__FILE, txt_file);
            if (args-&gt;reimport_into.u64)
            {
                tm_the_truth_api-&gt;retarget_write(tt, asset_obj, args-&gt;reimport_into);
                tm_the_truth_api-&gt;commit(tt, asset_obj, args-&gt;undo_scope);
                tm_the_truth_api-&gt;destroy_object(tt, asset_id, args-&gt;undo_scope);
            }
            else
            {
                tm_the_truth_api-&gt;commit(tt, asset_obj, args-&gt;undo_scope);
                const char *asset_name = tm_path_api-&gt;base(tm_str(txt_file)).data;
                struct tm_asset_browser_add_asset_api *add_asset = tm_get_api(tm_global_api_registry, tm_asset_browser_add_asset_api);
                const tm_tt_id_t current_dir = add_asset-&gt;current_directory(add_asset-&gt;inst, args-&gt;ui);
                const bool should_select = args-&gt;asset_browser.u64 &amp;&amp; tm_the_truth_api-&gt;version(tt, args-&gt;asset_browser) == args-&gt;asset_browser_version_at_start;
                add_asset-&gt;add(add_asset-&gt;inst, current_dir, asset_id, asset_name, args-&gt;undo_scope, should_select, args-&gt;ui, 0, 0);
            }
        }
        else
        {
            tm_logger_api-&gt;printf(TM_LOG_TYPE_INFO, &quot;import txt:cound not read %s\n&quot;, txt_file);
        }
    }
    else
    {
        tm_logger_api-&gt;printf(TM_LOG_TYPE_INFO, &quot;import txt:cound not find %s \n&quot;, txt_file);
    }
    tm_free(args-&gt;allocator, task, task-&gt;bytes);
}
</code></pre>
<h2 id="refactor-the-custom-ui-import-functionality"><a class="header" href="#refactor-the-custom-ui-import-functionality">Refactor the Custom UI import functionality</a></h2>
<p>The last step before this part is over is to refactor the initial import of the file when we change the property in its custom UI. The current code does everything async. Besides, if we would leave this, we would have code duplication, which we want to avoid, for better-maintained reasons.</p>
<p>You might argue that it is the same process as just reimporting an asset when we change the path. That's correct!</p>
<p>We can reuse our Import-Task. Before we can launch a task, we need to ensure we have the right setup!
We can check the documentation of <a href="https://ourmachinery.com/apidoc/foundation/asset_io.h.html#structtm_asset_io_import">tm_asset_io_import</a> to ensure we do not forget anything important. </p>
<p>After we have done that, we will find that the reimport task needs besides the file name:</p>
<ul>
<li>the allocator</li>
<li>the current Truth</li>
<li>the object to import reimport into</li>
</ul>
<p>Now we can write our reimport task code. The code itself looks like this:</p>
<pre><code class="language-c">            tm_allocator_i *allocator = tm_allocator_api-&gt;system;
            const uint64_t bytes = sizeof(struct task__import_txt) + strlen(file);
            struct task__import_txt *task = tm_alloc(allocator, bytes);
            *task = (struct task__import_txt){
                .bytes = bytes,
                .args = {
                    .allocator = allocator,
                    .tt = tt,
                    .reimport_into = object}};
            strcpy(task-&gt;file, file);
            task_system-&gt;run_task(task__import_txt, task, &quot;Import Text File&quot;);
</code></pre>
<p>First, we ask for the system allocator (This one has the same lifetime as the program is running). Then, we allocate our task, including bytes for the string. Remember the struct structure:</p>
<pre><code class="language-c">// -- struct definitions
struct task__import_txt
{
    uint64_t bytes;
    struct tm_asset_io_import args;
    char file[8];
};
// .. other code
</code></pre>
<p>After that, we initialize our struct and its members with the needed data. Moreover, we copy the chars of the file name into our struct + extra bytes, and then we ask the task system to run the task.</p>
<p>This, combined with the custom UI functions, should look similar to this:</p>
<pre><code class="language-c">static float properties__custom_ui(struct tm_properties_ui_args_t *args, tm_rect_t item_rect, tm_tt_id_t object, uint32_t indent)
{
    tm_the_truth_o *tt = args-&gt;tt;
    bool picked = false;
    item_rect.y = tm_properties_view_api-&gt;ui_open_path(args, item_rect, TM_LOCALIZE_LATER(&quot;Import Path&quot;), TM_LOCALIZE_LATER(&quot;Path that the text file was imported from.&quot;), object, TM_TT_PROP__MY_ASSET__FILE, &quot;txt&quot;, &quot;text files&quot;, &amp;picked);
    if (picked)
    {
        const char *file = tm_the_truth_api-&gt;get_string(tt, tm_tt_read(tt, object), TM_TT_PROP__MY_ASSET__FILE);
        {
            tm_allocator_i *allocator = tm_allocator_api-&gt;system;
            const uint64_t bytes = sizeof(struct task__import_txt) + strlen(file);
            struct task__import_txt *task = tm_alloc(allocator, bytes);
            *task = (struct task__import_txt){
                .bytes = bytes,
                .args = {
                    .allocator = allocator,
                    .tt = tt,
                    .reimport_into = object}};
            strcpy(task-&gt;file, file);
            task_system-&gt;run_task(task__import_txt, task, &quot;Import Text File&quot;);
        }
    }
    return item_rect.y;
}
</code></pre>
<p><em>(For more information on the structure of these functions, please check the previous part)</em></p>
<ul>
<li><a href="#">Part 1</a></li>
<li><a href="#">Part 2</a></li>
</ul>
<h2 id="the-end"><a class="header" href="#the-end">The end</a></h2>
<p>It is the end of this walkthrough. You might have gained a better understanding:</p>
<ul>
<li>Of the Truth </li>
<li>How to create an asset</li>
<li>How to import assets into the Engine</li>
<li>How to provide a custom UI. </li>
</ul>
<p>If you wanted to see a more complex example of an importer, you could check the assimp importer example <code>samples\plugins\assimp</code>.</p>
<h3 id="full-example-of-basic-asset"><a class="header" href="#full-example-of-basic-asset">Full example of basic asset</a></h3>
<p><code>my_asset.h</code></p>
<pre><code class="language-c">#pragma once
#include &lt;foundation/api_types.h&gt;
//... more code
#define TM_TT_TYPE__MY_ASSET &quot;tm_my_asset&quot;
#define TM_TT_TYPE_HASH__MY_ASSET TM_STATIC_HASH(&quot;tm_my_asset&quot;, 0x1e12ba1f91b99960ULL)

enum
{
    TM_TT_PROP__MY_ASSET__FILE,
    TM_TT_PROP__MY_ASSET__DATA,
};
</code></pre>
<p>(Do not forget to run hash.exe when you create a <a href="https://ourmachinery.com/apidoc/foundation/api_types.h.html#tm_static_hash()">TM_STATIC_HASH</a>)</p>
<p><code>my_asset.c</code></p>
<pre><code class="language-c">// -- api's
static struct tm_api_registry_api *tm_global_api_registry;
static struct tm_the_truth_api *tm_the_truth_api;
static struct tm_properties_view_api *tm_properties_view_api;
static struct tm_os_api *tm_os_api;
static struct tm_path_api *tm_path_api;
static struct tm_temp_allocator_api *tm_temp_allocator_api;
static struct tm_logger_api *tm_logger_api;
static struct tm_localizer_api *tm_localizer_api;
static struct tm_asset_io_api *tm_asset_io_api;
static struct tm_task_system_api *task_system;
static struct tm_allocator_api *tm_allocator_api;
static struct tm_sprintf_api *tm_sprintf_api;

// -- inlcudes

#include &lt;foundation/api_registry.h&gt;
#include &lt;foundation/asset_io.h&gt;
#include &lt;foundation/buffer.h&gt;
#include &lt;foundation/carray_print.inl&gt;
#include &lt;foundation/localizer.h&gt;
#include &lt;foundation/log.h&gt;
#include &lt;foundation/macros.h&gt;
#include &lt;foundation/os.h&gt;
#include &lt;foundation/path.h&gt;
#include &lt;foundation/sprintf.h&gt;
#include &lt;foundation/string.inl&gt;
#include &lt;foundation/task_system.h&gt;
#include &lt;foundation/temp_allocator.h&gt;
#include &lt;foundation/the_truth.h&gt;
#include &lt;foundation/the_truth_assets.h&gt;
#include &lt;foundation/undo.h&gt;

#include &lt;plugins/editor_views/asset_browser.h&gt;
#include &lt;plugins/editor_views/properties.h&gt;

#include &quot;txt.h&quot;
// -- struct definitions
struct task__import_txt
{
    uint64_t bytes;
    struct tm_asset_io_import args;
    char file[8];
};
/////
// -- functions:
////
// --- importer
static void task__import_txt(void *data, uint64_t task_id)
{
    struct task__import_txt *task = (struct task__import_txt *)data;
    const struct tm_asset_io_import *args = &amp;task-&gt;args;
    const char *txt_file = task-&gt;file;
    tm_the_truth_o *tt = args-&gt;tt;
    tm_file_stat_t stat = tm_os_api-&gt;file_system-&gt;stat(txt_file);
    if (stat.exists)
    {
        tm_buffers_i *buffers = tm_the_truth_api-&gt;buffers(tt);
        void *buffer = buffers-&gt;allocate(buffers-&gt;inst, stat.size, false);
        tm_file_o f = tm_os_api-&gt;file_io-&gt;open_input(txt_file);
        const int64_t read = tm_os_api-&gt;file_io-&gt;read(f, buffer, stat.size);
        tm_os_api-&gt;file_io-&gt;close(f);
        if (read == (int64_t)stat.size)
        {
            const uint32_t buffer_id = buffers-&gt;add(buffers-&gt;inst, buffer, stat.size, 0);
            const tm_tt_type_t plugin_asset_type = tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__MY_ASSET);
            const tm_tt_id_t asset_id = tm_the_truth_api-&gt;create_object_of_type(tt, plugin_asset_type, TM_TT_NO_UNDO_SCOPE);
            tm_the_truth_object_o *asset_obj = tm_the_truth_api-&gt;write(tt, asset_id);
            tm_the_truth_api-&gt;set_buffer(tt, asset_obj, TM_TT_PROP__MY_ASSET__DATA, buffer_id);
            tm_the_truth_api-&gt;set_string(tt, asset_obj, TM_TT_PROP__MY_ASSET__FILE, txt_file);
            if (args-&gt;reimport_into.u64)
            {
                tm_the_truth_api-&gt;retarget_write(tt, asset_obj, args-&gt;reimport_into);
                tm_the_truth_api-&gt;commit(tt, asset_obj, args-&gt;undo_scope);
                tm_the_truth_api-&gt;destroy_object(tt, asset_id, args-&gt;undo_scope);
            }
            else
            {
                tm_the_truth_api-&gt;commit(tt, asset_obj, args-&gt;undo_scope);
                const char *asset_name = tm_path_api-&gt;base(tm_str(txt_file)).data;
                struct tm_asset_browser_add_asset_api *add_asset = tm_get_api(tm_global_api_registry, tm_asset_browser_add_asset_api);
                const tm_tt_id_t current_dir = add_asset-&gt;current_directory(add_asset-&gt;inst, args-&gt;ui);
                const bool should_select = args-&gt;asset_browser.u64 &amp;&amp; tm_the_truth_api-&gt;version(tt, args-&gt;asset_browser) == args-&gt;asset_browser_version_at_start;
                add_asset-&gt;add(add_asset-&gt;inst, current_dir, asset_id, asset_name, args-&gt;undo_scope, should_select, args-&gt;ui, 0, 0);
            }
        }
        else
        {
            tm_logger_api-&gt;printf(TM_LOG_TYPE_INFO, &quot;import txt:cound not read %s\n&quot;, txt_file);
        }
    }
    else
    {
        tm_logger_api-&gt;printf(TM_LOG_TYPE_INFO, &quot;import txt:cound not find %s \n&quot;, txt_file);
    }
    tm_free(args-&gt;allocator, task, task-&gt;bytes);
}

static bool asset_io__enabled(struct tm_asset_io_o *inst)
{
    return true;
}
static bool asset_io__can_import(struct tm_asset_io_o *inst, const char *extension)
{
    return tm_strcmp_ignore_case(extension, &quot;txt&quot;) == 0;
}
static bool asset_io__can_reimport(struct tm_asset_io_o *inst, struct tm_the_truth_o *tt, tm_tt_id_t asset)
{
    const tm_tt_id_t object = tm_the_truth_api-&gt;get_subobject(tt, tm_tt_read(tt, asset), TM_TT_PROP__ASSET__OBJECT);
    return object.type == tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__MY_ASSET).u64;
}
static void asset_io__importer_extensions_string(struct tm_asset_io_o *inst, char **output, struct tm_temp_allocator_i *ta, const char *separator)
{
    tm_carray_temp_printf(output, ta, &quot;txt&quot;);
}
static void asset_io__importer_description_string(struct tm_asset_io_o *inst, char **output, struct tm_temp_allocator_i *ta, const char *separator)
{
    tm_carray_temp_printf(output, ta, &quot;.txt&quot;);
}
static uint64_t asset_io__import_asset(struct tm_asset_io_o *inst, const char *file, const struct tm_asset_io_import *args)
{
    const uint64_t bytes = sizeof(struct task__import_txt) + strlen(file);
    struct task__import_txt *task = tm_alloc(args-&gt;allocator, bytes);
    *task = (struct task__import_txt){
        .bytes = bytes,
        .args = *args,
    };
    strcpy(task-&gt;file, file);
    return task_system-&gt;run_task(task__import_txt, task, &quot;Import Text File&quot;);
}
static struct tm_asset_io_i txt_asset_io = {
    .enabled = asset_io__enabled,
    .can_import = asset_io__can_import,
    .can_reimport = asset_io__can_reimport,
    .importer_extensions_string = asset_io__importer_extensions_string,
    .importer_description_string = asset_io__importer_description_string,
    .import_asset = asset_io__import_asset};

// -- asset on its own

//custom ui
static float properties__custom_ui(struct tm_properties_ui_args_t *args, tm_rect_t item_rect, tm_tt_id_t object, uint32_t indent)
{
    tm_the_truth_o *tt = args-&gt;tt;
    bool picked = false;
    item_rect.y = tm_properties_view_api-&gt;ui_open_path(args, item_rect, TM_LOCALIZE_LATER(&quot;Import Path&quot;), TM_LOCALIZE_LATER(&quot;Path that the text file was imported from.&quot;), object, TM_TT_PROP__MY_ASSET__FILE, &quot;txt&quot;, &quot;text files&quot;, &amp;picked);
    if (picked)
    {
        const char *file = tm_the_truth_api-&gt;get_string(tt, tm_tt_read(tt, object), TM_TT_PROP__MY_ASSET__FILE);
        {
            tm_allocator_i *allocator = tm_allocator_api-&gt;system;
            const uint64_t bytes = sizeof(struct task__import_txt) + strlen(file);
            struct task__import_txt *task = tm_alloc(allocator, bytes);
            *task = (struct task__import_txt){
                .bytes = bytes,
                .args = {
                    .allocator = allocator,
                    .tt = tt,
                    .reimport_into = object}};
            strcpy(task-&gt;file, file);
            task_system-&gt;run_task(task__import_txt, task, &quot;Import Text File&quot;);
        }
    }
    return item_rect.y;
}

// -- create truth type
static void create_truth_types(struct tm_the_truth_o *tt)
{
    static tm_the_truth_property_definition_t my_asset_properties[] = {
        {&quot;import_path&quot;, TM_THE_TRUTH_PROPERTY_TYPE_STRING},
        {&quot;data&quot;, TM_THE_TRUTH_PROPERTY_TYPE_BUFFER},
    };
    const tm_tt_type_t type = tm_the_truth_api-&gt;create_object_type(tt, TM_TT_TYPE__MY_ASSET, my_asset_properties, TM_ARRAY_COUNT(my_asset_properties));
    tm_the_truth_api-&gt;set_aspect(tt, type, TM_TT_ASPECT__FILE_EXTENSION, &quot;txt&quot;);
    static tm_properties_aspect_i properties_aspect = {
        .custom_ui = properties__custom_ui,
    };
    tm_the_truth_api-&gt;set_aspect(tt, type, TM_TT_ASPECT__PROPERTIES, &amp;properties_aspect);
}

// -- asset browser regsiter interface
static tm_tt_id_t asset_browser_create(struct tm_asset_browser_create_asset_o *inst, tm_the_truth_o *tt, tm_tt_undo_scope_t undo_scope)
{
    const tm_tt_type_t type = tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__MY_ASSET);
    return tm_the_truth_api-&gt;create_object_of_type(tt, type, undo_scope);
}
static tm_asset_browser_create_asset_i asset_browser_create_my_asset = {
    .menu_name = TM_LOCALIZE_LATER(&quot;New Text File&quot;),
    .asset_name = TM_LOCALIZE_LATER(&quot;New Text File&quot;),
    .create = asset_browser_create,
};

// -- load plugin
TM_DLL_EXPORT void tm_load_plugin(struct tm_api_registry_api *reg, bool load)
{
    tm_the_truth_api = tm_get_api(reg, tm_the_truth_api);
    tm_properties_view_api = tm_get_api(reg, tm_properties_view_api);
    tm_os_api = tm_get_api(reg, tm_os_api);
    tm_path_api = tm_get_api(reg, tm_path_api);
    tm_temp_allocator_api = tm_get_api(reg, tm_temp_allocator_api);
    tm_allocator_api = tm_get_api(reg, tm_allocator_api);
    tm_logger_api = tm_get_api(reg, tm_logger_api);
    tm_localizer_api = tm_get_api(reg, tm_localizer_api);
    tm_asset_io_api = tm_get_api(reg, tm_asset_io_api);
    task_system = tm_get_api(reg, tm_task_system_api);
    tm_sprintf_api = tm_get_api(reg, tm_sprintf_api);
    tm_global_api_registry = reg;
    if (load)
        tm_asset_io_api-&gt;add_asset_io(&amp;txt_asset_io);
    else
        tm_asset_io_api-&gt;remove_asset_io(&amp;txt_asset_io);
    tm_add_or_remove_implementation(reg, load, tm_the_truth_create_types_i, create_truth_types);
    tm_add_or_remove_implementation(reg, load, tm_asset_browser_create_asset_i, &amp;asset_browser_create_my_asset);
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="../../the_truth/custom_asset/part2.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="../../the_truth/drag_and_drop.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="../../the_truth/custom_asset/part2.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="../../the_truth/drag_and_drop.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        
    </body>
</html>
