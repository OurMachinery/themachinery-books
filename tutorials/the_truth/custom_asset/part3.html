<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Part 3 - Custom Importer - The Machinery Tutorial Book</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="../../favicon.svg">
                        <link rel="shortcut icon" href="../../favicon.png">
                <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
                <link rel="stylesheet" href="../../css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="../../fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="../../index.html"><strong aria-hidden="true">1.</strong> Welcome</a></li><li class="chapter-item "><a href="../../workflows/how_to_create_prototypes.html"><strong aria-hidden="true">2.</strong> How to Create Prototypes</a></li><li class="chapter-item "><a href="../../workflows/how_to_instantiate_prototypes.html"><strong aria-hidden="true">3.</strong> How to Instantiate Prototypes</a></li><li class="chapter-item "><a href="../../creation_graph/index.html"><strong aria-hidden="true">4.</strong> Creation Graph</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../creation_graph/introduction_walkthrough/index.html"><strong aria-hidden="true">4.1.</strong> Creation Graph Introduction Series</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../creation_graph/introduction_walkthrough/texture_compression.html"><strong aria-hidden="true">4.1.1.</strong> Simple Texture Compression</a></li><li class="chapter-item "><a href="../../creation_graph/introduction_walkthrough/creation_graph_prototype.html"><strong aria-hidden="true">4.1.2.</strong> Creation Graph Prototype</a></li><li class="chapter-item "><a href="../../creation_graph/introduction_walkthrough/custom_import_settings.html"><strong aria-hidden="true">4.1.3.</strong> Custom Import Settings</a></li></ol></li><li class="chapter-item "><a href="../../creation_graph/custom_gpu_nodes.html"><strong aria-hidden="true">4.2.</strong> Creating Custom GPU Nodes</a></li><li class="chapter-item "><a href="../../creation_graph/custom_cpu_nodes.html"><strong aria-hidden="true">4.3.</strong> Creating Custom CPU Nodes</a></li><li class="chapter-item "><a href="../../creation_graph/custom_geometry_node.html"><strong aria-hidden="true">4.4.</strong> Creating Custom Geometry Nodes</a></li><li class="chapter-item "><a href="../../creation_graph/from_code.html"><strong aria-hidden="true">4.5.</strong> Calling Creation Graphs from Code</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../creation_graph/raymarch_output_node.html"><strong aria-hidden="true">4.5.1.</strong> Creating a Custom Raymarching Output Node</a></li></ol></li></ol></li><li class="chapter-item "><a href="../../post_processing/index.html"><strong aria-hidden="true">5.</strong> Post Processing</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../post_processing/aa.html"><strong aria-hidden="true">5.1.</strong> Anti-Aliasing</a></li><li class="chapter-item "><a href="../../post_processing/exposure.html"><strong aria-hidden="true">5.2.</strong> Exposure</a></li><li class="chapter-item "><a href="../../post_processing/bloom.html"><strong aria-hidden="true">5.3.</strong> Bloom</a></li><li class="chapter-item "><a href="../../post_processing/color_grading.html"><strong aria-hidden="true">5.4.</strong> Color Grading</a></li></ol></li><li class="chapter-item "><a href="../../physics/index.html"><strong aria-hidden="true">6.</strong> Physics</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../physics/triggers.html"><strong aria-hidden="true">6.1.</strong> Triggers</a></li></ol></li><li class="chapter-item expanded "><a href="../../the_truth/index.html"><strong aria-hidden="true">7.</strong> The Truth</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../the_truth/custom_asset/index.html"><strong aria-hidden="true">7.1.</strong> Creating a Custom Asset Type</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../the_truth/custom_asset/part1.html"><strong aria-hidden="true">7.1.1.</strong> Part 1 - Create an Asset Truth Type, Addable via Asset Browser</a></li><li class="chapter-item "><a href="../../the_truth/custom_asset/part2.html"><strong aria-hidden="true">7.1.2.</strong> Part 2 - Custom UI</a></li><li class="chapter-item expanded "><a href="../../the_truth/custom_asset/part3.html" class="active"><strong aria-hidden="true">7.1.3.</strong> Part 3 - Custom Importer</a></li></ol></li><li class="chapter-item "><a href="../../the_truth/drag_and_drop.html"><strong aria-hidden="true">7.2.</strong> Adding Drag and Drop to Assets</a></li><li class="chapter-item "><a href="../../the_truth/open_asset.html"><strong aria-hidden="true">7.3.</strong> Open Asset in Tab</a></li></ol></li><li class="chapter-item "><a href="../../gameplay_coding/index.html"><strong aria-hidden="true">8.</strong> Gameplay Coding</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../gameplay_coding/extend_the_entity_graph.html"><strong aria-hidden="true">8.1.</strong> Extending the Entity Graph</a></li><li class="chapter-item "><a href="../../gameplay_coding/provide_custom_data_type_to_the_entity_graph.html"><strong aria-hidden="true">8.2.</strong> Custom Data Type for the Entity Graph</a></li></ol></li><li class="chapter-item "><a href="../../network/index.html"><strong aria-hidden="true">9.</strong> Network</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../network/animation_sample/network_assets.html"><strong aria-hidden="true">9.1.</strong> Part 1: Network Asset</a></li><li class="chapter-item "><a href="../../network/animation_sample/multiple_network_instances.html"><strong aria-hidden="true">9.2.</strong> Part 2: Multiple Instances</a></li><li class="chapter-item "><a href="../../network/animation_sample/entity_control.html"><strong aria-hidden="true">9.3.</strong> Part 3: Entity Control</a></li><li class="chapter-item "><a href="../../network/animation_sample/support_multiple_players.html"><strong aria-hidden="true">9.4.</strong> Part 4: Multiple Players</a></li><li class="chapter-item "><a href="../../network/animation_sample/basic_graph_variables.html"><strong aria-hidden="true">9.5.</strong> Part 5: Variable Replication (Graph)</a></li><li class="chapter-item "><a href="../../network/animation_sample/smooth_animation.html"><strong aria-hidden="true">9.6.</strong> Part 6: Smooth Animation</a></li><li class="chapter-item "><a href="../../network/animation_sample/spawning_entities.html"><strong aria-hidden="true">9.7.</strong> Part 7: Spawning Entities</a></li></ol></li><li class="chapter-item "><a href="../../ui/index.html"><strong aria-hidden="true">10.</strong> UI</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../ui/build_custom_ui_controls/index.html"><strong aria-hidden="true">10.1.</strong> Build Custom UI Controls</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../ui/build_custom_ui_controls/part1.html"><strong aria-hidden="true">10.1.1.</strong> Part 1</a></li></ol></li><li class="chapter-item "><a href="../../ui/toolbars-overlays.html"><strong aria-hidden="true">10.2.</strong> Toolbars and Overlays</a></li><li class="chapter-item "><a href="../../ui/custom_layouts.html"><strong aria-hidden="true">10.3.</strong> Custom Tab Layouts</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">The Machinery Tutorial Book</h1>

                    <div class="right-buttons">
                                                <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/OurMachinery/themachinery-books" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="create-a-custom-asset-type-part-3"><a class="header" href="#create-a-custom-asset-type-part-3">Create a Custom Asset Type: Part 3</a></h1>
<p>This part will cover the following topics:</p>
<ul>
<li>How to write an importer</li>
</ul>
<blockquote>
<p>You can find the whole source code in its git repo: <a href="https://github.com/simon-ourmachinery/example-text-file-asset">example-text-file-asset</a></p>
</blockquote>
<p><strong>Table of Content</strong></p>
<ul>
<li><a href="#custom-importer-for-text-files">Custom importer for text files</a></li>
<li><a href="#import-task-setup">Import Task Setup</a></li>
<li><a href="#import-task-implementation">Import Task Implementation</a></li>
<li><a href="#enabling-reimport">Enabling Reimport</a></li>
<li><a href="#refactor-the-custom-ui-import-functionality">Refactor the Custom UI Import Functionality</a></li>
<li><a href="#the-end">The End</a>
<ul>
<li><a href="#full-example-of-basic-asset">Full Example of Basic Asset</a></li>
</ul>
</li>
</ul>
<h2 id="custom-importer-for-text-files"><a class="header" href="#custom-importer-for-text-files">Custom importer for text files</a></h2>
<p>In this part, we will add the ability to import a text file into the Engine. To implement an importer, we need the following APIs:</p>
<table><thead><tr><th><strong>Name</strong></th><th><strong>header file</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td><a href="https://ourmachinery.com/apidoc/foundation/asset_io.h.html#structtm_asset_io_api">tm_asset_io_api</a></td><td><code>foundation/asset_io.h</code></td><td>This API has the importer interface.</td></tr>
<tr><td><a href="https://ourmachinery.com/apidoc/foundation/temp_allocator.h.html#structtm_temp_allocator_api">tm_temp_allocator_api</a></td><td><code>foundation/temp_allocator.h</code></td><td>We will use this to allocate temporary memory.</td></tr>
<tr><td><a href="https://ourmachinery.com/apidoc/foundation/allocator.h.html#structtm_allocator_api">tm_allocator_api</a></td><td><code>foundation/allocator.h</code></td><td>We will use this for permanent memory allocations. <a href="https://ourmachinery.com/apidoc/foundation/allocator.h.html#structtm_allocator_api">tm_allocator_api</a> supports a number of different allocators, for example the <code>system</code> allocator. We need this one later when we rewrite our reimport.</td></tr>
<tr><td><a href="https://ourmachinery.com/apidoc/foundation/path.h.html#structtm_path_api">tm_path_api</a></td><td><code>foundation/path.h</code></td><td>Used for splitting and joining file system paths.</td></tr>
<tr><td><a href="https://ourmachinery.com/apidoc/foundation/api_registry.h.html#structtm_api_registry_api">tm_api_registry_api</a></td><td><code>foundation/api_registry.h</code></td><td>We use this to get access to APIs from the API registry.</td></tr>
<tr><td><a href="https://ourmachinery.com/apidoc/foundation/task_system.h.html#structtm_task_system_api">tm_task_system_api</a></td><td><code>foundation/task_system.h</code></td><td>Allows us to spawm tasks</td></tr>
</tbody></table>
<p>We include these header files and retrieve the APis from the API registry.</p>
<blockquote>
<p>Note: <a href="https://ourmachinery.com/apidoc/foundation/api_registry.h.html#structtm_api_registry_api">tm_api_registry_api</a> can be retrived from the reg parameter in the <code>tm_load_plugin</code> function. <code>tm_global_api_registry = reg;</code></p>
</blockquote>
<p>The Machinery has a generic interface for asset importers. It requires a bunch of functions to be able to work as intended. The struct we need to implement is called <a href="https://ourmachinery.com/apidoc/foundation/asset_io.h.html#structtm_asset_io_import">tm_asset_io_i</a>. It requires us to set the following members:</p>
<table><thead><tr><th>Member</th><th>Description</th></tr></thead><tbody>
<tr><td><code>enabled()</code></td><td>Should return <code>true</code> if the importer is active.</td></tr>
<tr><td><code>can_import()</code></td><td>Optional. Should return <code>true</code> for the file extensions that can be imported by this interface.</td></tr>
<tr><td><code>can_reimport()</code></td><td>Optional. Should return <code>true</code> for Truth assets that can be reimported.</td></tr>
<tr><td><code>importer_extensions_string()</code></td><td>Optional. Extensions that can be imported by this interface.</td></tr>
<tr><td><code>importer_description_string()</code></td><td>Optional. Descriptions for the extensions in <code>importer_extensions_string()</code>.</td></tr>
<tr><td><code>import_asset()</code></td><td>Implements the import. Since imports can be slow, they are typically implemented as background tasks and this function should return the ID of the background task from <a href="https://ourmachinery.com/apidoc/foundation/task_system.h.html#structtm_task_system_api">tm_task_system_api</a>.</td></tr>
</tbody></table>
<p>All these members expect a function pointer. Therefore, we need to provide the functionality.</p>
<p>To implement the first functions, we need to do the following steps:</p>
<pre><code class="language-c">//... other includes
#include &lt;foundation/carray_print.inl&gt;
#include &lt;foundation/string.inl&gt;
#include &lt;foundation/localizer.h&gt;
//... other code
static bool asset_io__enabled(struct tm_asset_io_o *inst)
{
    return true;
}
static bool asset_io__can_import(struct tm_asset_io_o *inst, const char *extension)
{
    return tm_strcmp_ignore_case(extension, &quot;txt&quot;) == 0;
}
static bool asset_io__can_reimport(struct tm_asset_io_o *inst, struct tm_the_truth_o *tt, tm_tt_id_t asset)
{
    const tm_tt_id_t object = tm_the_truth_api-&gt;get_subobject(tt, tm_tt_read(tt, asset), TM_TT_PROP__ASSET__OBJECT);
    return object.type == tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__MY_ASSET).u64;
}
static void asset_io__importer_extensions_string(struct tm_asset_io_o *inst, char **output, struct tm_temp_allocator_i *ta, const char *separator)
{
    tm_carray_temp_printf(output, ta, &quot;txt&quot;);
}
static void asset_io__importer_description_string(struct tm_asset_io_o *inst, char **output, struct tm_temp_allocator_i *ta, const char *separator)
{
    tm_carray_temp_printf(output, ta, &quot;.txt&quot;);
}
</code></pre>
<p>Let us go through them:</p>
<ul>
<li><code>enabled()</code> returns <em>true</em> because we want the importer to work. </li>
<li><code>asset_io__can_import()</code> compares the extension with the one we want to support.</li>
</ul>
<blockquote>
<p><strong>Note</strong>: <code>string.inl </code> which we need to include for <code>tm_strcmp_ignore_case()</code> uses the <a href="https://ourmachinery.com/apidoc/foundation/localizer.h.html#structtm_localizer_api">tm_localizer_api</a> for some of its functionality, that's why we need it.</p>
</blockquote>
<ul>
<li><code>asset_io__can_reimport()</code> checks if the object type matches our type. </li>
</ul>
<blockquote>
<p><a href="https://ourmachinery.com/apidoc/foundation/the_truth_assets.h.html#enumtm_tt_prop__asset">TM_TT_PROP__ASSET__OBJECT</a> is the property of the <a href="https://ourmachinery.com/apidoc/foundation/the_truth_assets.h.html#tm_tt_type__asset">TM_TT_TYPE__ASSET</a> type which holds the object associated with the asset.</p>
</blockquote>
<p>The last two functions append <code>.txt</code> to the file extensions and descriptions. Note that the argument <code>output</code> is a <a href="https://ourmachinery.com/apidoc/foundation/carray.inl.html#carray.inl">carray</a>. We can use <code>tm_carray_temp_printf()</code> to append to that array.</p>
<blockquote>
<p><strong>Note</strong>: <code>carray_print.h</code> requires tm_sprintf_api`. Therefore, we need to include the right header here.</p>
</blockquote>
<h2 id="import-task-setup"><a class="header" href="#import-task-setup">Import Task Setup</a></h2>
<p>To run the import as a background task we need to queue a task using the <a href="https://ourmachinery.com/apidoc/the_machinery/task_manager.h.html#structtm_task_manager_api">tm_task_manager_api</a> from our <code>asset_io__import_asset()</code> function. Task functions take a single <code>void *userdata</code> argument. Since we typically want to pass more than one thing to the task, we put everything the task needs in a struct and pass a pointer to that struct as the <code>userdata</code>. The task function casts this <code>void *</code> to the desired type and can then make use of the data.</p>
<p>The task needs to know the location of the file that is to be imported. It also needs access to some semi-global objects, such as the Truth that the file should be imported to, and an allocator to use for memory allocations. The struct could look like this:</p>
<pre><code class="language-c">struct task__import_txt
{
    uint64_t bytes;
    struct tm_asset_io_import args;
    char file[8];
};
</code></pre>
<p>The <a href="https://ourmachinery.com/apidoc/foundation/asset_io.h.html#structtm_asset_io_import">tm_asset_io_import</a> field will used be copied from the parameter passed to <code>asset_io__import_asset()</code> to the struct.</p>
<p>The function itself looks like this:</p>
<pre><code class="language-c">static uint64_t asset_io__import_asset(struct tm_asset_io_o *inst, const char *file, const struct tm_asset_io_import *args)
{
    const uint64_t bytes = sizeof(struct task__import_txt) + strlen(file);
    struct task__import_txt *task = tm_alloc(args-&gt;allocator, bytes);
    *task = (struct task__import_txt){
        .bytes = bytes,
        .args = *args,
    };
    strcpy(task-&gt;file, file);
    return task_system-&gt;run_task(task__import_txt, task, &quot;Import Text File&quot;);
}
</code></pre>
<blockquote>
<p><strong>Important</strong>: The task is the memory owner and needs to clean it up at the end of the execution!</p>
</blockquote>
<p>The line <code>task_system-&gt;run_task(task__import_txt, task, &quot;Import Text File&quot;);</code> queues the task task <code>import_txt()</code> , with the data <code>task</code>, and returns its id. The id can be used to query for when the background task has completed. </p>
<blockquote>
<p>Info: For more information on the task system check the <a href="https://ourmachinery.com/apidoc/foundation/task_system.h.html#structtm_task_system_api.run_task()">documentation</a>.</p>
</blockquote>
<h2 id="import-task-implementation"><a class="header" href="#import-task-implementation">Import Task Implementation</a></h2>
<p>The import task should import the data and clean up afterwards.</p>
<p>The function signature is:</p>
<pre><code class="language-c">static void task__import_txt(void *data, uint64_t task_id)
{
    // all our work
}
</code></pre>
<p>We need to cast <code>ptr</code> to our previously defined data type <code>task__import_txt</code>. The task <code>id</code> can be used by the task callback function to provide task progress updates. In this example, we do not use it.</p>
<blockquote>
<p>For more information on how to update the status of a task so that it is shown in the editor, see the <a href="https://ourmachinery.com/apidoc/foundation/progress_report.h.html#structtm_progress_report_api">documentation</a>.</p>
</blockquote>
<p>To implement the import we retrieve the data passed in the struct and then implement the import as in the previous chapter. The reimport works the same as the import, except we add the buffer to an existing object instead of creating a new one:</p>
<pre><code class="language-c">static void task__import_txt(void *data, uint64_t task_id)
{
    struct task__import_txt *task = (struct task__import_txt *)data;
    const struct tm_asset_io_import *args = &amp;task-&gt;args;
    const char *txt_file = task-&gt;file;
    tm_the_truth_o *tt = args-&gt;tt;
//.. more
}
</code></pre>
<p>Another thing we should consider is error checking: </p>
<ul>
<li>Does the file exist? </li>
<li>Can we read the expected number of bytes from the file?</li>
</ul>
<p>Since we are running as a background task, we will report any errors through the logging API: <a href="https://ourmachinery.com/apidoc/foundation/log.h.html#structtm_logger_api">tm_logger_api</a>. Errors reported that way will appear in the Console tab of the UI:</p>
<pre><code class="language-c">static void task__import_txt(void *data, uint64_t task_id)
{
    struct task__import_txt *task = (struct task__import_txt *)data;
    const struct tm_asset_io_import *args = &amp;task-&gt;args;
    const char *txt_file = task-&gt;file;
    tm_the_truth_o *tt = args-&gt;tt;
    tm_file_stat_t stat = tm_os_api-&gt;file_system-&gt;stat(txt_file);
    if (stat.exists)
    {
    // .. code
    else
    {
        tm_logger_api-&gt;printf(TM_LOG_TYPE_INFO, &quot;import txt:cound not find %s \n&quot;, txt_file);
    }
}
</code></pre>
<p>Now we combine all the knowledge from this chapter and the previous chapter. We need to create a new asset via code for the import, and for the reimport, we need to update an existing file. 
Before we do all of this, let us first read the file and create the buffer.</p>
<pre><code class="language-c">static void task__import_txt(void *data, uint64_t task_id)
{
    struct task__import_txt *task = (struct task__import_txt *)data;
    const struct tm_asset_io_import *args = &amp;task-&gt;args;
    const char *txt_file = task-&gt;file;
    tm_the_truth_o *tt = args-&gt;tt;
    tm_file_stat_t stat = tm_os_api-&gt;file_system-&gt;stat(txt_file);
    if (stat.exists)
    {
        tm_buffers_i *buffers = tm_the_truth_api-&gt;buffers(tt);
        void *buffer = buffers-&gt;allocate(buffers-&gt;inst, stat.size, false);
        tm_file_o f = tm_os_api-&gt;file_io-&gt;open_input(txt_file);
        const int64_t read = tm_os_api-&gt;file_io-&gt;read(f, buffer, stat.size);
        tm_os_api-&gt;file_io-&gt;close(f);
// ..code
    else
    {
        tm_logger_api-&gt;printf(TM_LOG_TYPE_INFO, &quot;import txt:cound not find %s \n&quot;, txt_file);
    }
}
</code></pre>
<p>After this, we should ensure that the file size matches the size of the read data.</p>
<pre><code class="language-c">static void task__import_txt(void *data, uint64_t task_id)
{
    struct task__import_txt *task = (struct task__import_txt *)data;
    const struct tm_asset_io_import *args = &amp;task-&gt;args;
    const char *txt_file = task-&gt;file;
    tm_the_truth_o *tt = args-&gt;tt;
    tm_file_stat_t stat = tm_os_api-&gt;file_system-&gt;stat(txt_file);
    if (stat.exists)
    {
        tm_buffers_i *buffers = tm_the_truth_api-&gt;buffers(tt);
        void *buffer = buffers-&gt;allocate(buffers-&gt;inst, stat.size, false);
        tm_file_o f = tm_os_api-&gt;file_io-&gt;open_input(txt_file);
        const int64_t read = tm_os_api-&gt;file_io-&gt;read(f, buffer, stat.size);
        tm_os_api-&gt;file_io-&gt;close(f);
        if (read == (int64_t)stat.size)
//..
        }
        else
        {
            tm_logger_api-&gt;printf(TM_LOG_TYPE_INFO, &quot;import txt:cound not read %s\n&quot;, txt_file);
        }
    else
    {
        tm_logger_api-&gt;printf(TM_LOG_TYPE_INFO, &quot;import txt:cound not find %s \n&quot;, txt_file);
    }
}
</code></pre>
<p>With this out of the way, we can use our knowledge from the last part.</p>
<ul>
<li>How to add an asset via code.</li>
</ul>
<p>The first step was to create the new object and add the data to it.</p>
<pre><code class="language-c">            const uint32_t buffer_id = buffers-&gt;add(buffers-&gt;inst, buffer, stat.size, 0);
            const tm_tt_type_t plugin_asset_type = tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__MY_ASSET);
            const tm_tt_id_t asset_id = tm_the_truth_api-&gt;create_object_of_type(tt, plugin_asset_type, TM_TT_NO_UNDO_SCOPE);
            tm_the_truth_object_o *asset_obj = tm_the_truth_api-&gt;write(tt, asset_id);
            tm_the_truth_api-&gt;set_buffer(tt, asset_obj, TM_TT_PROP__MY_ASSET__DATA, buffer_id);
            tm_the_truth_api-&gt;set_string(tt, asset_obj, TM_TT_PROP__MY_ASSET__FILE, txt_file);
                tm_the_truth_api-&gt;commit(tt, asset_obj, args-&gt;undo_scope);
</code></pre>
<p>After that, we can use the <a href="https://ourmachinery.com/apidoc/plugins/editor_views/asset_browser.h.html#structtm_asset_browser_add_asset_api">tm_asset_browser_add_asset_api</a> to add the asset to the asset browser. </p>
<pre><code class="language-c">                struct tm_asset_browser_add_asset_api *add_asset = tm_get_api(tm_global_api_registry, tm_asset_browser_add_asset_api);
</code></pre>
<p>We are getting the API first, because we do not need it anywhere else than in this case. Then we need to extract the file name of the imported file. You can do this with the <em>path API</em>'s <code> tm_path_api-&gt;base()</code> function. Be aware this function requires a <a href="https://ourmachinery.com/apidoc/foundation/api_types.h.html#structtm_str_t">tm_str_t</a> which you an create from a normal C string (<code>const char*</code>) via <code>tm_str()</code>. To access the underlaying C string again just call <code>.data</code> on the <a href="https://ourmachinery.com/apidoc/foundation/api_types.h.html#structtm_str_t">tm_str_t</a>.</p>
<blockquote>
<p><a href="https://ourmachinery.com/apidoc/foundation/api_types.h.html#structtm_str_t">tm_str_t</a> represents strings with a <code>char *</code> and a size, instead of just a <code>char *</code>. </p>
<p>This lets you reason about parts of a string, which you are not able to do with standard NULL-terminated strings.</p>
<p><a href="https://ourmachinery.com/apidoc/foundation/api_types.h.html#structtm_str_t">documentation</a></p>
</blockquote>
<p>We want to add the asset to the folder that currently open in the asset browser. We can ask the <a href="https://ourmachinery.com/apidoc/plugins/editor_views/asset_browser.h.html#structtm_asset_browser_add_asset_api">tm_asset_browser_add_asset_api</a> what the current folder is. Then we decide if want to select the file. At the end we call <code>tm_asset_browser_add_asset_api-&gt;add()</code>. </p>
<blockquote>
<p><strong>Note:</strong> If we wanted to, we could add asset labels to the asset and pass them as the last two arguments of the <code>add()</code> function instead of <code>0, 0</code>.</p>
</blockquote>
<pre><code class="language-c">                const char *asset_name = tm_path_api-&gt;base(tm_str(txt_file)).data;
                struct tm_asset_browser_add_asset_api *add_asset = tm_get_api(tm_global_api_registry, tm_asset_browser_add_asset_api);
                const tm_tt_id_t current_dir = add_asset-&gt;current_directory(add_asset-&gt;inst, args-&gt;ui);
                const bool should_select = args-&gt;asset_browser.u64 &amp;&amp; tm_the_truth_api-&gt;version(tt, args-&gt;asset_browser) == args-&gt;asset_browser_version_at_start;
                add_asset-&gt;add(add_asset-&gt;inst, current_dir, asset_id, asset_name, args-&gt;undo_scope, should_select, args-&gt;ui, 0, 0);
</code></pre>
<p>That's it for the import.  Before we move on, we need to clean up! No allocation without deallocation!</p>
<pre><code class="language-c">    tm_free(args-&gt;allocator, task, task-&gt;bytes);
</code></pre>
<blockquote>
<p>Info:  If you forget to do this, the Engine will inform you that there is a memory leak in the Console log</p>
</blockquote>
<p>Now let's bring it all together:</p>
<pre><code class="language-c">static void task__import_txt(void *data, uint64_t task_id)
{
    struct task__import_txt *task = (struct task__import_txt *)data;
    const struct tm_asset_io_import *args = &amp;task-&gt;args;
    const char *txt_file = task-&gt;file;
    tm_the_truth_o *tt = args-&gt;tt;
    tm_file_stat_t stat = tm_os_api-&gt;file_system-&gt;stat(txt_file);
    if (stat.exists)
    {
        tm_buffers_i *buffers = tm_the_truth_api-&gt;buffers(tt);
        void *buffer = buffers-&gt;allocate(buffers-&gt;inst, stat.size, false);
        tm_file_o f = tm_os_api-&gt;file_io-&gt;open_input(txt_file);
        const int64_t read = tm_os_api-&gt;file_io-&gt;read(f, buffer, stat.size);
        tm_os_api-&gt;file_io-&gt;close(f);
        if (read == (int64_t)stat.size)
            const uint32_t buffer_id = buffers-&gt;add(buffers-&gt;inst, buffer, stat.size, 0);
            const tm_tt_type_t plugin_asset_type = tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__MY_ASSET);
            const tm_tt_id_t asset_id = tm_the_truth_api-&gt;create_object_of_type(tt, plugin_asset_type, TM_TT_NO_UNDO_SCOPE);
            tm_the_truth_object_o *asset_obj = tm_the_truth_api-&gt;write(tt, asset_id);
            tm_the_truth_api-&gt;set_buffer(tt, asset_obj, TM_TT_PROP__MY_ASSET__DATA, buffer_id);
            tm_the_truth_api-&gt;set_string(tt, asset_obj, TM_TT_PROP__MY_ASSET__FILE, txt_file);
                tm_the_truth_api-&gt;commit(tt, asset_obj, args-&gt;undo_scope);
        }
        else
        {
            tm_logger_api-&gt;printf(TM_LOG_TYPE_INFO, &quot;import txt:cound not read %s\n&quot;, txt_file);
        }
    else
    {
        tm_logger_api-&gt;printf(TM_LOG_TYPE_INFO, &quot;import txt:cound not find %s \n&quot;, txt_file);
    }
}
</code></pre>
<h2 id="enabling-reimport"><a class="header" href="#enabling-reimport">Enabling Reimport</a></h2>
<p>Our implementation does not yet support reimports. Let us fix this quickly!</p>
<p><a href="https://ourmachinery.com/apidoc/foundation/asset_io.h.html#structtm_asset_io_import">tm_asset_io_import</a> has a field called <code>reimport_into</code> of type <a href="https://ourmachinery.com/apidoc/foundation/api_types.h.html#structtm_tt_id_t">tm_tt_id_t</a>. When doing a regular import, the value of this field will be <code>(tm_tt_id_t){0}</code>. When reimporting, it will be the ID of the Truth object that we should import into.</p>
<p>To change an existing object instead of creating a new one, we can use the function <code>tm_the_truth_api-&gt;retarget_write()</code>. It will make the <code>commit()</code> operation write the changes to an existing object instead of two the new one we just created. After comitting, we can destroy the new (temporary) object:</p>
<pre><code class="language-c">            if (args-&gt;reimport_into.u64)
            {
                tm_the_truth_api-&gt;retarget_write(tt, asset_obj, args-&gt;reimport_into);
                tm_the_truth_api-&gt;commit(tt, asset_obj, args-&gt;undo_scope);
                tm_the_truth_api-&gt;destroy_object(tt, asset_id, args-&gt;undo_scope);
            }
</code></pre>
<p>With these changes, the source code now looks as like this:</p>
<pre><code class="language-c">static void task__import_txt(void *data, uint64_t task_id)
{
    struct task__import_txt *task = (struct task__import_txt *)data;
    const struct tm_asset_io_import *args = &amp;task-&gt;args;
    const char *txt_file = task-&gt;file;
    tm_the_truth_o *tt = args-&gt;tt;
    tm_file_stat_t stat = tm_os_api-&gt;file_system-&gt;stat(txt_file);
    if (stat.exists)
    {
        tm_buffers_i *buffers = tm_the_truth_api-&gt;buffers(tt);
        void *buffer = buffers-&gt;allocate(buffers-&gt;inst, stat.size, false);
        tm_file_o f = tm_os_api-&gt;file_io-&gt;open_input(txt_file);
        const int64_t read = tm_os_api-&gt;file_io-&gt;read(f, buffer, stat.size);
        tm_os_api-&gt;file_io-&gt;close(f);
        if (read == (int64_t)stat.size)
        {
            const uint32_t buffer_id = buffers-&gt;add(buffers-&gt;inst, buffer, stat.size, 0);
            const tm_tt_type_t plugin_asset_type = tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__MY_ASSET);
            const tm_tt_id_t asset_id = tm_the_truth_api-&gt;create_object_of_type(tt, plugin_asset_type, TM_TT_NO_UNDO_SCOPE);
            tm_the_truth_object_o *asset_obj = tm_the_truth_api-&gt;write(tt, asset_id);
            tm_the_truth_api-&gt;set_buffer(tt, asset_obj, TM_TT_PROP__MY_ASSET__DATA, buffer_id);
            tm_the_truth_api-&gt;set_string(tt, asset_obj, TM_TT_PROP__MY_ASSET__FILE, txt_file);
            if (args-&gt;reimport_into.u64)
            {
                tm_the_truth_api-&gt;retarget_write(tt, asset_obj, args-&gt;reimport_into);
                tm_the_truth_api-&gt;commit(tt, asset_obj, args-&gt;undo_scope);
                tm_the_truth_api-&gt;destroy_object(tt, asset_id, args-&gt;undo_scope);
            }
            else
            {
                tm_the_truth_api-&gt;commit(tt, asset_obj, args-&gt;undo_scope);
                const char *asset_name = tm_path_api-&gt;base(tm_str(txt_file)).data;
                struct tm_asset_browser_add_asset_api *add_asset = tm_get_api(tm_global_api_registry, tm_asset_browser_add_asset_api);
                const tm_tt_id_t current_dir = add_asset-&gt;current_directory(add_asset-&gt;inst, args-&gt;ui);
                const bool should_select = args-&gt;asset_browser.u64 &amp;&amp; tm_the_truth_api-&gt;version(tt, args-&gt;asset_browser) == args-&gt;asset_browser_version_at_start;
                add_asset-&gt;add(add_asset-&gt;inst, current_dir, asset_id, asset_name, args-&gt;undo_scope, should_select, args-&gt;ui, 0, 0);
            }
        }
        else
        {
            tm_logger_api-&gt;printf(TM_LOG_TYPE_INFO, &quot;import txt:cound not read %s\n&quot;, txt_file);
        }
    }
    else
    {
        tm_logger_api-&gt;printf(TM_LOG_TYPE_INFO, &quot;import txt:cound not find %s \n&quot;, txt_file);
    }
    tm_free(args-&gt;allocator, task, task-&gt;bytes);
}
</code></pre>
<h2 id="refactor-the-custom-ui-import-functionality"><a class="header" href="#refactor-the-custom-ui-import-functionality">Refactor the Custom UI Import Functionality</a></h2>
<p>The last step before in this part of the tutorial is to update what happens when the user picks a new file in the Properties View of the asset. We want this workflow to make use of the asynchronous import functionality we just added to make the user experience smoother. Besides, this will also remove some code duplication.</p>
<p>Let's reuse our import task. We just need to make sure it has all the data it needs.
We can check the documentation of <a href="https://ourmachinery.com/apidoc/foundation/asset_io.h.html#structtm_asset_io_import">tm_asset_io_import</a> to ensure we do not forget anything important. </p>
<p>Besides the name of the file we're importing, we also need:</p>
<ul>
<li>an allocator</li>
<li>the Truth to import into</li>
<li>the object to reimport into</li>
</ul>
<p>Now we can write our reimport task code:</p>
<pre><code class="language-c">            tm_allocator_i *allocator = tm_allocator_api-&gt;system;
            const uint64_t bytes = sizeof(struct task__import_txt) + strlen(file);
            struct task__import_txt *task = tm_alloc(allocator, bytes);
            *task = (struct task__import_txt){
                .bytes = bytes,
                .args = {
                    .allocator = allocator,
                    .tt = tt,
                    .reimport_into = object}};
            strcpy(task-&gt;file, file);
            task_system-&gt;run_task(task__import_txt, task, &quot;Import Text File&quot;);
</code></pre>
<p>We'll use the <code>system</code> allocator (a global allocator with the same lifetime as the program) to allocate our task, including the bytes needed for the file name string. Remember the layout of our struct:</p>
<pre><code class="language-c">// -- struct definitions
struct task__import_txt
{
    uint64_t bytes;
    struct tm_asset_io_import args;
    char file[8];
};
// .. other code
</code></pre>
<p>We fill out the struct with the needed data, copy the file name, and then ask the task system to run the task:</p>
<pre><code class="language-c">static float properties__custom_ui(struct tm_properties_ui_args_t *args, tm_rect_t item_rect, tm_tt_id_t object, uint32_t indent)
{
    tm_the_truth_o *tt = args-&gt;tt;
    bool picked = false;
    item_rect.y = tm_properties_view_api-&gt;ui_open_path(args, item_rect, TM_LOCALIZE_LATER(&quot;Import Path&quot;), TM_LOCALIZE_LATER(&quot;Path that the text file was imported from.&quot;), object, TM_TT_PROP__MY_ASSET__FILE, &quot;txt&quot;, &quot;text files&quot;, &amp;picked);
    if (picked)
    {
        const char *file = tm_the_truth_api-&gt;get_string(tt, tm_tt_read(tt, object), TM_TT_PROP__MY_ASSET__FILE);
        {
            tm_allocator_i *allocator = tm_allocator_api-&gt;system;
            const uint64_t bytes = sizeof(struct task__import_txt) + strlen(file);
            struct task__import_txt *task = tm_alloc(allocator, bytes);
            *task = (struct task__import_txt){
                .bytes = bytes,
                .args = {
                    .allocator = allocator,
                    .tt = tt,
                    .reimport_into = object}};
            strcpy(task-&gt;file, file);
            task_system-&gt;run_task(task__import_txt, task, &quot;Import Text File&quot;);
        }
    }
    return item_rect.y;
}
</code></pre>
<p><em>(For more information on the structure of these functions, please check the previous part)</em></p>
<ul>
<li><a href="#">Part 1</a></li>
<li><a href="#">Part 2</a></li>
</ul>
<h2 id="the-end"><a class="header" href="#the-end">The End</a></h2>
<p>This is the final part of this walkthrough. By now, you should have a better idea of:</p>
<ul>
<li>How to work with The Truth</li>
<li>How to create an asset</li>
<li>How to import assets into the Engine</li>
<li>How to create a custom UI. </li>
</ul>
<p>If you want to see a more complex example of an importer, look at the assimp importer example: <code>samples\plugins\assimp</code>.</p>
<h3 id="full-example-of-basic-asset"><a class="header" href="#full-example-of-basic-asset">Full Example of Basic Asset</a></h3>
<p><code>my_asset.h</code></p>
<pre><code class="language-c">#pragma once
#include &lt;foundation/api_types.h&gt;
//... more code
#define TM_TT_TYPE__MY_ASSET &quot;tm_my_asset&quot;
#define TM_TT_TYPE_HASH__MY_ASSET TM_STATIC_HASH(&quot;tm_my_asset&quot;, 0x1e12ba1f91b99960ULL)

enum
{
    TM_TT_PROP__MY_ASSET__FILE,
    TM_TT_PROP__MY_ASSET__DATA,
};
</code></pre>
<p>(Do not forget to run hash.exe when you create a <a href="https://ourmachinery.com/apidoc/foundation/api_types.h.html#tm_static_hash()">TM_STATIC_HASH</a>)</p>
<p><code>my_asset.c</code></p>
<pre><code class="language-c">// -- api's
static struct tm_api_registry_api *tm_global_api_registry;
static struct tm_the_truth_api *tm_the_truth_api;
static struct tm_properties_view_api *tm_properties_view_api;
static struct tm_os_api *tm_os_api;
static struct tm_path_api *tm_path_api;
static struct tm_temp_allocator_api *tm_temp_allocator_api;
static struct tm_logger_api *tm_logger_api;
static struct tm_localizer_api *tm_localizer_api;
static struct tm_asset_io_api *tm_asset_io_api;
static struct tm_task_system_api *task_system;
static struct tm_allocator_api *tm_allocator_api;
static struct tm_sprintf_api *tm_sprintf_api;

// -- inlcudes

#include &lt;foundation/api_registry.h&gt;
#include &lt;foundation/asset_io.h&gt;
#include &lt;foundation/buffer.h&gt;
#include &lt;foundation/carray_print.inl&gt;
#include &lt;foundation/localizer.h&gt;
#include &lt;foundation/log.h&gt;
#include &lt;foundation/macros.h&gt;
#include &lt;foundation/os.h&gt;
#include &lt;foundation/path.h&gt;
#include &lt;foundation/sprintf.h&gt;
#include &lt;foundation/string.inl&gt;
#include &lt;foundation/task_system.h&gt;
#include &lt;foundation/temp_allocator.h&gt;
#include &lt;foundation/the_truth.h&gt;
#include &lt;foundation/the_truth_assets.h&gt;
#include &lt;foundation/undo.h&gt;

#include &lt;plugins/editor_views/asset_browser.h&gt;
#include &lt;plugins/editor_views/properties.h&gt;

#include &quot;txt.h&quot;
// -- struct definitions
struct task__import_txt
{
    uint64_t bytes;
    struct tm_asset_io_import args;
    char file[8];
};
/////
// -- functions:
////
// --- importer
static void task__import_txt(void *data, uint64_t task_id)
{
    struct task__import_txt *task = (struct task__import_txt *)data;
    const struct tm_asset_io_import *args = &amp;task-&gt;args;
    const char *txt_file = task-&gt;file;
    tm_the_truth_o *tt = args-&gt;tt;
    tm_file_stat_t stat = tm_os_api-&gt;file_system-&gt;stat(txt_file);
    if (stat.exists)
    {
        tm_buffers_i *buffers = tm_the_truth_api-&gt;buffers(tt);
        void *buffer = buffers-&gt;allocate(buffers-&gt;inst, stat.size, false);
        tm_file_o f = tm_os_api-&gt;file_io-&gt;open_input(txt_file);
        const int64_t read = tm_os_api-&gt;file_io-&gt;read(f, buffer, stat.size);
        tm_os_api-&gt;file_io-&gt;close(f);
        if (read == (int64_t)stat.size)
        {
            const uint32_t buffer_id = buffers-&gt;add(buffers-&gt;inst, buffer, stat.size, 0);
            const tm_tt_type_t plugin_asset_type = tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__MY_ASSET);
            const tm_tt_id_t asset_id = tm_the_truth_api-&gt;create_object_of_type(tt, plugin_asset_type, TM_TT_NO_UNDO_SCOPE);
            tm_the_truth_object_o *asset_obj = tm_the_truth_api-&gt;write(tt, asset_id);
            tm_the_truth_api-&gt;set_buffer(tt, asset_obj, TM_TT_PROP__MY_ASSET__DATA, buffer_id);
            tm_the_truth_api-&gt;set_string(tt, asset_obj, TM_TT_PROP__MY_ASSET__FILE, txt_file);
            if (args-&gt;reimport_into.u64)
            {
                tm_the_truth_api-&gt;retarget_write(tt, asset_obj, args-&gt;reimport_into);
                tm_the_truth_api-&gt;commit(tt, asset_obj, args-&gt;undo_scope);
                tm_the_truth_api-&gt;destroy_object(tt, asset_id, args-&gt;undo_scope);
            }
            else
            {
                tm_the_truth_api-&gt;commit(tt, asset_obj, args-&gt;undo_scope);
                const char *asset_name = tm_path_api-&gt;base(tm_str(txt_file)).data;
                struct tm_asset_browser_add_asset_api *add_asset = tm_get_api(tm_global_api_registry, tm_asset_browser_add_asset_api);
                const tm_tt_id_t current_dir = add_asset-&gt;current_directory(add_asset-&gt;inst, args-&gt;ui);
                const bool should_select = args-&gt;asset_browser.u64 &amp;&amp; tm_the_truth_api-&gt;version(tt, args-&gt;asset_browser) == args-&gt;asset_browser_version_at_start;
                add_asset-&gt;add(add_asset-&gt;inst, current_dir, asset_id, asset_name, args-&gt;undo_scope, should_select, args-&gt;ui, 0, 0);
            }
        }
        else
        {
            tm_logger_api-&gt;printf(TM_LOG_TYPE_INFO, &quot;import txt:cound not read %s\n&quot;, txt_file);
        }
    }
    else
    {
        tm_logger_api-&gt;printf(TM_LOG_TYPE_INFO, &quot;import txt:cound not find %s \n&quot;, txt_file);
    }
    tm_free(args-&gt;allocator, task, task-&gt;bytes);
}

static bool asset_io__enabled(struct tm_asset_io_o *inst)
{
    return true;
}
static bool asset_io__can_import(struct tm_asset_io_o *inst, const char *extension)
{
    return tm_strcmp_ignore_case(extension, &quot;txt&quot;) == 0;
}
static bool asset_io__can_reimport(struct tm_asset_io_o *inst, struct tm_the_truth_o *tt, tm_tt_id_t asset)
{
    const tm_tt_id_t object = tm_the_truth_api-&gt;get_subobject(tt, tm_tt_read(tt, asset), TM_TT_PROP__ASSET__OBJECT);
    return object.type == tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__MY_ASSET).u64;
}
static void asset_io__importer_extensions_string(struct tm_asset_io_o *inst, char **output, struct tm_temp_allocator_i *ta, const char *separator)
{
    tm_carray_temp_printf(output, ta, &quot;txt&quot;);
}
static void asset_io__importer_description_string(struct tm_asset_io_o *inst, char **output, struct tm_temp_allocator_i *ta, const char *separator)
{
    tm_carray_temp_printf(output, ta, &quot;.txt&quot;);
}
static uint64_t asset_io__import_asset(struct tm_asset_io_o *inst, const char *file, const struct tm_asset_io_import *args)
{
    const uint64_t bytes = sizeof(struct task__import_txt) + strlen(file);
    struct task__import_txt *task = tm_alloc(args-&gt;allocator, bytes);
    *task = (struct task__import_txt){
        .bytes = bytes,
        .args = *args,
    };
    strcpy(task-&gt;file, file);
    return task_system-&gt;run_task(task__import_txt, task, &quot;Import Text File&quot;);
}
static struct tm_asset_io_i txt_asset_io = {
    .enabled = asset_io__enabled,
    .can_import = asset_io__can_import,
    .can_reimport = asset_io__can_reimport,
    .importer_extensions_string = asset_io__importer_extensions_string,
    .importer_description_string = asset_io__importer_description_string,
    .import_asset = asset_io__import_asset};

// -- asset on its own

//custom ui
static float properties__custom_ui(struct tm_properties_ui_args_t *args, tm_rect_t item_rect, tm_tt_id_t object, uint32_t indent)
{
    tm_the_truth_o *tt = args-&gt;tt;
    bool picked = false;
    item_rect.y = tm_properties_view_api-&gt;ui_open_path(args, item_rect, TM_LOCALIZE_LATER(&quot;Import Path&quot;), TM_LOCALIZE_LATER(&quot;Path that the text file was imported from.&quot;), object, TM_TT_PROP__MY_ASSET__FILE, &quot;txt&quot;, &quot;text files&quot;, &amp;picked);
    if (picked)
    {
        const char *file = tm_the_truth_api-&gt;get_string(tt, tm_tt_read(tt, object), TM_TT_PROP__MY_ASSET__FILE);
        {
            tm_allocator_i *allocator = tm_allocator_api-&gt;system;
            const uint64_t bytes = sizeof(struct task__import_txt) + strlen(file);
            struct task__import_txt *task = tm_alloc(allocator, bytes);
            *task = (struct task__import_txt){
                .bytes = bytes,
                .args = {
                    .allocator = allocator,
                    .tt = tt,
                    .reimport_into = object}};
            strcpy(task-&gt;file, file);
            task_system-&gt;run_task(task__import_txt, task, &quot;Import Text File&quot;);
        }
    }
    return item_rect.y;
}

// -- create truth type
static void create_truth_types(struct tm_the_truth_o *tt)
{
    static tm_the_truth_property_definition_t my_asset_properties[] = {
        {&quot;import_path&quot;, TM_THE_TRUTH_PROPERTY_TYPE_STRING},
        {&quot;data&quot;, TM_THE_TRUTH_PROPERTY_TYPE_BUFFER},
    };
    const tm_tt_type_t type = tm_the_truth_api-&gt;create_object_type(tt, TM_TT_TYPE__MY_ASSET, my_asset_properties, TM_ARRAY_COUNT(my_asset_properties));
    tm_the_truth_api-&gt;set_aspect(tt, type, TM_TT_ASPECT__FILE_EXTENSION, &quot;txt&quot;);
    static tm_properties_aspect_i properties_aspect = {
        .custom_ui = properties__custom_ui,
    };
    tm_the_truth_api-&gt;set_aspect(tt, type, TM_TT_ASPECT__PROPERTIES, &amp;properties_aspect);
}

// -- asset browser regsiter interface
static tm_tt_id_t asset_browser_create(struct tm_asset_browser_create_asset_o *inst, tm_the_truth_o *tt, tm_tt_undo_scope_t undo_scope)
{
    const tm_tt_type_t type = tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__MY_ASSET);
    return tm_the_truth_api-&gt;create_object_of_type(tt, type, undo_scope);
}
static tm_asset_browser_create_asset_i asset_browser_create_my_asset = {
    .menu_name = TM_LOCALIZE_LATER(&quot;New Text File&quot;),
    .asset_name = TM_LOCALIZE_LATER(&quot;New Text File&quot;),
    .create = asset_browser_create,
};

// -- load plugin
TM_DLL_EXPORT void tm_load_plugin(struct tm_api_registry_api *reg, bool load)
{
    tm_the_truth_api = tm_get_api(reg, tm_the_truth_api);
    tm_properties_view_api = tm_get_api(reg, tm_properties_view_api);
    tm_os_api = tm_get_api(reg, tm_os_api);
    tm_path_api = tm_get_api(reg, tm_path_api);
    tm_temp_allocator_api = tm_get_api(reg, tm_temp_allocator_api);
    tm_allocator_api = tm_get_api(reg, tm_allocator_api);
    tm_logger_api = tm_get_api(reg, tm_logger_api);
    tm_localizer_api = tm_get_api(reg, tm_localizer_api);
    tm_asset_io_api = tm_get_api(reg, tm_asset_io_api);
    task_system = tm_get_api(reg, tm_task_system_api);
    tm_sprintf_api = tm_get_api(reg, tm_sprintf_api);
    tm_global_api_registry = reg;
    if (load)
        tm_asset_io_api-&gt;add_asset_io(&amp;txt_asset_io);
    else
        tm_asset_io_api-&gt;remove_asset_io(&amp;txt_asset_io);
    tm_add_or_remove_implementation(reg, load, tm_the_truth_create_types_i, create_truth_types);
    tm_add_or_remove_implementation(reg, load, tm_asset_browser_create_asset_i, &amp;asset_browser_create_my_asset);
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="../../the_truth/custom_asset/part2.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="../../the_truth/drag_and_drop.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="../../the_truth/custom_asset/part2.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="../../the_truth/drag_and_drop.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        
    </body>
</html>
