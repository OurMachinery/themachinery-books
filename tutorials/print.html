<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Machinery Tutorial Book</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Welcome</a></li><li class="chapter-item expanded "><a href="creation_graph/index.html"><strong aria-hidden="true">2.</strong> Creation Graph</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="creation_graph/custom_gpu_nodes.html"><strong aria-hidden="true">2.1.</strong> Creating custom GPU nodes</a></li><li class="chapter-item expanded "><a href="creation_graph/custom_cpu_nodes.html"><strong aria-hidden="true">2.2.</strong> Creating custom CPU nodes</a></li><li class="chapter-item expanded "><a href="creation_graph/from_code.html"><strong aria-hidden="true">2.3.</strong> Calling Creation Graphs from code</a></li></ol></li><li class="chapter-item expanded "><a href="physics/index.html"><strong aria-hidden="true">3.</strong> Physics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="physics/triggers.html"><strong aria-hidden="true">3.1.</strong> Triggers</a></li></ol></li><li class="chapter-item expanded "><a href="the_truth/index.html"><strong aria-hidden="true">4.</strong> The Truth</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="the_truth/custom_asset/index.html"><strong aria-hidden="true">4.1.</strong> Creating a custom asset</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="the_truth/custom_asset/part1.html"><strong aria-hidden="true">4.1.1.</strong> Part 1 - Create an Asset Truth Type, Addable via Asset Browser</a></li><li class="chapter-item expanded "><a href="the_truth/custom_asset/part2.html"><strong aria-hidden="true">4.1.2.</strong> Part 2 - Custom UI</a></li><li class="chapter-item expanded "><a href="the_truth/custom_asset/part3.html"><strong aria-hidden="true">4.1.3.</strong> Part 3 - Custom Importer</a></li></ol></li><li class="chapter-item expanded "><a href="the_truth/drag_and_drop.html"><strong aria-hidden="true">4.2.</strong> Adding Drag and Drop to Assets</a></li><li class="chapter-item expanded "><a href="the_truth/open_asset.html"><strong aria-hidden="true">4.3.</strong> Open Asset in Tab</a></li></ol></li><li class="chapter-item expanded "><a href="ui/index.html"><strong aria-hidden="true">5.</strong> UI</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ui/build_custom_ui_controls/index.html"><strong aria-hidden="true">5.1.</strong> Build Custom UI Controls</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ui/build_custom_ui_controls/part1.html"><strong aria-hidden="true">5.1.1.</strong> Part 1</a></li></ol></li><li class="chapter-item expanded "><a href="ui/toolbars-overlays.html"><strong aria-hidden="true">5.2.</strong> Toolbars and Overlays</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">The Machinery Tutorial Book</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/OurMachinery/themachinery-books" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="welcome"><a class="header" href="#welcome">Welcome</a></h1>
<p>Hi,</p>
<p>This book is here to give you guidance on how to work with the engine. We are constantly working on improving the onboarding as much as possible. If you have not read about the basic concepts of the engine you might want to start at there before you move on to this book <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/index.html">The Machinery Book</a>.</p>
<p>Besides this book we have several other resources which might be good to checkout:</p>
<ul>
<li><a href="https://ourmachinery.com/apidoc/apidoc.html">Our API Documentation</a></li>
<li><a href="https://ourmachinery.com/post/">Our Blog</a></li>
<li><a href="https://anchor.fm/ourmachinery">Our Podcast</a></li>
<li><a href="https://discord.gg/SHHSZaH">Our Discord</a></li>
<li><a href="https://github.com/OurMachinery/themachinery-public/discussions">Our Github Discussion Board</a></li>
</ul>
<p>Enjoy!</p>
<p><em>The Machinery Team</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creation-graph"><a class="header" href="#creation-graph">Creation Graph</a></h1>
<p>In The Machinery, we provide full control over how data enters the engine and what data-processing
steps that get executed, allowing technical artists to better optimize content and setup custom,
game-specific asset pipelines. </p>
<p>This is handled through <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book//creation_graphs/concept.html"><em>Creation Graphs</em></a>. A Creation Graph is essentially a generic framework for
processing arbitrary data on the CPUs and GPUs, exposed through a graph front-end view. While we can
use <em>Creation Graphs</em> for any type of data processing.</p>
<p>The following section will guide you from basic use cases to more advanced use cases.</p>
<p>We have a couple of blog posts which might also be a valid source of information and interesting to
you.</p>
<ul>
<li><a href="https://ourmachinery.com/post/creation-graphs/">Creation Graphs</a></li>
<li><a href="https://ourmachinery.com/post/more-on-creation-graphs/">More on Creation Graphs</a></li>
<li><a href="https://ourmachinery.com/post/summer-fun-with-creation-graphs/">Summer Fun with Creation Graphs</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-gpu-nodes"><a class="header" href="#custom-gpu-nodes">Custom GPU nodes</a></h1>
<p>The <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book//creation_graphs/concept.html"><em>Creation Graph</em></a> is a powerful visual scripting language that can generate shader code through its GPU nodes. Extending this with custom nodes allows for more complex algorithms, custom material types and much more. In this tutorial we will demonstrate how to create some basic GPU nodes. To learn the difference between CPU and GPU nodes, check out <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book//creation_graphs/node_types.html"><em>Node Types</em></a>. </p>
<p>A creation graph CPU node needs to be in a <code>.tmsl</code> file, these can be compiled by the shader system. Note that there can only be <strong>one</strong> creation graph node per <code>.tmsl</code> file, additional definitions will be ignored. If these shaders are places in the <code>bin/data/shaders/</code> directory then they will be loaded automatically. For a full reference on the shader files, check out the <a href="https://ourmachinery.com/apidoc/doc/shader_system_reference.md.html">Shader System Reference</a>.</p>
<h2 id="cube-node"><a class="header" href="#cube-node">Cube Node</a></h2>
<p><img src="https://www.dropbox.com/s/z6faxvwm0sb7i9o/tut_creation_graph_custom_cube.png?dl=1" alt="" /></p>
<pre><code class="language-json">function: [[
	output.res = x * x * x;
]]

creation_graph_node: {
	name: &quot;tm_cube_node&quot;
	display_name: &quot;Cube&quot;
	category: &quot;Shader/Math&quot;

	inputs: [ 
		{ name: &quot;x&quot; display_name: &quot;X&quot; } 
	]
	outputs: [
		{ name: &quot;res&quot; display_name: &quot;Result&quot; type: { type_of: &quot;x&quot; } }
	]
}
</code></pre>
<p>This node show you the absolute basics of making a creation graph GPU node. All GPU nodes require two blocks. The <code>function</code> block is where you actual shader code will end up. The <code>creation_graph_node</code> is a meta node that defines you node I/O and general information.</p>
<p>In this example the <code>creation_graph_node</code> has several fields, but more can be defined:</p>
<ul>
<li><code>name</code> is the unique identifier for you node, it’s a good idea to prefix this with your namespace.</li>
<li><code>display_name</code> specifies an optional name of the node shown in the editor UI, if this is not defined then the node will get an automatically generated name based on the <code>name</code> field.</li>
<li><code>category</code> is an optional path-type string that allows you to group related nodes.</li>
<li><code>inputs</code> is an array of input parameters for this node, a type can be specified, but it is not required which allows for generic types.</li>
<li><code>outputs</code> is an array of output parameters for this node.</li>
</ul>
<p>Note that we didn’t specify a <code>type</code> parameter for our input field. This makes it a fuzzy input and anything that supports the multiplication operator can be passed. Our output parameter does have a <code>type</code> field, but instead of defining a fixed type it uses a generic syntax that sets the output type to whatever the input type was. For more information about this syntax see the <a href="https://ourmachinery.com/apidoc/doc/shader_system_reference.md.html">Shader System Reference</a>.</p>
<h2 id="depth-output-node"><a class="header" href="#depth-output-node">Depth Output Node</a></h2>
<p><img src="https://www.dropbox.com/s/o947fbjy9uddltn/tut_creation_graph_custom_depth_output.png?dl=1" alt="" /></p>
<p>Output nodes are more complex than function nodes. Instead of a single <code>function</code> block these nodes that the form of a render pass that can have variations based on the systems used with it and the connected inputs. The example above creates a very simple material node that displays a gray-scale interpretation of the object’s distance to the viewing camera.</p>
<pre><code class="language-json">depth_stencil_states: {
	depth_test_enable: true
	depth_write_enable: true
	depth_compare_op: &quot;greater_equal&quot;
}

raster_states: {
	front_face: &quot;ccw&quot;
}

imports: [
	{ name: &quot;tm&quot; type: &quot;float4x4&quot; }
]

vertex_shader: {
	import_system_semantics: [ &quot;vertex_id&quot; ]

	code: [[
		tm_vertex_loader_context ctx;
		init_vertex_loader_context(ctx);
		float4 vp = load_position(ctx, vertex_id, 0);

		float4 wp = mul(vp, load_tm());
		output.position = mul(wp, load_camera_view_projection());
		return output;
	]]
}

pixel_shader: {
	code: [[
		float2 near_far = load_camera_near_far();
		float depth = linearize_depth(input.position.z, near_far.x, near_far.y) * 0.01f;

		output.buffer0 = float4(linear_to_gamma2(depth), 1); // Base color, alpha
		output.buffer1 = float4(1, 1, 0, 1); // Normal (encoded in signed oct)
		output.buffer2 = float4(0, 0, 0, 1); // Specular, Roughness
		output.velocity = float2(0, 0);
		return output;
	]]
}
</code></pre>
<p>The <code>creation_graph_node</code> block for this node is very small. If no outputs are specified then the output will be a <code>Shader Instance</code>. These can be passed to other nodes for rendering like the <code>Draw Call</code> and <code>Shader Instance</code> output node.</p>
<pre><code class="language-json">creation_graph_node: {
	name: &quot;depth_output&quot;
	display_name: &quot;Depth&quot;
	category: &quot;Shader/Output&quot;
}
</code></pre>
<p>In this example the <code>compile</code> block has the following fields:</p>
<ul>
<li><code>includes</code> specify which common shaders this shader is dependent on. In this example that is the <code>common.tmsl</code> shader because we use the <code>linear_to_gamma2</code> function.</li>
<li><code>contexts</code> specifies how this pass should be executed depending on the context. In this example we only support one context, the <code>viewport</code>. In this context we want to run during the <code>gbuffer</code> phase so we specify that as our layer. We also want to enable the <code>gbuffer_system</code> as we will be writing to it. Finally we specify that in this context we will enable the <code>gbuffer</code> configuration.</li>
<li><code>configurations</code> are groups of settings. In this example we have one configuration group: <code>gbuffer</code>. This configuration requests three systems, if these systems are not present then we cannot run:
<ul>
<li>The <code>viewer_system</code> is needed to query the camera information.</li>
<li>The <code>gbuffer_system</code> allows us to render to the G-Buffer in the opaque pass of the default-render-pipeline.</li>
<li>The <code>vertex_buffer_system</code> allows us to query vertex information from the mesh.</li>
</ul>
</li>
</ul>
<pre><code class="language-json">compile: {
	includes: [ &quot;common&quot; ]

	configurations: {
		gbuffer: [{ 
			variations: [{ 
				systems: [ &quot;viewer_system&quot;, &quot;gbuffer_system&quot;, &quot;vertex_buffer_system&quot; ]
			}]
		}]
	}

	contexts: {
		viewport: [
			{ layer: &quot;gbuffer&quot; enable_systems: [ &quot;gbuffer_system&quot; ] configuration: &quot;gbuffer&quot; }
		]
	}
}
</code></pre>
<blockquote>
<p><strong>Note</strong> that the available contexts are defined by the application. Some example of these in The Machinery editor are <code>viewport</code>, <code>shadow_caster</code> and <code>ray_trace_material</code>. </p>
</blockquote>
<blockquote>
<p><strong>Note</strong> that layers are defined by the render pipeline used. Some examples from the default render pipeline are: <code>gbuffer</code>, <code>skydome</code>, <code>hdr-transparency</code>, <code>ui</code>. </p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-custom-cpu-nodes"><a class="header" href="#creating-custom-cpu-nodes">Creating custom CPU nodes</a></h1>
<p>In this tutorial we will create a simple CPU node for the <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book//creation_graphs/concept.html"><em>Creation Graph</em></a>. The definition for these nodes is based on the entity graph nodes, so there is some overlap. The goal for our example node is a random <code>uint32_t</code> node with a settable maximum. To learn the difference between CPU and GPU nodes, check out <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book//creation_graphs/node_types.html"><em>Node Types</em></a>.</p>
<p><img src="https://www.dropbox.com/s/04s5rzhmg9iwz68/tut_creation_graph_cpu_random.png?dl=1" alt="" /></p>
<p>Let’s first create the code for this node. This function will be called by the creation graph every time it needs to evaluate the node. Our only input to this function is the context of the creation graph. The first thing we will do is read our input from the context. We can query wires from the <a href="https://ourmachinery.com/apidoc/plugins/creation_graph/creation_graph_interpreter.h.html#structtm_creation_graph_interpreter_api">tm_creation_graph_interpreter_api</a> using the <code>read_wire</code> function. If this wire is not connect (or set directly) we early out with an error. After this we start writing to our output wire, note that this uses a very similar syntax, expect that we write to a pre-allocated pointer.</p>
<blockquote>
<p><strong>Note</strong> that the indices of these wires is relative to the way they are defined. Our input wire is defined first so its index is zero. The output wire is defined second so it gets the index one.</p>
</blockquote>
<pre><code class="language-c">static void random_node__run(tm_creation_graph_interpreter_context_t *ctx)
{
	tm_creation_graph_interpreter_wire_content_t max_wire = tm_creation_graph_interpreter_api-&gt;read_wire(ctx-&gt;instance, ctx-&gt;wires[0]);
	if (!TM_ASSERT(max_wire.n, tm_error_api-&gt;def, &quot;Max wire was not connected to random node!&quot;))
		return;

	uint32_t *res = (uint32_t *)tm_creation_graph_interpreter_api-&gt;write_wire(ctx-&gt;instance, ctx-&gt;wires[1], TM_TT_TYPE_HASH__UINT32_T, 1, sizeof(uint32_t));
	*res = tm_random_to_uint32_t(tm_random_api-&gt;next()) % *(uint32_t *)max_wire.data;
}
</code></pre>
<p>We need to register this node to the creation graph API. This is done through the creation graph node interface. We define the general information to the node like its <code>name</code>, <code>display_name</code> and I/O connectors (wires), and the actual function to run.</p>
<pre><code class="language-c">static tm_creation_graph_node_type_i random_node = {
	.name = &quot;tm_random&quot;,
	.display_name = &quot;Random Uint&quot;,
	.static_connectors.in = {
		{ .name = &quot;max&quot;, .display_name = &quot;Max&quot;, .type_hash = TM_TT_TYPE_HASH__UINT32_T }
	},
	.static_connectors.num_in = 1,
	.static_connectors.out = {
		{ .name = &quot;res&quot;, .display_name = &quot;Result&quot;, .type_hash = TM_TT_TYPE_HASH__UINT32_T }
	},
	.static_connectors.num_out = 1,
	.run = random_node__run
};

tm_add_or_remove_implementation(reg, load, TM_CREATION_GRAPH_NODE_INTERFACE_NAME, &amp;random_node);
</code></pre>
<p>This is the full code to define this creation graph CPU node.</p>
<pre><code class="language-c">static struct tm_error_api *tm_error_api;
static struct tm_random_api *tm_random_api;
static struct tm_creation_graph_interpreter_api *tm_creation_graph_interpreter_api;

#include &lt;foundation/api_registry.h&gt;
#include &lt;foundation/error.h&gt;
#include &lt;foundation/random.h&gt;
#include &lt;foundation/the_truth_types.h&gt;

#include &lt;plugins/creation_graph/creation_graph.h&gt;
#include &lt;plugins/creation_graph/creation_graph_interpreter.h&gt;
#include &lt;plugins/creation_graph/creation_graph_node_type.h&gt;

static void random_node__run(tm_creation_graph_interpreter_context_t *ctx)
{
	tm_creation_graph_interpreter_wire_content_t max_wire = tm_creation_graph_interpreter_api-&gt;read_wire(ctx-&gt;instance, ctx-&gt;wires[0]);
	if (!TM_ASSERT(max_wire.n, tm_error_api-&gt;def, &quot;Max wire was not connected to random node!&quot;))
		return;

	uint32_t *res = (uint32_t *)tm_creation_graph_interpreter_api-&gt;write_wire(ctx-&gt;instance, ctx-&gt;wires[1], TM_TT_TYPE_HASH__UINT32_T, 1, sizeof(uint32_t));
	*res = tm_random_to_uint32_t(tm_random_api-&gt;next()) % *(uint32_t *)max_wire.data;
}

static tm_creation_graph_node_type_i random_node = {
	.name = &quot;tm_random&quot;,
	.display_name = &quot;Random Uint&quot;,
	.static_connectors.in = {
		{ .name = &quot;max&quot;, .display_name = &quot;Max&quot;, .type_hash = TM_TT_TYPE_HASH__UINT32_T }
	},
	.static_connectors.num_in = 1,
	.static_connectors.out = {
		{ .name = &quot;res&quot;, .display_name = &quot;Result&quot;, .type_hash = TM_TT_TYPE_HASH__UINT32_T }
	},
	.static_connectors.num_out = 1,
	.run = random_node__run
};

TM_DLL_EXPORT void tm_load_plugin(struct tm_api_registry_api *reg, bool load)
{
	tm_error_api = reg-&gt;get(TM_ERROR_API_NAME);
	tm_random_api = reg-&gt;get(TM_RANDOM_API_NAME);
	tm_creation_graph_interpreter_api = reg-&gt;get(TM_CREATION_GRAPH_INTERPRETER_API_NAME);

	tm_add_or_remove_implementation(reg, load, TM_CREATION_GRAPH_NODE_INTERFACE_NAME, &amp;random_node);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calling-creation-graphs-from-code"><a class="header" href="#calling-creation-graphs-from-code">Calling creation graphs from code</a></h1>
<p>In this tutorial we will create a very simple component that uses a <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book//creation_graphs/concept.html">creation graph</a> to render to the viewport. The creation graph used for this example can be seen in the image below.</p>
<p>The goal of this creation graph is to create an image output that we can copy to the viewport. In this example the image is created by the creation graph and the viewport UV is rendered onto it using and unlit pass. Notice that no geometry has to be defined as we use the <code>Construct Quad</code> node in clip space, this will procedurally encompass the entire viewport.</p>
<p><strong>Contents</strong></p>
<ul>
<li><a href="creation_graph/from_code.html#using-the-creation-graph-api">Using the creation graph API</a></li>
<li><a href="creation_graph/from_code.html#remarks">Remarks</a></li>
<li><a href="creation_graph/from_code.html#full-code">Full Code</a></li>
</ul>
<p><img src="https://www.dropbox.com/s/k4y8wlwx7y8vll3/tm_tut_creation_graphs_from_code.png?dl=1" alt="" /></p>
<h2 id="using-the-creation-graph-api"><a class="header" href="#using-the-creation-graph-api">Using the creation graph API</a></h2>
<p>The component itself is very simple, it only has a single property which is our creation graph asset.</p>
<pre><code class="language-c">static const tm_the_truth_property_definition_t properties[] = {
	[TM_TT_PROP__CREATION_GRAPH_TEST_COMPONENT__CREATION_GRAPH] = { &quot;creation_graph&quot;, TM_THE_TRUTH_PROPERTY_TYPE_SUBOBJECT, .type_hash = TM_TT_TYPE_HASH__CREATION_GRAPH }
};
</code></pre>
<p>However multiple fields are defined in the runtime component struct, all of these are dependent on our creation graph.</p>
<pre><code class="language-c">typedef struct tm_component_t
{
	// The truth ID of the creation graph subobject.
	tm_tt_id_t creation_graph;
	// An instance of the `creation_graph` (created in `shader_ci__init`).
	tm_creation_graph_instance_t instance;

	// The handle to the output image.
	tm_renderer_handle_t image_handle;
	// The resource state of the output image.
	uint32_t resource_state;
	// The description of the output image.
	tm_renderer_image_desc_t desc;
	// The name of the output image.
	tm_strhash_t name;
} tm_component_t;
</code></pre>
<p>In the example we only call the creation graph once (during the initialization phase). The workflow is as follows. 
The creation graph subobject is added by The Truth, so we don’t have to do any UI or linking code for it. 
In the initialize function we instantiate this creation graph asset with a default context. 
This updates our image output node and all the nodes it is dependent upon. </p>
<pre><code class="language-c">tm_creation_graph_context_t ctx = {
	.rb = manager-&gt;rb,
	.device_affinity_mask = TM_RENDERER_DEVICE_AFFINITY_MASK_ALL,
	.entity_ctx = manager-&gt;ctx,
	.tt = tm_entity_api-&gt;the_truth(manager-&gt;ctx)
};

for (uint32_t i = 0; i &lt; num_components; ++i) {
	
	// Skip any component that don't have a creation graph defined.
	tm_component_t *cur = cdata[i];
	if (!cur-&gt;creation_graph.u64)
		continue;

	// Instantiate the creation graph if this is the first time.
	if (!cur-&gt;instance.graph.u64)
		cur-&gt;instance = tm_creation_graph_api-&gt;create_instance(ctx.tt, cur-&gt;creation_graph, &amp;ctx);
}
</code></pre>
<p>Next we query all the image output nodes from the graph, and pick the first one. This information we get from the output node is enough to copy our image to the viewport. </p>
<pre><code class="language-c">// Query the creation graph for image outputs, if non are defined then we skip the update step.
tm_creation_graph_output_t image_outputs = tm_creation_graph_api-&gt;output(&amp;cur-&gt;instance, TM_CREATION_GRAPH__IMAGE__OUTPUT_NODE_HASH, &amp;ctx, NULL);
if (image_outputs.num_output_objects &gt; 0) {
	const tm_creation_graph_image_data_t *image_data = (const tm_creation_graph_image_data_t *)image_outputs.output;

	cur-&gt;image_handle = image_data-&gt;handle;
	cur-&gt;resource_state = image_data-&gt;resource_state;
	cur-&gt;desc = image_data-&gt;desc;
	cur-&gt;name = image_data-&gt;resource_name;
}
</code></pre>
<p>To do this we register it to the viewports render graph using <code>register_gpu_image</code> and then pass it to the <code>debug_visualization_resources</code> for easy rendering to the screen.</p>
<pre><code class="language-c">// Loop through all components until we find one that has a valid image output.
uint32_t i;
const tm_component_t **cdata = (const tm_component_t **)data;
for (i = 0; i &lt; num_components; ++i) {
	const tm_component_t *cur = cdata[i];
	if (!cur-&gt;image_handle.resource)
		continue;

	tm_render_graph_api-&gt;register_gpu_image(args-&gt;render_graph, cur-&gt;name, cur-&gt;image_handle, cur-&gt;resource_state, &amp;cur-&gt;desc);
	break;
}

// None of the components had a valid image output, so skip the copy step.
if (i == num_components)
	return;

// Instead of making our own copy call, the debug visualization pass is used to copy to the viewport.
// This is not a proper copy, but it's good enough for this tutorial.
tm_render_graph_blackboard_value value;
tm_render_graph_api-&gt;read_blackboard(args-&gt;render_graph, TM_STATIC_HASH(&quot;debug_visualization_resources&quot;, 0xd0d50436a0f3fcb9ULL), &amp;value);
tm_debug_visualization_resources_t *resources = (tm_debug_visualization_resources_t *)value.data;

const uint32_t slot = resources-&gt;num_resources;
resources-&gt;resources[slot].name = cdata[i]-&gt;name,
resources-&gt;resources[slot].contents = CONTENT_COLOR_RGB;
++resources-&gt;num_resources;
</code></pre>
<h2 id="remarks"><a class="header" href="#remarks">Remarks</a></h2>
<p>Note that this is a very simple example of the creation graph, we don’t update it every frame so it will only render once. This makes use of the <code>Time</code> node useless in this example. Note as well that we are not triggering any wires, this also means that the <code>Init event</code> node will never be called by the component. </p>
<p>Note as well that all destruction code has been omitted from the code sample to shorten it. In a production implementation the creation graph instance and the component should be destroyed.</p>
<h2 id="full-code"><a class="header" href="#full-code">Full Code</a></h2>
<pre><code class="language-c">static struct tm_allocator_api *tm_allocator_api;
static struct tm_api_registry_api *tm_api_registry_api;
static struct tm_creation_graph_api *tm_creation_graph_api;
static struct tm_entity_api *tm_entity_api;
static struct tm_render_graph_api *tm_render_graph_api;
static struct tm_shader_system_api *tm_shader_system_api;
static struct tm_the_truth_api *tm_the_truth_api;

#include &lt;foundation/allocator.h&gt;
#include &lt;foundation/api_registry.h&gt;
#include &lt;foundation/macros.h&gt;
#include &lt;foundation/the_truth.h&gt;

#include &lt;plugins/creation_graph/creation_graph.h&gt;
#include &lt;plugins/creation_graph/creation_graph_output.inl&gt;
#include &lt;plugins/creation_graph/image_nodes.h&gt;
#include &lt;plugins/editor_views/graph.h&gt;
#include &lt;plugins/entity/entity.h&gt;
#include &lt;plugins/render_graph/render_graph.h&gt;
#include &lt;plugins/render_graph_toolbox/toolbox_common.h&gt;
#include &lt;plugins/renderer/render_backend.h&gt;
#include &lt;plugins/renderer/render_command_buffer.h&gt;
#include &lt;plugins/shader_system/shader_system.h&gt;
#include &lt;plugins/the_machinery_shared/component_interfaces/editor_ui_interface.h&gt;
#include &lt;plugins/the_machinery_shared/component_interfaces/shader_interface.h&gt;
#include &lt;plugins/the_machinery_shared/render_context.h&gt;

#include &lt;string.h&gt;

#define TM_TT_TYPE__CREATION_GRAPH_TEST_COMPONENT &quot;tm_creation_graph_test_component&quot;

enum {
	TM_TT_PROP__CREATION_GRAPH_TEST_COMPONENT__CREATION_GRAPH
};

typedef struct tm_component_t
{
	// The truth ID of the creation graph subobject.
	tm_tt_id_t creation_graph;
	// An instance of the `creation_graph` (created in `shader_ci__init`).
	tm_creation_graph_instance_t instance;

	// The handle to the output image.
	tm_renderer_handle_t image_handle;
	// The resource state of the output image.
	uint32_t resource_state;
	// The description of the output image.
	tm_renderer_image_desc_t desc;
	// The name of the output image.
	tm_strhash_t name;
} tm_component_t;

typedef struct tm_component_manager_o
{
	tm_allocator_i allocator;
	tm_entity_context_o *ctx;
	tm_renderer_backend_i *rb;
} tm_component_manager_o;

// This function is called when the component is initialized,
// this happens at engine startup for the scene tab, 
// at the start of the simulation for the simulate tab,
// or once an entity is selected for the preview tab.
static void shader_ci__init(tm_component_manager_o *manager, const tm_entity_t *entities, const uint32_t *entity_indices, void **data, uint32_t num_components)
{
	tm_component_t **cdata = (tm_component_t **)data;

	// Create the context for the creation graph, only the bare minimum is defined for this tutorial.
	// This is not production-level code.
	tm_creation_graph_context_t ctx = {
		.rb = manager-&gt;rb,
		.device_affinity_mask = TM_RENDERER_DEVICE_AFFINITY_MASK_ALL,
		.entity_ctx = manager-&gt;ctx,
		.tt = tm_entity_api-&gt;the_truth(manager-&gt;ctx)
	};

	for (uint32_t i = 0; i &lt; num_components; ++i) {
		
		// Skip any component that don't have a creation graph defined.
		tm_component_t *cur = cdata[i];
		if (!cur-&gt;creation_graph.u64)
			continue;

		// Instantiate the creation graph if this is the first time.
		if (!cur-&gt;instance.graph.u64)
			cur-&gt;instance = tm_creation_graph_api-&gt;create_instance(ctx.tt, cur-&gt;creation_graph, &amp;ctx);

		// Query the creation graph for image outputs, if non are defined then we skip the update step.
		tm_creation_graph_output_t image_outputs = tm_creation_graph_api-&gt;output(&amp;cur-&gt;instance, TM_CREATION_GRAPH__IMAGE__OUTPUT_NODE_HASH, &amp;ctx, NULL);
		if (image_outputs.num_output_objects &gt; 0) {
			const tm_creation_graph_image_data_t *image_data = (const tm_creation_graph_image_data_t *)image_outputs.output;

			cur-&gt;image_handle = image_data-&gt;handle;
			cur-&gt;resource_state = image_data-&gt;resource_state;
			cur-&gt;desc = image_data-&gt;desc;
			cur-&gt;name = image_data-&gt;resource_name;
		}
	}
}

// This function is called every frame and allows us to update our shader variables.
static void shader_ci__update(tm_component_manager_o *manager, tm_render_args_t *args, const tm_entity_t *entities,
	const struct tm_transform_component_t *transforms, const uint32_t *entity_indices, void **data,
	uint32_t num_components, const uint8_t *frustum_visibilty)
{

	// Loop through all components until we find one that has a valid image output.
	uint32_t i;
	const tm_component_t **cdata = (const tm_component_t **)data;
	for (i = 0; i &lt; num_components; ++i) {
		const tm_component_t *cur = cdata[i];
		if (!cur-&gt;image_handle.resource)
			continue;

		tm_render_graph_api-&gt;register_gpu_image(args-&gt;render_graph, cur-&gt;name, cur-&gt;image_handle, cur-&gt;resource_state, &amp;cur-&gt;desc);
		break;
	}

	// None of the components had a valid image output, so skip the copy step.
	if (i == num_components)
		return;

	// Instead of making our own copy call, the debug visualization pass is used to copy to the viewport.
	// This is not a proper copy, but it's good enough for this tutorial.
	tm_render_graph_blackboard_value value;
	tm_render_graph_api-&gt;read_blackboard(args-&gt;render_graph, TM_STATIC_HASH(&quot;debug_visualization_resources&quot;, 0xd0d50436a0f3fcb9ULL), &amp;value);
	tm_debug_visualization_resources_t *resources = (tm_debug_visualization_resources_t *)value.data;

	const uint32_t slot = resources-&gt;num_resources;
	resources-&gt;resources[slot].name = cdata[i]-&gt;name,
	resources-&gt;resources[slot].contents = CONTENT_COLOR_RGB;
	++resources-&gt;num_resources;
}

static void create_truth_types(struct tm_the_truth_o *tt)
{
	static tm_ci_editor_ui_i editor_aspect = { 0 };

	static tm_ci_shader_i shader_aspect = {
		.init = shader_ci__init,
		.update = shader_ci__update
	};

	static const tm_the_truth_property_definition_t properties[] = {
		[TM_TT_PROP__CREATION_GRAPH_TEST_COMPONENT__CREATION_GRAPH] = { &quot;creation_graph&quot;, TM_THE_TRUTH_PROPERTY_TYPE_SUBOBJECT, .type_hash = TM_TT_TYPE_HASH__CREATION_GRAPH }
	};

	const tm_tt_type_t component_type = tm_the_truth_api-&gt;create_object_type(tt, TM_TT_TYPE__CREATION_GRAPH_TEST_COMPONENT, properties, TM_ARRAY_COUNT(properties));
	tm_creation_graph_api-&gt;create_truth_types(tt);
	tm_the_truth_api-&gt;set_default_object_to_create_subobjects(tt, component_type);

	// The editor aspect has to be defined if we want our component to be usable in the editor.
	// The shader aspect is used to update the creation graph and our final output.
	tm_the_truth_api-&gt;set_aspect(tt, component_type, TM_CI_EDITOR_UI, &amp;editor_aspect);
	tm_the_truth_api-&gt;set_aspect(tt, component_type, TM_CI_SHADER, &amp;shader_aspect);
}

static bool component__load_asset(tm_component_manager_o *manager, tm_entity_t e, void *data, const tm_the_truth_o *tt, tm_tt_id_t asset)
{
	tm_component_t *c = data;
	tm_tt_id_t creation_graph = tm_the_truth_api-&gt;get_subobject(tt, tm_tt_read(tt, asset), TM_TT_PROP__CREATION_GRAPH_TEST_COMPONENT__CREATION_GRAPH);

	// We only want update if the creation graph has changed,
	// Note that we set the entire component to zero if this happens,
	// this is because all fields are dependent on the creation graph.
	if (c-&gt;creation_graph.u64 != creation_graph.u64) {
		memset(c, 0, sizeof(tm_component_t));
		c-&gt;creation_graph = creation_graph;
		return true;
	}

	return false;
}

static void component__create_manager(tm_entity_context_o *ctx)
{
	tm_allocator_i a;
	tm_entity_api-&gt;create_child_allocator(ctx, TM_TT_TYPE__CREATION_GRAPH_TEST_COMPONENT, &amp;a);

	uint32_t num_backends;
	tm_renderer_backend_i **backends = (tm_renderer_backend_i **)tm_api_registry_api-&gt;implementations(TM_RENDER_BACKEND_INTERFACE_NAME, &amp;num_backends);

	tm_component_manager_o *manager = tm_alloc(&amp;a, sizeof(tm_component_manager_o));
	*manager = (tm_component_manager_o){
		.allocator = a,
		.ctx = ctx,
		.rb = backends[0]
	};

	const tm_component_i component = {
		.name = TM_TT_TYPE__CREATION_GRAPH_TEST_COMPONENT,
		.bytes = sizeof(tm_component_t),
		.manager = manager,
		.load_asset = component__load_asset
	};

	tm_entity_api-&gt;register_component(ctx, &amp;component);
}

TM_DLL_EXPORT void load_plugin(struct tm_api_registry_api *reg, bool load)
{
	tm_allocator_api = reg-&gt;get(TM_ALLOCATOR_API_NAME);
	tm_api_registry_api = reg;
	tm_creation_graph_api = reg-&gt;get(TM_CREATION_GRAPH_API_NAME);
	tm_entity_api = reg-&gt;get(TM_ENTITY_API_NAME);
	tm_render_graph_api = reg-&gt;get(TM_RENDER_GRAPH_API_NAME);
	tm_shader_system_api = reg-&gt;get(TM_SHADER_SYSTEM_API_NAME);
	tm_the_truth_api = reg-&gt;get(TM_THE_TRUTH_API_NAME);

	tm_add_or_remove_implementation(reg, load, TM_THE_TRUTH_CREATE_TYPES_INTERFACE_NAME, create_truth_types);
	tm_add_or_remove_implementation(reg, load, TM_ENTITY_CREATE_COMPONENT_INTERFACE_NAME, component__create_manager);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="physics"><a class="header" href="#physics">Physics</a></h2>
<p>The Machinery integrates Nvidia's PhysX toolkit and uses it for physics simulation of entities. This section will not attempt to describe in detail how physics simulation works, for that we refer to <a href="https://docs.nvidia.com/gameworks/content/gameworkslibrary/physx/guide/Manual/Index.html">the PhysX documentation</a>. 
We will only talk about how physics is set up in The Machinery.</p>
<p><strong>Table of Content</strong></p>
<ul>
<li><a href="physics/index.html#the-physics-simulation-system">The physics simulation system</a>
<ul>
<li><a href="physics/index.html#physics-assets">Physics Assets</a></li>
<li><a href="physics/index.html#physics-components">Physics Components</a></li>
</ul>
</li>
<li><a href="physics/index.html#physics-scripting">Physics scripting</a></li>
<li><a href="physics/index.html#missing-features">Missing Features</a></li>
<li><a href="physics/index.html#tutorials">Tutorials</a></li>
</ul>
<h2 id="the-physics-simulation-system"><a class="header" href="#the-physics-simulation-system">The physics simulation system</a></h2>
<p>The physics simulation system introduces two new assets: <em>Physics Material</em> and <em>Physics Collision</em>
as well as four new components: <em>Physics Shape Component</em>, <em>Physics Body Component</em>, <em>Physics
Joint Component</em>, and <em>Physics Mover Component</em>.</p>
<h3 id="physics-assets"><a class="header" href="#physics-assets">Physics Assets</a></h3>
<p>A <em>Physics Material</em> asset specifies the physical properties of a physics object: <em>friction</em> (how
&quot;slippery&quot; the object is) and <em>restitution</em> (how &quot;bouncy&quot; the object is). Note that if you don't
assign a material to a physics shape it will get default values for <em>friction</em> and <em>constitution</em>.</p>
<p>A <em>Physics Collision</em> asset describes a <em>collision class</em>. <em>Collision Classes</em> control which physics
shapes collide with each other. For example, a common thing to do is to have a <em>debris</em> class for
small objects and set it up so that <em>debris</em> collide with regular objects, but not with other
<em>debris</em>. That way, you are not wasting resources on computing collisions between lots of tiny
objects. (Note that the debris objects still need to collide with regular objects, or they would
just fall through the world.)</p>
<p>In addition to deciding who collides with who, the collision class also decides which collisions
generate callback events. These events can be handled in the <em>Entity Graph</em>.</p>
<p>If you don't assign a collision class to a physics shape, it will get the <em>Default</em> collision class.</p>
<h3 id="physics-components"><a class="header" href="#physics-components">Physics Components</a></h3>
<p>The <em>Physics Shape Component</em> can be added to an entity to give it a collision shape for physics.
Entities with shape components will collide with each other when physics is simulated.</p>
<p>A physics shape can either be specified as geometry (sphere, capsule, plane, box) or it can be
computed from a graphics mesh (convex, mesh). Note that if you use computed geometry, you must press
the <strong>Cook</strong> button in the Properties UI to explicitly compute the geometry for the object.</p>
<p><img src="physics/index.html#" alt="Convex shape." /></p>
<p>If you just give an entity a <em>Physics Shape Component</em> it will become a static physics object. Other
moving objects can still collide with it, but the object itself won't move.</p>
<p>To create a moving physics object, you need to add a <em>Physics Body Component</em>. The body component
lets you specify dynamic properties such as damping, mass, and inertia tensor. It also lets you
specify whether the object should be <em>kinematic</em> or not. A <em>kinematic</em> object is being moved by
<em>animation</em>. Its movement is not affected by physics, but it can still affect other physical
objects by colliding with them and pushing them around. In contrast, if the object is <em>not
kinematic</em> it will be completely controlled by physics. If you place it above ground, it will fall
down as soon as you start the simulation.</p>
<p>Note that parameters such as <em>damping</em> and <em>mass</em> do not really affect kinematic objects, since
the animations will move them the same way, regardless of their mass or damping. However, these
parameters can still be important because gameplay code could at some point change the object
from being kinematic to non-kinematic. If the gameplay code never makes the body non-kinematic, the
mass doesn't matter.</p>
<p>The <em>Physics Joint Component</em> can be used to add <em>joints</em> to the physics simulation. Joints can tie
together physics bodies in various ways. For example, if you tie together two bodies with a hinge
joint they will swing as if they were connected by a hinge. For a more thorough description of
joints, we refer to the PhysX documentation.</p>
<p>The <em>Physics Mover Component</em> implements a physics-based character controller. If you add it to an
entity, it will keep the entity's feet on the ground, prevent it from going through walls, etc. For
an example of how to use the character controller, check out the <code>animation</code> or <code>gameplay</code> sample
projects.</p>
<h2 id="physics-scripting"><a class="header" href="#physics-scripting">Physics scripting</a></h2>
<p>Physics can be scripted using the visual scripting language in the <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/editing_workflows/visual-scripting.html"><em>Entity Graph</em></a>.</p>
<p>We can divide the PhysX scripting nodes into a few categories.</p>
<p><strong>Nodes that query the state of a physics body:</strong></p>
<ul>
<li>Get Angular Velocity</li>
<li>Get Velocity</li>
<li>Is Joint Broken</li>
<li>Is Kinematic</li>
</ul>
<p><strong>Nodes that manipulate physics bodies:</strong></p>
<ul>
<li>Add Force</li>
<li>Add Torque</li>
<li>Break Joint</li>
<li>Push</li>
<li>Set Angular Velocity</li>
<li>Set Kinematic</li>
<li>Set Velocity</li>
</ul>
<p><strong>Event nodes that get triggered when something happens in the scene:</strong></p>
<ul>
<li>On Contact Event</li>
<li>On Joint Break Event</li>
<li>On Trigger Event</li>
</ul>
<p><strong>Nodes that query the world for physics bodies:</strong></p>
<ul>
<li>Overlap</li>
<li>Raycast</li>
<li>Sweep</li>
</ul>
<blockquote>
<p><strong>Note</strong> that the query nodes may return more than one result. They will do that by triggering their
<em>Out</em> event multiple times, each time with one of the result objects. (In the future we might change
this and have the nodes actually return arrays of objects.)</p>
</blockquote>
<p>From C you can access those features via the <a href="https://ourmachinery.com/apidoc/plugins/physx/physx_scene.h.html#structtm_physx_scene_api">tm_physx_scene_api</a>.</p>
<h2 id="missing-features"><a class="header" href="#missing-features">Missing Features</a></h2>
<p>Note that The Machinery doesn't currently support all the features found in PhysX. The most
glaring omissions are:</p>
<ul>
<li>D6 joints and joint motors.</li>
<li>Vehicles.</li>
</ul>
<p>We will add more support going forward.</p>
<p>For an example of how to use physics, see the <a href="https://ourmachinery.com/samples.html">Physics Sample Project</a>.</p>
<h2 id="tutorials"><a class="header" href="#tutorials">Tutorials</a></h2>
<p>For more information and guides checkout out the <a href="https://ourmachinery.github.io/themachinery-books/tutorials/">The Machinery Tutorials Book</a> as well as our <a href="https://ourmachinery.com/samples.html">Physics Sample</a>.</p>
<p>In this section we will discuss some of the Samples in more detail. </p>
<p>You can download the Physics Sample projects from the Download Tab: <em><strong>Help -&gt; Download Sample Projects</strong></em> </p>
<p><img src="https://www.dropbox.com/s/1w81dsmhazf6pfn/tm_tut_physics_sample_download.png?dl=1" alt="Where to find the samples" /></p>
<p>After you have downloaded the Physic Sample Project, you can open it. Its folder structure looks as following in the default view:</p>
<p><img src="https://www.dropbox.com/s/igj4b4ao1ntb4zw/tm_tut_physics_scenes.png?dl=1" alt="Where to find the scene" /></p>
<p>All examples are in the folder <code>Scenes</code>. When you open that folder, you can see all the sample Scenes (Entities). Double click on the Sample of your choice, and the Editor will load the Scene for you.</p>
<p>Each of the Sample Scenes is composed of multiple Entity Prototypes. You can find them in the &quot;Special Objects&quot; or in the &quot;Shapes&quot; folder in the Asset Browser.</p>
<p><img src="https://www.dropbox.com/s/cafrzpkal6sd1y7/tm_tut_physics_special_objects.png?dl=1" alt="Special Objects folder" /></p>
<p><em>Special Objects</em> are entities with Graph Component attached and have the logic with them.</p>
<p><img src="https://www.dropbox.com/s/og7wipthmw1hl7d/tm_tut_physics_shapes.png?dl=1" alt="" /></p>
<p><em>Shapes</em> are reused Entities to demonstrate different kind of Physic Bodies.</p>
<blockquote>
<p><strong>Note:</strong> If you change any of those Prototypes all the none modified instances will change as well. Keep this in mind when playing around with the samples.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="triggers"><a class="header" href="#triggers">Triggers</a></h2>
<p>This walkthrough shows you how to create a trigger with the Graph Component. You can find the &quot;source code&quot; in our <a href="https://ourmachinery.com/samples.html">Physic Samples</a>.</p>
<p><strong>Table of Content</strong></p>
<ul>
<li><a href="physics/triggers.html#assemble-a-trigger">Assemble a Trigger</a>
<ul>
<li><a href="physics/triggers.html#create-the-trigger-entity">Create the Trigger Entity</a></li>
<li><a href="physics/triggers.html#add-the-logic-to-the-graph">Add the logic to the graph</a></li>
<li><a href="physics/triggers.html#create-the-ball">Create the ball</a></li>
<li><a href="physics/triggers.html#creating-the-scene">Creating the Scene</a></li>
<li><a href="physics/triggers.html#spawn-balls">Spawn balls</a></li>
</ul>
</li>
<li><a href="physics/triggers.html#conclusion">Conclusion</a></li>
</ul>
<h2 id="assemble-a-trigger"><a class="header" href="#assemble-a-trigger">Assemble a Trigger</a></h2>
<p>What is a trigger? </p>
<p>Something that reacts when something intersects/touches them, either constantly or just the first/last time.</p>
<blockquote>
<p><strong>Note:</strong> In Unreal Engine, this might be called Trigger Actors / Trigger Box. </p>
</blockquote>
<p>In the Machinery, we have two types of triggers we can use:</p>
<ul>
<li>PhysX's Trigger- Physical Based Trigger</li>
<li>Volume-Component - The Trigger is based on the Volume Component.</li>
</ul>
<p>In this walkthrough, we are focused on <strong>PhysX's Trigger</strong> <strong>Event.</strong></p>
<p>This walkthrough will be to create a Trigger that adds Velocity to a Ball Shot from the Camera. Therefore we need to make the following Entities:</p>
<ul>
<li>The Trigger</li>
<li>A world (plane)</li>
<li>A Ball</li>
</ul>
<h3 id="create-the-trigger-entity"><a class="header" href="#create-the-trigger-entity">Create the Trigger Entity</a></h3>
<p>Let us create a folder in the Project root and call it &quot;Special Objects&quot;. It will be the folder in which we keep all our <em>Special Objects</em> for now and for what might come.</p>
<p>In this folder, we create an Entity with the name &quot;Trigger&quot;. We add two extra components:</p>
<ul>
<li>A Graph Component for some logic</li>
<li>A Physic Shape to make sure the Physics World can see it</li>
</ul>
<p>When adding the Physic Shape, we need to consider the Type. By default, the Type is Sphere, but that would not suit our needs since we want it to be a red box. We change the Type to Box and tick the Checkbox &quot;Is Trigger&quot; to make sure it is a Trigger. We can also change the Half Extent value if we like.</p>
<p>If you look now into the Scene Tab, you see nothing. To change that, you can turn on the Debug Visualization:</p>
<p><img src="https://www.dropbox.com/s/jp8oxoz8zl0f5d7/tm_tut_physics_viz.png?dl=1" alt="" /></p>
<p>Having a Trigger that cannot be seen might be applicable for some games. In our case, we choose to make the Trigger Visible with a box.</p>
<p>Luckily the core provides a Box Entity for us: <code>core/geometry/box.entity</code>. </p>
<p><img src="https://www.dropbox.com/s/xd9gjg8pbw6p8kj/tm_tut_physics_core_gom.png?dl=1" alt="" /></p>
<p>This location is something we keep in mind!</p>
<p>Let us also add the Box (<code>core/geometry/box.entity</code>) from the core to our Entity as a child. This Box makes it easier for us to test it later because we can see it in the Scene Window.</p>
<h3 id="add-the-logic-to-the-graph"><a class="header" href="#add-the-logic-to-the-graph">Add the logic to the graph</a></h3>
<p>We double-click the Graph Component to open the Graph Editor. The Graph Editor is Empty. We want to add an <code>Init Event</code> and then a &quot;Physx On Trigger Event&quot;. We need to connect the Start Listing connector with the &quot;Init Event Connector&quot;.</p>
<p>To get the current Entity, we add the node &quot;Scene Entity&quot; and connect the outgoing connector with the &quot;Physx On Trigger Event&quot; Entity connector. </p>
<p>The goal was to apply Velocity to any entity that touches the Trigger the first time. That is why we add a connector from the &quot;First Touch&quot; to the newly added Physx Set Velocity node.</p>
<p>We connect the Entity from the &quot;Physx Set Velocity&quot; entity connector to the <em>Touched Entity Connector</em> at the &quot;Physx On Trigger Event&quot; node. </p>
<p>We need to get the current Velocity of this Entity. We can do this by using the &quot;Physx Get Velocity&quot; node. The result we modify with, let us say -1 and apply it at the end. (<em>The smaller the value, the stronger the ball will bounce off.</em>)</p>
<p><img src="https://www.dropbox.com/s/g8yhrs5e7wugau4/tm_tut_physics_graph_trigger_event.png?dl=1" alt="" /></p>
<p>This is how our trigger Entity looks like:</p>
<p><img src="https://www.dropbox.com/s/njipx8mfsjsqcgj/tm_tut_physics_trigger_entity.png?dl=1" alt="" /></p>
<blockquote>
<p><strong>Note:</strong> The Box Entity will be displayed yellow because it is a prototype instance of the Entity within the <code>core/geometry/</code> folder. Any changes to this prototype will apply to this instance as well. </p>
</blockquote>
<h3 id="create-the-ball"><a class="header" href="#create-the-ball">Create the ball</a></h3>
<p>The Trigger is quite useless unless it can interact with something! That is why we want to shoot a ball from the Camera to the player.</p>
<p>Again the core comes to our rescue and provides us with a Sphere in the <code>core/geometry/</code>! We will use this for our ball!</p>
<p>We open the &quot;Special Objects&quot; folder and add a new Entity called &quot;Ball&quot;. With a double-click, we open it and add a &quot;Physics Shape&quot; and &quot;Physics Body&quot; Component. In the  &quot;Physics Shape Component,&quot; we leave the Type to Sphere. </p>
<blockquote>
<p><strong>Note:</strong> We can also visualize the Sphere Physics Shape in the Scene the same way we visualized them for the Box.</p>
</blockquote>
<p>After this, we need to ensure that our ball has CCD is enabled. Also, the Inertia Tensor should be set to 0.4, and Angular Damping should be set to 0.05.</p>
<p>Now that we have adjusted all the components let us add the actual ball. Again we can drag and drop the <code>sphere.entity</code> from the <code>core/geometry/</code> folder onto our Entity.</p>
<p><img src="https://www.dropbox.com/s/xd9gjg8pbw6p8kj/tm_tut_physics_core_gom.png?dl=1" alt="" /></p>
<h3 id="creating-the-scene"><a class="header" href="#creating-the-scene">Creating the Scene</a></h3>
<p>After we have nearly all the components to create our little Scene, all that is missing is the playground. The playground can be defined as just a plane with a trigger on it.</p>
<p>We can create a new Folder in the Asset Browser root and call it &quot;Scenes&quot;. In there, we create a new Entity and call it &quot;Triggers&quot;. We open this Entity.</p>
<p>The first thing we do is add a new Empty Child entity. We call it Floor or Plane. </p>
<blockquote>
<p><strong>Note:</strong> Right-click on the Main Entity &quot;Add Child Entity.&quot;</p>
</blockquote>
<p>We add a Physics Shape Component to this Entity and change its Type to Plane.</p>
<p>If we do not use the Physics Visualization mode, we see nothing in the Scene Tab. We can change this by adding a new Child Entity to our floor Entity. We right-click on the Plane / Floor Entity <strong>-&gt;Add Child Entity -&gt; From Asset</strong>, and we search for the Plane Entity. It is also located in the core.</p>
<p>When we look at the Scene Tab now, we see our new floor entity! Let us drag in our Trigger. We need to drag and drop the Trigger Entity from the Asset Browser in the Scene and adjust it with the Tools within the Scene Tab.</p>
<p>The result could look like this:</p>
<p><img src="https://www.dropbox.com/s/w4xqxvhcblinopu/tm_tut_physics_trigger_scene.png?dl=1" alt="" /></p>
<blockquote>
<p><strong>Note:</strong> We should add a Light Entity. Otherwise, it might be quite dark. Luckily the core has our back also here. We can just right-click the main Entity and <strong>Add Child Entity -&gt; From Asset -&gt; Light</strong>.</p>
</blockquote>
<h3 id="spawn-balls"><a class="header" href="#spawn-balls">Spawn balls</a></h3>
<p>The Scene itself is not what we want because we cannot spawn balls yet. To do this, we add a graph to the Scene itself.</p>
<p>In there, we add a &quot;Tick Event&quot; we need to poll every tick if the space key has was pressed. If you pressed space, we would spawn the ball from the camera direction. </p>
<p>We push the ball via &quot;Physx Push&quot; with a calculated velocity.</p>
<p><img src="https://www.dropbox.com/s/q9k4qp08lumgzef/tm_tut_physics_graph_spawn_ball.png?dl=1" alt="" /></p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>All of the above described &quot;code you can&quot; find when you download the Physics Sample projects from the Download Tab: <em><strong>Help -&gt; Download Sample Projects</strong></em> </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-truth"><a class="header" href="#the-truth">The Truth</a></h1>
<p>The Machinery uses a powerful data model to represent edited assets. This model has built-in support for serialization, streaming, copy/paste, drag-and-drop as well as unlimited undo/redo. It supports an advanced hierarchical prefab model for making derivative object instances and propagating changes. It even has full support for real-time collaboration. Multiple people can work together in the same game project, Google Docs-style. Since all of these features are built into the data model itself, your custom, game-specific data will get them automatically, without you having to write a line of code.</p>
<h2 id="the-data-model"><a class="header" href="#the-data-model">The Data Model</a></h2>
<p>The Machinery stores its data as <strong>objects with properties</strong>. Each object has a type and the type defines what properties the object has. Available property types are <em>bools, integers, floats, strings, buffers, references</em>, <em>sub-objects</em> and <em>sets of references or sub-objects</em>.</p>
<p>The object/properties model gives us us <em>forward and backward compatibility</em> and allows us to implement operations such as <em>cloning</em> without knowing any details about the data. We can also represent modifications to the data in a uniform way <code>(object, property, old-value, new-value)</code> for undo/redo and collaboration.</p>
<p>The model is <strong>memory-based</strong> rather than disk-based. I.e. the in-memory representation of the data is considered <em>authoritative.</em> Read/write access to the data is provided by a thread-safe API. If two systems want to co-operate, they do so by talking to the same in-memory model, not by sharing files on disk. Of course, we still need to save data out disk at some point for persistence, but this is just a “backup” of the memory model and we might use different disk formats for different purposes (i.e. a git-friendly representation for collaborative work vs single binary for solo projects).</p>
<p>Since we have a memory-based model which supports cloning and change tracking, copy/paste and undo can be defined in terms of the data model. Real-time collaboration is also supported, by serializing modifications and transmitting them over the network. Since the runtime has equal access to the data model, modifying the data from within a VR session is also possible.</p>
<p>We make a clear <strong>distinction between “buffer data” and “object data”</strong>. <em>Object data</em> is stuff that can be reasoned about on a per-property level. I.e. if user A changes one property of an object, and user B changes another, we can merge those changes. <em>Buffer data</em> are binary blobs of data that are opaque to the data model. We use it for large pieces of binary data, such as textures, meshes and sound files. Since the data model cannot reason about the content of these blobs it can’t for example merge changes made to the same texture by different users.</p>
<p>Making the distinction between buffer data and object data is important because we pay an overhead for representing data as objects. We only want to pay that overhead when the benefits outweigh the costs. Most of a game’s data (in terms of bytes) is found in things like textures, meshes, audio data, etc and does not really gain anything from being stored in a JSON-like object tree.</p>
<p>In The Truth, <strong>references are represented by IDs</strong>. Each object has a unique ID and we reference other objects by their IDs. Since references have their own property type in The Truth, it is easy for us to reason about references and find all the dependencies of an object.</p>
<p>Sub-objects in The Truth are references to <em>owned</em> objects. They work just as references, but have special behaviours in some situations. For examples, when an object is cloned, all its sub-objects will be cloned too, while its references will not.</p>
<p>For more information checkout the <a href="https://ourmachinery.com/apidoc/foundation/the_truth.h.html">documentation</a> and these blog posts: <a href="https://ourmachinery.com/post/the-story-behind-the-truth-designing-a-data-model/">The Story behind The Truth: Designing a Data Model</a>  or this <a href="https://ourmachinery.com/post/multi-threading-the-truth/">one</a>.</p>
<h2 id="tutorials-1"><a class="header" href="#tutorials-1">Tutorials</a></h2>
<p>This section shall introduce you to some more complex topics such as <a href="https://ourmachinery.github.io/themachinery-books/tutorials//the_truth/custom_asset/index.html"><em>How to create your own asset.</em></a></p>
<p>For more information checkout the <a href="https://ourmachinery.com/apidoc/foundation/the_truth.h.html">documentation</a> and these blog posts: <a href="https://ourmachinery.com/post/the-story-behind-the-truth-designing-a-data-model/">The Story behind The Truth: Designing a Data Model</a>  or this <a href="https://ourmachinery.com/post/multi-threading-the-truth/">one</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-custom-asset"><a class="header" href="#creating-a-custom-asset">Creating a custom asset</a></h1>
<p>This walkthrough series shows you how to add a custom asset to the Engine. You should have basic knowledge about how to write a custom plugin. If not, you might want to check this <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/extending_the_machinery/the_plugin_system.html">Guide</a>. The goal for this walkthrough is to write a text file asset.</p>
<p>In the parts 1 - 3 we will cover the following topics:</p>
<ul>
<li><a href="https://ourmachinery.github.io/themachinery-books/tutorials/the_truth/custom_asset/part1.html#creating-an-asset-the-truth-type">How to create your asset</a></li>
<li><a href="https://ourmachinery.github.io/themachinery-books/tutorials/the_truth/custom_asset/part1.html#what-is-the-difference-between-truth-type-and-asset">What is the difference between a Truth Type and an Asset?</a></li>
<li><a href="https://ourmachinery.github.io/themachinery-books/tutorials/the_truth/custom_asset/part1.html#appendix-adding-an-asset-via-code-to-the-asset-browser">Add a asset via code to the project</a></li>
<li><a href="https://ourmachinery.github.io/themachinery-books/tutorials/the_truth/custom_asset/part2.html#text-file-asset">How to associate data with your asset</a></li>
<li><a href="https://ourmachinery.github.io/themachinery-books/tutorials/the_truth/custom_asset/part2.html#custom-ui">How to add a custom UI to your asset</a></li>
<li><a href="https://ourmachinery.github.io/themachinery-books/tutorials/the_truth/custom_asset/part3.html#custom-importer-for-text-files">How to create your importer</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-a-custom-asset-part-1"><a class="header" href="#create-a-custom-asset-part-1">Create a custom asset part 1</a></h1>
<p>This walkthrough shows you how to add a custom asset to the Engine. You should have basic knowledge about how to write a custom plugin. If not, you might want to check this <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/extending_the_machinery/the_plugin_system.html">Guide</a>. The goal for this walkthrough is to write a text file asset.</p>
<p>In the parts 1 - 3 we will cover the following topics:</p>
<ul>
<li>How to create your asset</li>
<li>How to associate data with your asset</li>
<li>How to add a custom UI to your asset</li>
<li>How to create your importer</li>
</ul>
<p>This part will cover the following topics:</p>
<ul>
<li>What to think of in advance?</li>
<li>Creating an essential asset The Truth type</li>
<li>Being able to add the asset to the asset browser
<ul>
<li>Via context Menu</li>
<li>Via code</li>
</ul>
</li>
</ul>
<p>The next part will explore how to store more complex data in an asset file and how to get this data back into the Engine.</p>
<blockquote>
<p>You can find the whole source code in its git repo: <a href="https://github.com/simon-ourmachinery/example-text-file-asset">example-text-file-asset</a></p>
</blockquote>
<p><strong>Table of Content</strong></p>
<ul>
<li><a href="the_truth/custom_asset/part1.html#first-step-what-kind-of-asset-do-we-want-to-create">First step: What kind of asset do we want to create?</a></li>
<li><a href="the_truth/custom_asset/part1.html#creating-an-asset-the-truth-type">Creating an asset The Truth Type</a>
<ul>
<li><a href="the_truth/custom_asset/part1.html#what-is-the-difference-between-truth-type-and-asset">What is the difference between Truth Type and Asset?</a></li>
</ul>
</li>
<li><a href="the_truth/custom_asset/part1.html#making-the-asset-browser-able-to-create-it">Making the Asset Browser able to create it</a></li>
<li><a href="the_truth/custom_asset/part1.html#what-is-next">What is next?</a></li>
<li><a href="the_truth/custom_asset/part1.html#appendix-adding-an-asset-via-code-to-the-asset-browser">Appendix: Adding an asset via code to the Asset Browser</a></li>
<li><a href="the_truth/custom_asset/part1.html#full-example-of-basic-asset">Full example of basic asset</a></li>
</ul>
<h2 id="first-step-what-kind-of-asset-do-we-want-to-create"><a class="header" href="#first-step-what-kind-of-asset-do-we-want-to-create"><strong>First step:</strong> What kind of asset do we want to create?</a></h2>
<p>Sometimes it is needed to add a custom asset to the Engine to support different asset types which are not supported yet. The first step is that we need to decide what our asset shall represent. In this case, it will be a text file. Those decisions have some influence on the details of the implementation. How ever the steps discussed below are the same in any case.</p>
<h2 id="creating-an-asset-the-truth-type"><a class="header" href="#creating-an-asset-the-truth-type">Creating an asset The Truth Type</a></h2>
<p>The Engine needs to know that there shall be a new asset type. That is why we need to register a new Truth type. Those steps are the same for every truth type, be it an asset or not.</p>
<p>We need to define a globally accessible definition for the name of the type and its hash value. The usual place for this is a header file.</p>
<p>Example Header file: <code>my_asset.h</code></p>
<pre><code class="language-c">#pragma once
#include &quot;entity_api_types.h&quot;
//... more code
#define TM_TT_TYPE__MY_ASSET &quot;tm_my_asset&quot;
#define TM_TT_TYPE_HASH__MY_ASSET TM_STATIC_HASH(&quot;tm_my_asset&quot;, 0xc0995d6c144ac64aULL)
</code></pre>
<p>(Do not forget to run hash.exe when you create a <a href="https://ourmachinery.com/apidoc/foundation/api_types.h.html#tm_static_hash()">TM_STATIC_HASH</a>, mode information here.)</p>
<p>Now we need to define the layout of our asset type. We should always do this during plugin load. (<code>tm_load_plugin</code>) 
During this call we need to register a function to the <a href="https://ourmachinery.com/apidoc/foundation/the_truth.h.html#tm_the_truth_create_types_interface_name">TM_THE_TRUTH_CREATE_TYPES_INTERFACE_NAME</a> interface. 
This function is typically called <code>create_truth_types</code>, but its name can be arbitrary.</p>
<blockquote>
<p><strong>Note:</strong> An interface is an abstract structure that maps a struct (the interface) to a hash value/name. It allows for customization points. In The Machinery, the Engine uses this extensively.</p>
</blockquote>
<p>Example <code>tm_load_plugin</code> function for <code>my_asset.c</code></p>
<pre><code class="language-c">TM_DLL_EXPORT void tm_load_plugin(struct tm_api_registry_api *reg, bool load)
{
tm_add_or_remove_implementation(reg, load, TM_THE_TRUTH_CREATE_TYPES_INTERFACE_NAME, create_truth_types);
}
</code></pre>
<p>After we did this, let us implement the actual function. First, we need to create a Truth type:
We use the function <code>tm_the_truth_api-&gt;create_object_type(tm_the_truth_o *tt, const char *name, const tm_the_truth_property_definition_t *properties, uint32_t num_properties);</code> . This one will register in the Truth a new type with the name and the properties we give the type. </p>
<p>At this point, we have a normal The Truth type. But we wanted to create an asset! </p>
<h4 id="what-is-the-difference-between-truth-type-and-asset"><a class="header" href="#what-is-the-difference-between-truth-type-and-asset">What is the difference between Truth Type and Asset?</a></h4>
<p>An asset is just a normal truth type. The structure of an asset in the truth is defined in the <code>foundation/the_truth_assets.h</code>. An asset itself is, therefore, nothing else than a wrapper around our actual asset. It provides a generic interface to provide some standard information.</p>
<p>The structure of an asset type looks like this:</p>
<pre><code class="language-c">enum {
    // Name of the asset.
    TM_TT_PROP__ASSET__NAME, // string
    // Directory where the asset resides. For top-level assets, this is `NULL`.
    TM_TT_PROP__ASSET__DIRECTORY, // reference [[TM_TT_TYPE__ASSET_DIRECTORY]]
    // Labels applied to this asset.
    TM_TT_PROP__ASSET__UUID_LABELS, // subobject_set(UINT64_T) storing the UUID of the associated label.
    // Subobject with the actual data of the asset. The type of this subobject depends on the type
    // of data storedin this asset.
    TM_TT_PROP__ASSET__OBJECT, // subobject(*)
    // Thumbnail image associated with asset
    TM_TT_PROP__ASSET__THUMBNAIL, // buffer
};
</code></pre>
<p>The truth type of the text file we just created will live as a subobject of the Asset Truth Type in the property field: <a href="https://ourmachinery.com/apidoc/foundation/the_truth_assets.h.html#enumtm_tt_prop__asset">TM_TT_PROP__ASSET__OBJECT</a>.</p>
<p>Let us move on and go back and finish the definition of our type. Let us add a file extension to our type. All we need to do is add an aspect of type <a href="https://ourmachinery.com/apidoc/foundation/the_truth_assets.h.html#tm_tt_aspect__file_extension">TM_TT_ASPECT__FILE_EXTENSION</a> to our Truth Type. You can find it in the following header file <code>foundation/the_truth_assets.h</code>.</p>
<blockquote>
<p><strong>Note:</strong> The Machinery will automatically prefix your file extension with <strong>tm_</strong></p>
</blockquote>
<p>In code, this looks as follows:</p>
<pre><code class="language-c">static void create_truth_types(struct tm_the_truth_o *tt)
{
    const tm_tt_type_t type = tm_the_truth_api-&gt;create_object_type(tt, TM_TT_TYPE__MY_ASSET, 0, 0);
    tm_the_truth_api-&gt;set_aspect(tt, type, TM_TT_ASPECT__FILE_EXTENSION, &quot;my_asset&quot;);
}
</code></pre>
<p>We create a type of name <code>TM_TT_TYPE__MY_ASSET</code> with no properties and a file extension my_asset (<code>.tm_my_asset</code> in your explorer). </p>
<h2 id="making-the-asset-browser-able-to-create-it"><a class="header" href="#making-the-asset-browser-able-to-create-it">Making the Asset Browser able to create it</a></h2>
<p>Now that there is a basic asset type, you might want the asset browser to create it via the <code>New Asset</code> context menu. All you need to do is register the asset to the <a href="https://ourmachinery.com/apidoc/plugins/editor_views/asset_browser.h.html#tm_asset_browser_create_asset_interface_name">TM_ASSET_BROWSER_CREATE_ASSET_INTERFACE_NAME</a> interface. This interface requires an implementation of the type <a href="https://ourmachinery.com/apidoc/plugins/editor_views/asset_browser.h.html#structtm_asset_browser_create_asset_i">tm_asset_browser_create_asset_i</a>:</p>
<pre><code class="language-c">typedef struct tm_asset_browser_create_asset_i
{
    struct tm_asset_browser_create_asset_o *inst;
    // TM_LOCALIZE_LATER() name of menu option to display for creating the asset (e.g. &quot;New
    // Entity&quot;).
    const char *menu_name;
    // TM_LOCALIZE_LATER() name of the newly created asset (e.g. &quot;New Entity&quot;);
    const char *asset_name;
    // Create callback, should return The Truth ID for the newly created asset.
    tm_tt_id_t (*create)(struct tm_asset_browser_create_asset_o *inst, struct tm_the_truth_o *tt, tm_tt_undo_scope_t undo_scope);
} tm_asset_browser_create_asset_i;
</code></pre>
<p>Source: <code>plugins/editor_views/asset_browser.h</code></p>
<p>For our basic type, this interface can be defined as follows:</p>
<pre><code class="language-c">static tm_tt_id_t asset_browser_create(struct tm_asset_browser_create_asset_o *inst, tm_the_truth_o *tt, tm_tt_undo_scope_t undo_scope)
{
    const tm_tt_type_t type = tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE__MY_ASSET);
    return tm_the_truth_api-&gt;create_object_of_type(tt, type, undo_scope);
}

static tm_asset_browser_create_asset_i asset_browser_create_my_asset = {
    .menu_name = TM_LOCALIZE_LATER(&quot;New My Asset&quot;),
    .asset_name = TM_LOCALIZE_LATER(&quot;New My Asset&quot;),
    .create = asset_browser_create,
};
</code></pre>
<p>What is happening?</p>
<ul>
<li>In this case, the function <code>asset_browser_create</code> creates the object of our type. Here we could do more complex things if the asset were more complicated. </li>
<li>The <em>menu name</em> is for the context menu, while the <em>asset name</em> functions as the default asset name. </li>
</ul>
<p>Now we register our code to the interface. We do this also in the load plugin function.</p>
<p>Example <code>tm_load_plugin</code> function for <code>my_asset.c</code></p>
<pre><code class="language-c">TM_DLL_EXPORT void tm_load_plugin(struct tm_api_registry_api *reg, bool load)
{
tm_add_or_remove_implementation(reg, load, TM_THE_TRUTH_CREATE_TYPES_INTERFACE_NAME, create_truth_types);
   tm_add_or_remove_implementation(reg, load, TM_ASSET_BROWSER_CREATE_ASSET_INTERFACE_NAME, &amp;asset_browser_create_my_asset);
}
</code></pre>
<p>When we open the Engine, we can open the Asset Browser and create our asset:</p>
<p><img src="https://paper-attachments.dropbox.com/s_080D43F0A98EB2BE6BBB6D719C7B3B910F38D78674006103833AED0070469AD4_1609883533160_image.png" alt="" /></p>
<p>What happens is not existing! But we are getting there! Check out the <a href="the_truth/custom_asset/part1.html#">next part</a> for more complex and existing actions.</p>
<h2 id="what-is-next"><a class="header" href="#what-is-next">What is next?</a></h2>
<p>The next part will refactor the current code and show you how to make your code and asset more useful by implementing the action asset.</p>
<p><a href="https://ourmachinery.github.io/themachinery-books/tutorials//the_truth/custom_asset/part2.html">Part 2</a></p>
<h2 id="appendix-adding-an-asset-via-code-to-the-asset-browser"><a class="header" href="#appendix-adding-an-asset-via-code-to-the-asset-browser">Appendix: Adding an asset via code to the Asset Browser</a></h2>
<p>Sometimes it is necessary to create an asset via code. The Asset Browser plugin provides a solution for this the <a href="https://ourmachinery.com/apidoc/plugins/editor_views/asset_browser.h.html#structtm_asset_browser_add_asset_api">tm_asset_browser_add_asset_api</a>. With this API assets can be created and added to the current project.</p>
<p>To add an asset to the asset browser a few steps are needed. </p>
<ol>
<li>First, we need to pick the correct type. We need to request it from the truth via the type hash (in this example, <code>TM_TT_TYPE_HASH__MY_ASSET</code>). </li>
<li>Secondly, we should create an object of the correct type. </li>
<li>Then we can request the asset browser API if the API not globally accessible.</li>
</ol>
<blockquote>
<p>If we already requested the API, we do not need to do this step and can use the already defined instance of the API.</p>
</blockquote>
<ol start="4">
<li>We need to create a undo scope. (We could also use <a href="https://ourmachinery.com/apidoc/foundation/the_truth.h.html#tm_tt_no_undo_scope">TM_TT_NO_UNDO_SCOPE</a>) but its not recommended!</li>
<li>Then, we should decide if we should highlight the new asset in the Asset Browser. (<code>should_select=true</code>) If that's needed, an instance of the current UI is required. </li>
<li>Then, the magic can happen and we can call the function <code>add</code> of the <a href="https://ourmachinery.com/apidoc/plugins/editor_views/asset_browser.h.html#structtm_asset_browser_add_asset_api">tm_asset_browser_add_asset_api</a> </li>
</ol>
<p>The following code example will demonstrate how to add my_asset via code to the current project.</p>
<pre><code class="language-c">// ... other includes
#include &lt;foundation/the_truth.h&gt;
#include &lt;foundation/undo.h&gt;

#include &lt;plugins/editor_views/asset_browser.h&gt;

#include &quot;my_asset.h&quot;
//... other code

static void add_my_asset_to_project(tm_the_truth_o *tt,struct tm_ui_o *ui,const char*asset_name, tm_tt_id_t target_dir){
    const tm_tt_type_t my_asset_type_id= tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__MY_ASSET);
    const tm_tt_id_t asset_id = tm_the_truth_api-&gt;create_object_of_type(tt, my_asset_type_id, TM_TT_NO_UNDO_SCOPE);
tm_asset_browser_add_asset_api *add_asset = tm_global_api_registry-&gt;get(TM_ASSET_BROWSER_ADD_ASSET_API_NAME);
const tm_tt_undo_scope_t undo_scope = tm_the_truth_api-&gt;create_undo_scope(tt, TM_LOCALIZE(&quot;Add My Asset to Project&quot;));
bool should_select = true;
// we do not have any asset label therefore we do not need to pass them thats why the last
// 2 arguments are 0 and 0!
add_asset-&gt;add(add_asset-&gt;inst, target_dir, asset_id, asset_name, undo_scope,should_select,ui,0,0);
}
</code></pre>
<h2 id="full-example-of-basic-asset"><a class="header" href="#full-example-of-basic-asset">Full example of basic asset</a></h2>
<p><code>my_asset.h</code></p>
<pre><code class="language-c">#pragma once
#include &lt;foundation/api_types.h&gt;
//... more code
#define TM_TT_TYPE__MY_ASSET &quot;tm_my_asset&quot;
#define TM_TT_TYPE_HASH__MY_ASSET TM_STATIC_HASH(&quot;tm_my_asset&quot;, 0x1e12ba1f91b99960ULL)
</code></pre>
<p>(Do not forget to run hash.exe when you create a <a href="https://ourmachinery.com/apidoc/foundation/api_types.h.html#tm_static_hash()">TM_STATIC_HASH</a>)</p>
<p><code>my_asset.c</code></p>
<pre><code class="language-c">// -- api's
static struct tm_the_truth_api *tm_the_truth_api;
// -- inlcudes
#include &lt;foundation/api_registry.h&gt;
#include &lt;foundation/the_truth.h&gt;
#include &lt;foundation/undo.h&gt;
#include &lt;foundation/the_truth_assets.h&gt;
#include &lt;foundation/localizer.h&gt;

#include &lt;plugins/editor_views/asset_browser.h&gt;

#include &quot;my_asset.h&quot;

// -- create truth type
static void create_truth_types(struct tm_the_truth_o *tt)
{
    // we have properties this is why the last arguments are &quot;0, 0&quot;
    const tm_tt_type_t type = tm_the_truth_api-&gt;create_object_type(tt, TM_TT_TYPE__MY_ASSET, 0, 0);
    tm_the_truth_api-&gt;set_aspect(tt, type, TM_TT_ASPECT__FILE_EXTENSION, &quot;my_asset&quot;);
}

// -- asset browser regsiter interface
static tm_tt_id_t asset_browser_create(struct tm_asset_browser_create_asset_o *inst, tm_the_truth_o *tt, tm_tt_undo_scope_t undo_scope)
{
    const tm_tt_type_t type = tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__MY_ASSET);
    return tm_the_truth_api-&gt;create_object_of_type(tt, type, undo_scope);
}
static tm_asset_browser_create_asset_i asset_browser_create_my_asset = {
    .menu_name = TM_LOCALIZE_LATER(&quot;New My Asset&quot;),
    .asset_name = TM_LOCALIZE_LATER(&quot;New My Asset&quot;),
    .create = asset_browser_create,
};

// -- load plugin
TM_DLL_EXPORT void tm_load_plugin(struct tm_api_registry_api *reg, bool load)
{
    tm_the_truth_api = reg-&gt;get(TM_THE_TRUTH_API_NAME);
    tm_add_or_remove_implementation(reg, load, TM_THE_TRUTH_CREATE_TYPES_INTERFACE_NAME, create_truth_types);
    tm_add_or_remove_implementation(reg, load, TM_ASSET_BROWSER_CREATE_ASSET_INTERFACE_NAME, &amp;asset_browser_create_my_asset);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-a-custom-asset-part-2"><a class="header" href="#create-a-custom-asset-part-2">Create a custom asset part 2</a></h1>
<p>This walkthrough shows you how to add a custom asset to the Engine. You should have basic knowledge about how to write a custom plugin. If not, you might want to check this <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/extending_the_machinery/the_plugin_system.html">Guide</a>. The goal for this walkthrough is to write a text file asset.</p>
<p>This part will cover the following topics:</p>
<ul>
<li>How to store data in a buffer that is associated with the asset file</li>
<li>How to add a custom UI to be associated with the asset.</li>
</ul>
<p>When you have finished this part in the <a href="https://ourmachinery.github.io/themachinery-books/tutorials/the_truth/custom_asset/part3.html">next one</a>, we will show you how to write your importer.</p>
<blockquote>
<p>You can find the whole source code in its git repo: <a href="https://github.com/simon-ourmachinery/example-text-file-asset">example-text-file-asset</a></p>
</blockquote>
<p><strong>Table of Content</strong></p>
<ul>
<li><a href="the_truth/custom_asset/part2.html#extending-the-asset-the-truth-type">Extending the asset The Truth Type</a></li>
<li><a href="the_truth/custom_asset/part2.html#text-file-asset">Text file asset</a></li>
<li><a href="the_truth/custom_asset/part2.html#load-a-text-file">Load a text file</a>
<ul>
<li><a href="the_truth/custom_asset/part2.html#custom-ui">Custom UI</a></li>
</ul>
</li>
<li><a href="the_truth/custom_asset/part2.html#what-is-next">What is next?</a></li>
<li><a href="the_truth/custom_asset/part2.html#full-example-source-code">Full example source code</a></li>
</ul>
<h2 id="extending-the-asset-the-truth-type"><a class="header" href="#extending-the-asset-the-truth-type">Extending the asset The Truth Type</a></h2>
<p>The asset type we created is nice but it cannot do much. The Machinery can save anything to file that it can store in the Truth. This thought brings us back to the part: <strong>“What kind of asset do we want to create?”.</strong> </p>
<p>Let us go back to the basic definition of the type <code>my_asset</code>. We defined the type without any properties.</p>
<p>The current implementation looks as follows:</p>
<pre><code class="language-c">// -- create truth type
static void create_truth_types(struct tm_the_truth_o *tt)
{
    const tm_tt_type_t type = tm_the_truth_api-&gt;create_object_type(tt, TM_TT_TYPE__MY_ASSET, 0, 0);
    tm_the_truth_api-&gt;set_aspect(tt, type, TM_TT_ASPECT__FILE_EXTENSION, &quot;my_asset&quot;);
}
</code></pre>
<p>To make this more useful, what we can do is add some properties to the type. We can do this via an array of the type <a href="https://ourmachinery.com/apidoc/foundation/the_truth.h.html#structtm_the_truth_property_definition_t">tm_the_truth_property_definition_t</a>. In this array we can define all the properties we want. </p>
<h2 id="text-file-asset"><a class="header" href="#text-file-asset">Text file asset</a></h2>
<p>Now we are changing the <code>my_asset</code> to be able to store text in it. </p>
<p>First, we need to answer the question: <em>How is a text file defined?</em> </p>
<p>Well, a text file has three properties: </p>
<ol>
<li>It has a file name</li>
<li>A file path</li>
<li>data - A bunch of characters.</li>
</ol>
<p>Consequently, we are defining the <em>import path</em> property to “reimport” our text asset and the data property to store the imported text.</p>
<pre><code class="language-c">    static tm_the_truth_property_definition_t my_asset_properties[] = {
        { &quot;import_path&quot;, TM_THE_TRUTH_PROPERTY_TYPE_STRING },
        { &quot;data&quot;, TM_THE_TRUTH_PROPERTY_TYPE_BUFFER},
    };
</code></pre>
<blockquote>
<p><strong>Note:</strong> The type <a href="https://ourmachinery.com/apidoc/foundation/the_truth.h.html#structtm_the_truth_property_definition_t"><em>tm_the_truth_property_definition_t</em></a> has a lot more options. For example, is it possible to hide properties from the editor, etc. For more information, read the documentation <a href="https://ourmachinery.com/apidoc/foundation/the_truth.h.html#structtm_the_truth_property_definition_t"><em>here</em></a><em>.</em></p>
</blockquote>
<p>After we have thought about this, we need to provide the <code>create_object_type</code> function with the new information:</p>
<pre><code class="language-c">static void create_truth_types(struct tm_the_truth_o *tt)
{
    static tm_the_truth_property_definition_t my_asset_properties[] = {
        { &quot;import_path&quot;, TM_THE_TRUTH_PROPERTY_TYPE_STRING },
        { &quot;data&quot;, TM_THE_TRUTH_PROPERTY_TYPE_BUFFER},
    };
    const tm_tt_type_t type = tm_the_truth_api-&gt;create_object_type(tt, TM_TT_TYPE__MY_ASSET, my_asset_properties, 2);
    tm_the_truth_api-&gt;set_aspect(tt, type, TM_TT_ASPECT__FILE_EXTENSION, &quot;my_asset&quot;);
}
</code></pre>
<p>Now we should change the asset name to something more meaningful than <code>my_asset</code>. Lets call it <code>txt</code></p>
<p>The renaming has as a consequence that we need to change three places:</p>
<ul>
<li>Asset Name</li>
<li>Menu Name</li>
<li>File extension</li>
<li>The source file: <code>my_asset.c/h</code> -&gt; <code>txt.c/h</code></li>
</ul>
<p>This will change the code as follows:</p>
<pre><code class="language-c">//.. other code
static void create_truth_types(struct tm_the_truth_o *tt)
{
//... the other code
    tm_the_truth_api-&gt;set_aspect(tt, type, TM_TT_ASPECT__FILE_EXTENSION, &quot;txt&quot;);
}
// .. other code
static tm_asset_browser_create_asset_i asset_browser_create_my_asset = {
    .menu_name = TM_LOCALIZE_LATER(&quot;New Text File&quot;),
    .asset_name = TM_LOCALIZE_LATER(&quot;New Text File&quot;),
    .create = asset_browser_create,
};
</code></pre>
<p>Let's have a look at how it looks in the editor:</p>
<p><img src="https://paper-attachments.dropbox.com/s_892FB4725BEE1D4E7D7CCEA6A89558987964DFF4B0524E03B4E0F6FFCF6E0FED_1609926443262_image.png" alt="creating a new asset" /></p>
<h2 id="load-a-text-file"><a class="header" href="#load-a-text-file">Load a text file</a></h2>
<p>After creating a new asset, the asset looks as following in the editor:</p>
<p><img src="https://paper-attachments.dropbox.com/s_892FB4725BEE1D4E7D7CCEA6A89558987964DFF4B0524E03B4E0F6FFCF6E0FED_1609926772154_image.png" alt="" /></p>
<p>This asset file is still not quite how we want it because we have not loaded a text file yet. Therefore let us load a file next. At first, we will do it by <em>hand</em> via loading a file whenever we are changing the path, and then later on (in the next chapter) we are writing our importer. It will allow us to drag and drop files into the Engine as well or use the <em>Import Menu.</em></p>
<h3 id="custom-ui"><a class="header" href="#custom-ui">Custom UI</a></h3>
<p>To archive our first manual loading, we need to add a custom UI associated with our type. We can do this via the properties aspect <a href="https://ourmachinery.com/apidoc/plugins/editor_views/properties.h.html#tm_tt_aspect__properties">TM_TT_ASPECT__PROPERTIES</a>. It means we need to go back to the <code>create_truth_types</code> function and add a new Aspect and a new object associated with this Aspect.</p>
<p>The Aspect expects a <a href="https://ourmachinery.com/apidoc/plugins/editor_views/properties.h.html#structtm_properties_aspect_i">tm_properties_aspect_i</a> object. When defining the object, we are focused only on is the custom_ui field. </p>
<blockquote>
<p>Note: This struct has many different fields which are not interesting to us now. (If you want more information on them, check out the <a href="https://ourmachinery.com/apidoc/plugins/editor_views/properties.h.html#structtm_properties_aspect_i">documentation</a>.</p>
</blockquote>
<p>The <code>custom_ui</code> expected s function pointer of the type <code>float (*custom_ui)(struct tm_properties_ui_args_t *args, tm_rect_t item_rect, tm_tt_id_t object, uint32_t indent)</code>.</p>
<p>Let us quickly go over this:</p>
<p><em>Function Arguments:</em></p>
<table><thead><tr><th><strong>Argument</strong></th><th><strong>Data Type</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>1 (<code>args</code>)</td><td><a href="https://ourmachinery.com/apidoc/plugins/editor_views/properties.h.html#structtm_properties_ui_args_t">tm_properties_ui_args_t</a></td><td>A bundled type of important information. For example this is the way you would retrieve your ui instance as well as your uistyle instance. For more information check the <a href="https://ourmachinery.com/apidoc/plugins/editor_views/properties.h.html#structtm_properties_ui_args_t">documentation</a>.</td></tr>
<tr><td>2 (<code>item_rect</code>)</td><td><a href="https://ourmachinery.com/apidoc/foundation/api_types.h.html#structtm_rect_t">tm_rect_t</a></td><td>The ui rectangular of the current item. This can be manipulated in x,y as well as w and h as long as the correct y value is being returned.</td></tr>
<tr><td>3 (<code>object</code>)</td><td><a href="https://ourmachinery.com/apidoc/foundation/api_types.h.html#structtm_tt_id_t">tm_tt_id_t</a></td><td>The truth object id of the current object. Can be used to read information of.</td></tr>
<tr><td>4 (<code>indent</code>)</td><td><code>uint32_t</code></td><td>Used for intention.</td></tr>
</tbody></table>
<p><em>Return values</em></p>
<table><thead><tr><th><strong>Type</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>float</td><td>This is the being used as the next y value of the following element.</td></tr>
</tbody></table>
<p>We need to define a static instance of the <a href="https://ourmachinery.com/apidoc/plugins/editor_views/properties.h.html#structtm_properties_aspect_i">tm_properties_aspect_i*</a> and a custom UI function.</p>
<pre><code class="language-c">//.. other code
static float properties__custom_ui(struct tm_properties_ui_args_t *args, tm_rect_t item_rect, tm_tt_id_t object, uint32_t indent)
{
// -- code
}
//.. other code    
static tm_properties_aspect_i properties_aspect = {
        .custom_ui = properties__custom_ui,
    };
// .. other code
</code></pre>
<p>Now the properties aspect needs to know about the existence of our custom UI. It follows the same principle as the properties:</p>
<pre><code class="language-c">//.. other code
static void create_truth_types(struct tm_the_truth_o *tt)
{
//... the other code
    tm_the_truth_api-&gt;set_aspect(tt, type, TM_TT_ASPECT__PROPERTIES, &amp;properties_aspect);
}
//... the other code
</code></pre>
<p>In the editor, the change is imminently visible. The UI is gone because we have chosen to provide our custom UI.</p>
<p><img src="https://paper-attachments.dropbox.com/s_892FB4725BEE1D4E7D7CCEA6A89558987964DFF4B0524E03B4E0F6FFCF6E0FED_1609928409366_image.png" alt="" /></p>
<p>It is time to add the imported file property back to the UI panel. The first step is to think about what our property shall represent:
When we defined it, we described it as type <a href="https://ourmachinery.com/apidoc/foundation/the_truth.h.html#enumtm_the_truth_property_type">TM_THE_TRUTH_PROPERTY_TYPE_STRING</a>. 
It is essential to know because the <a href="https://ourmachinery.com/apidoc/plugins/editor_views/properties.h.html#properties.h">properties header file</a> has the <a href="https://ourmachinery.com/apidoc/plugins/editor_views/properties.h.html#structtm_properties_view_api">properties view API</a>, which has many built-in functions for default behavior.</p>
<p>One of the things we can find in there is the <a href="https://ourmachinery.com/apidoc/plugins/editor_views/properties.h.html#structtm_properties_view_api.ui_open_path()">ui_open_path</a> which sounds perfect for the import path. The buffer (data) does not need to be displayed yet. Before using any Properties-View API functions, we need to request the API in our load plugin function.</p>
<pre><code class="language-c">// -- api's
static struct tm_properties_view_api *tm_properties_view_api;
//.. other code 
// -- load plugin
TM_DLL_EXPORT void tm_load_plugin(struct tm_api_registry_api *reg, bool load)
{
//.. other code 
    tm_properties_view_api = reg-&gt;get(TM_PROPERTIES_VIEW_API_NAME);
//.. other code 
} 
</code></pre>
<p>Now we can use and implement the path opening function. Let us look at its <a href="https://ourmachinery.com/apidoc/plugins/editor_views/properties.h.html#structtm_properties_view_api.ui_open_path()">signature</a> first:</p>
<p><code>float (*ui_open_path)(struct tm_properties_ui_args_t *args, tm_rect_t item_rect, const char *name, const char *tooltip, tm_tt_id_t object, uint32_t property, const char *extensions, const char *description, bool *picked)</code></p>
<p><em>Function Arguments:</em></p>
<table><thead><tr><th><strong>Argument</strong></th><th><strong>Data Type</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>1 (<code>args</code>)</td><td><a href="https://ourmachinery.com/apidoc/plugins/editor_views/properties.h.html#structtm_properties_ui_args_t">tm_properties_ui_args_t</a></td><td>A bundled type of important information. For example this is the way you would retrieve your UI instance as well as your <code>uistyle</code> instance. For more information check the <a href="https://ourmachinery.com/apidoc/plugins/editor_views/properties.h.html#structtm_properties_ui_args_t">documentation</a>.</td></tr>
<tr><td>2 (<code>item_rect</code>)</td><td><a href="https://ourmachinery.com/apidoc/foundation/api_types.h.html#structtm_rect_t">tm_rect_t</a></td><td>The UI rectangular of the current item. This can be manipulated in x,y as well as w and h as long as the correct y value is being returned.</td></tr>
<tr><td>3 (<code>n</code>ame)</td><td><code>const char*</code></td><td>This is the name the Properties tab will display as the title in front of the text field.</td></tr>
<tr><td>4 (<code>t</code>ooltip)</td><td><code>const char*</code></td><td>Extra information if needed. (Optional)</td></tr>
<tr><td>5 (object)</td><td><a href="https://ourmachinery.com/apidoc/foundation/api_types.h.html#structtm_tt_id_t">tm_tt_id_t</a></td><td>The truth object id of the current object. Can be used to read information of.</td></tr>
<tr><td>6 (property)</td><td><code>uint32_t</code></td><td>Property index</td></tr>
<tr><td>7 (<code>extensions</code>)</td><td><code>const char*</code></td><td>List of potential file extension supported by the open dialog</td></tr>
<tr><td>8 (<code>description</code>)</td><td><code>const char*</code></td><td>List of descriptions for the potential file extensions</td></tr>
<tr><td>9 (picked)</td><td><code>bool*</code></td><td>Out pointer indicating if a file has been picked or not. (optional)</td></tr>
</tbody></table>
<p><em>Return values</em></p>
<table><thead><tr><th><strong>Type</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>float</td><td>This is the being used as the next y value of the following element.</td></tr>
</tbody></table>
<p>To implement the function all that's needed to remember is what index the property had.</p>
<pre><code class="language-c">    static tm_the_truth_property_definition_t my_asset_properties[] = {
        { &quot;import_path&quot;, TM_THE_TRUTH_PROPERTY_TYPE_STRING },
        { &quot;data&quot;, TM_THE_TRUTH_PROPERTY_TYPE_BUFFER},
    };
</code></pre>
<p>The index is 0 there for we are no ready to implement the function:</p>
<pre><code class="language-c">//custom ui
static float properties__custom_ui(struct tm_properties_ui_args_t *args, tm_rect_t item_rect, tm_tt_id_t object, uint32_t indent)
{
    // -- code
    bool picked = false;
    item_rect.y = tm_properties_view_api-&gt;ui_open_path(args, item_rect, &quot;Imported Path&quot;, &quot;Path that the text file was imported from.&quot;, object, 0, &quot;txt&quot;, &quot;text files&quot;, &amp;picked);
    if (picked)
    {
        // import...
    }
    return item_rect.y;
}
</code></pre>
<p>Remembering all of those indices is quite cucumbersome! Therefore, it is better to define an enum in our header file. Define an <code>enum</code> for each property <code>TM_TT_PROP__[NAME_OF_TYPE]__[NAME_OF_PROPERTY]</code></p>
<pre><code class="language-c">#pragma once
#include &lt;foundation/api_types.h&gt;
//... more code
#define TM_TT_TYPE__MY_ASSET &quot;tm_my_asset&quot;
#define TM_TT_TYPE_HASH__MY_ASSET TM_STATIC_HASH(&quot;tm_my_asset&quot;, 0x1e12ba1f91b99960ULL)

enum {
    TM_TT_PROP__MY_ASSET__FILE,
    TM_TT_PROP__MY_ASSET__DATA,
}
</code></pre>
<p>(<code>txt.h</code>)</p>
<p>When we compiled this we can test it in the engine, just by adding a new text file click on the Import Path:</p>
<p><img src="https://paper-attachments.dropbox.com/s_892FB4725BEE1D4E7D7CCEA6A89558987964DFF4B0524E03B4E0F6FFCF6E0FED_1609931496164_image.png" alt="" /></p>
<p>The next step is using the OS API to load a file from the disc and store it in the buffer. This process works after the same principle as adding the properties view API. </p>
<p>The OS API (<a href="https://ourmachinery.com/apidoc/foundation/os.h.html#structtm_os_api">tm_os_api</a>) lives in the <a href="https://ourmachinery.com/apidoc/foundation/os.h.html#os.h">os.h</a> and has a member called <a href="https://ourmachinery.com/apidoc/foundation/os.h.html#structtm_os_file_io_api">file_io</a>, allowing access to the <a href="https://ourmachinery.com/apidoc/foundation/os.h.html#structtm_os_file_io_api">tm_os_file_io_api</a>. With this API, we can read a file. The following example code shows how reading the file and storing it in a buffer could look like in this case. </p>
<pre><code class="language-c">//other includes
#include &lt;foundation/os.h&gt;
#include &lt;foundation/buffer.h&gt;
//.. other code
//custom ui
static float properties__custom_ui(struct tm_properties_ui_args_t *args, tm_rect_t item_rect, tm_tt_id_t object, uint32_t indent)
{
    tm_the_truth_o *tt = args-&gt;tt;
    bool picked = false;
    item_rect.y = tm_properties_view_api-&gt;ui_open_path(args, item_rect, TM_LOCALIZE_LATER(&quot;Import Path&quot;), TM_LOCALIZE_LATER(&quot;Path that the text file was imported from.&quot;), object, TM_TT_PROP__MY_ASSET__FILE, &quot;txt&quot;, &quot;text files&quot;, &amp;picked);
    if (picked)
    {
        const char *file = tm_the_truth_api-&gt;get_string(tt, tm_tt_read(tt, object), TM_TT_PROP__MY_ASSET__FILE);

        tm_file_stat_t stat = tm_os_api-&gt;file_system-&gt;stat(file);

        tm_buffers_i *buffers = tm_the_truth_api-&gt;buffers(tt);
        void *buffer = buffers-&gt;allocate(buffers-&gt;inst, stat.size, false);

        tm_file_o f = tm_os_api-&gt;file_io-&gt;open_input(file);
        tm_os_api-&gt;file_io-&gt;read(f, buffer, stat.size);
        tm_os_api-&gt;file_io-&gt;close(f);

        const uint32_t buffer_id = buffers-&gt;add(buffers-&gt;inst, buffer, stat.size, 0);
        tm_the_truth_object_o *asset_obj = tm_the_truth_api-&gt;write(tt, object);
        tm_the_truth_api-&gt;set_buffer(tt, asset_obj, TM_TT_PROP__MY_ASSET__DATA, buffer_id); // 1 = data property index.
        tm_the_truth_api-&gt;commit(tt, asset_obj, TM_TT_NO_UNDO_SCOPE);
    }
    return item_rect.y;
}
</code></pre>
<p>First, we need to read out the file path from our The Truth object. After that, we can create the buffer we want to add to our <em>data</em> property (index 1 or <code>TM_TT_PROP___MY_ASSET__DATA</code>). 
The buffers live in the <a href="https://ourmachinery.com/apidoc/foundation/buffer.h.html#buffer.h">buffer.h</a>. We create the buffer via The Truth, and it also owns the memory. We are using the <a href="https://ourmachinery.com/apidoc/foundation/os.h.html#structtm_os_file_system_api">file_system API</a> to get the size of the text file. We need to know how big the file is to understand how big the buffer should be. </p>
<blockquote>
<p>Note: We should also check if the file exists. It has been left out because we just picked the file. </p>
</blockquote>
<p>Then we are reading the file from the disc and store its content in the allocated buffer. The next step is to add the buffer to the Truth buffers via the <a href="https://ourmachinery.com/apidoc/foundation/buffer.h.html#structtm_buffers_i.add()">buffers-&gt;add(buffers-&gt;inst, buffer, stat.size, 0);</a> call. It adds a buffer containing the specified data of size. It returns an ID identifying the new buffer. For more information, read <a href="https://ourmachinery.com/apidoc/foundation/buffer.h.html#structtm_buffers_i.add()">here</a>.</p>
<p>Now we need to ask the Truth to give us a writeable object. Objects from the Truth are immutable in their default state and can only be made mutable by asking explicitly for a writable object.
This happens via the <a href="https://ourmachinery.com/apidoc/foundation/the_truth.h.html#structtm_the_truth_api.write()">tm_the_truth_object_o *asset_obj = tm_the_truth_api-&gt;write(tt, object);</a> call.</p>
<p>With the writeable object, we can set the buffer, and then we can commit the changes to the Truth itself.</p>
<p>This iteration is the first, but the issue with it is that we cannot import or drag and drop a .txt file into the Engine. We will tackle this issue in the <a href="the_truth/custom_asset/part2.html#">next part</a>.</p>
<h2 id="what-is-next-1"><a class="header" href="#what-is-next-1">What is next?</a></h2>
<p>The next part will refactor the current code and show you how to make your code and asset more useful by showing you how to program an importer.</p>
<p><a href="the_truth/custom_asset/part2.html#">Part 3</a></p>
<h2 id="full-example-source-code"><a class="header" href="#full-example-source-code">Full example source code</a></h2>
<p><code>txt.h</code></p>
<pre><code class="language-c">#pragma once
#include &lt;foundation/api_types.h&gt;
//... more code
#define TM_TT_TYPE__MY_ASSET &quot;tm_my_asset&quot;
#define TM_TT_TYPE_HASH__MY_ASSET TM_STATIC_HASH(&quot;tm_my_asset&quot;, 0x1e12ba1f91b99960ULL)

enum {
    TM_TT_PROP__MY_ASSET__FILE,
    TM_TT_PROP__MY_ASSET__DATA,
};
</code></pre>
<p><code>txt.c</code></p>
<pre><code class="language-c">// -- api's
static struct tm_the_truth_api *tm_the_truth_api;
static struct tm_properties_view_api *tm_properties_view_api;
static struct tm_os_api *tm_os_api;
// -- inlcudes
#include &lt;foundation/api_registry.h&gt;
#include &lt;foundation/the_truth.h&gt;
#include &lt;foundation/undo.h&gt;
#include &lt;foundation/the_truth_assets.h&gt;
#include &lt;foundation/localizer.h&gt;
#include &lt;foundation/macros.h&gt;
#include &lt;foundation/os.h&gt;
#include &lt;foundation/buffer.h&gt;

#include &lt;plugins/editor_views/asset_browser.h&gt;
#include &lt;plugins/editor_views/properties.h&gt;

#include &quot;txt.h&quot;

//custom ui
static float properties__custom_ui(struct tm_properties_ui_args_t *args, tm_rect_t item_rect, tm_tt_id_t object, uint32_t indent)
{
    tm_the_truth_o *tt = args-&gt;tt;
    bool picked = false;
    item_rect.y = tm_properties_view_api-&gt;ui_open_path(args, item_rect, TM_LOCALIZE_LATER(&quot;Import Path&quot;), TM_LOCALIZE_LATER(&quot;Path that the text file was imported from.&quot;), object, TM_TT_PROP__MY_ASSET__FILE, &quot;txt&quot;, &quot;text files&quot;, &amp;picked);
    if (picked)
    {
        const char *file = tm_the_truth_api-&gt;get_string(tt, tm_tt_read(tt, object), TM_TT_PROP__MY_ASSET__FILE);
        tm_file_stat_t stat = tm_os_api-&gt;file_system-&gt;stat(file);
        tm_buffers_i *buffers = tm_the_truth_api-&gt;buffers(tt);
        void *buffer = buffers-&gt;allocate(buffers-&gt;inst, stat.size, false);
        tm_file_o f = tm_os_api-&gt;file_io-&gt;open_input(file);
        tm_os_api-&gt;file_io-&gt;read(f, buffer, stat.size);
        tm_os_api-&gt;file_io-&gt;close(f);
        const uint32_t buffer_id = buffers-&gt;add(buffers-&gt;inst, buffer, stat.size, 0);
        tm_the_truth_object_o *asset_obj = tm_the_truth_api-&gt;write(tt, object);
        tm_the_truth_api-&gt;set_buffer(tt, asset_obj, TM_TT_PROP__MY_ASSET__DATA, buffer_id);
        tm_the_truth_api-&gt;commit(tt, asset_obj, TM_TT_NO_UNDO_SCOPE);
    }
    return item_rect.y;
}
// -- create truth type
static void create_truth_types(struct tm_the_truth_o *tt)
{
    static tm_the_truth_property_definition_t my_asset_properties[] = {
        {&quot;import_path&quot;, TM_THE_TRUTH_PROPERTY_TYPE_STRING},
        {&quot;data&quot;, TM_THE_TRUTH_PROPERTY_TYPE_BUFFER},
    };
    const tm_tt_type_t type = tm_the_truth_api-&gt;create_object_type(tt, TM_TT_TYPE__MY_ASSET, my_asset_properties, TM_ARRAY_COUNT(my_asset_properties));
    tm_the_truth_api-&gt;set_aspect(tt, type, TM_TT_ASPECT__FILE_EXTENSION, &quot;txt&quot;);
    static tm_properties_aspect_i properties_aspect = {
        .custom_ui = properties__custom_ui,
    };
    tm_the_truth_api-&gt;set_aspect(tt, type, TM_TT_ASPECT__PROPERTIES, &amp;properties_aspect);
}
// -- asset browser regsiter interface
static tm_tt_id_t asset_browser_create(struct tm_asset_browser_create_asset_o *inst, tm_the_truth_o *tt, tm_tt_undo_scope_t undo_scope)
{
    const tm_tt_type_t type = tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__MY_ASSET);
    return tm_the_truth_api-&gt;create_object_of_type(tt, type, undo_scope);
}
static tm_asset_browser_create_asset_i asset_browser_create_my_asset = {
    .menu_name = TM_LOCALIZE_LATER(&quot;New Text File&quot;),
    .asset_name = TM_LOCALIZE_LATER(&quot;New Text File&quot;),
    .create = asset_browser_create,
};
// -- load plugin
TM_DLL_EXPORT void tm_load_plugin(struct tm_api_registry_api *reg, bool load)
{
    tm_the_truth_api = reg-&gt;get(TM_THE_TRUTH_API_NAME);
    tm_properties_view_api = reg-&gt;get(TM_PROPERTIES_VIEW_API_NAME);
    tm_os_api = reg-&gt;get(TM_OS_API_NAME);
    tm_add_or_remove_implementation(reg, load, TM_THE_TRUTH_CREATE_TYPES_INTERFACE_NAME, create_truth_types);
    tm_add_or_remove_implementation(reg, load, TM_ASSET_BROWSER_CREATE_ASSET_INTERFACE_NAME, &amp;asset_browser_create_my_asset);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-a-custom-asset-part-3"><a class="header" href="#create-a-custom-asset-part-3">Create a custom asset part 3</a></h1>
<p>This walkthrough shows you how to add a custom asset to the Engine. You should have basic knowledge about how to write a custom plugin. If not, you might want to check this <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/extending_the_machinery/the_plugin_system.html">Guide</a>. The goal for this walkthrough is to write a text file asset.</p>
<p>This part will cover the following topics:</p>
<ul>
<li>How to write an importer</li>
</ul>
<blockquote>
<p>You can find the whole source code in its git repo: <a href="https://github.com/simon-ourmachinery/example-text-file-asset">example-text-file-asset</a></p>
</blockquote>
<p><strong>Table of Content</strong></p>
<ul>
<li><a href="the_truth/custom_asset/part3.html#custom-importer-for-text-files">Custom importer for text files</a></li>
<li><a href="the_truth/custom_asset/part3.html#import-task-set-up">Import Task set up</a></li>
<li><a href="the_truth/custom_asset/part3.html#import-task-implementation">Import task implementation</a></li>
<li><a href="the_truth/custom_asset/part3.html#enabling-reimport">Enabling reimport</a></li>
<li><a href="the_truth/custom_asset/part3.html#refactor-the-custom-ui-import-functionality">Refactor the Custom UI import functionality</a></li>
<li><a href="the_truth/custom_asset/part3.html#the-end">The end</a></li>
</ul>
<h2 id="custom-importer-for-text-files"><a class="header" href="#custom-importer-for-text-files">Custom importer for text files</a></h2>
<p>In this part, we are adding the ability to import a text file into the Engine. To implement an importer, we need the following APIs:</p>
<table><thead><tr><th><strong>Name</strong></th><th><strong>header file</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>tm_asset_io_api</td><td>foundation/asset_io.h</td><td>This api provides us with the interface for the actual importer.</td></tr>
<tr><td>tm_temp_allocator_api</td><td>foundation/temp_allocator.h</td><td>Provides a easy way to allocate temporary memory.</td></tr>
<tr><td>tm_allocator_api</td><td>foundation/allocator.h</td><td>Allows us access to different kind of allocators. For example to the system allocator. We need this one later when we rewrite our reimport.</td></tr>
<tr><td>tm_path_api</td><td>foundation/path.h</td><td>Allows us to split a path.</td></tr>
<tr><td>tm_api_registry_api</td><td>foundation/api_registry.h</td><td>Allows us to retrive a API from the registry.</td></tr>
<tr><td>tm_task_system_api</td><td>foundation/task_system.h</td><td>Allowes us to spawm tasks</td></tr>
</tbody></table>
<p>After we have included all the needed header files and retrieved all the APIs from the registry, we can start to write an importer.</p>
<blockquote>
<p>Note: <a href="https://ourmachinery.com/apidoc/foundation/api_registry.h.html#structtm_api_registry_api">tm_api_registry_api</a> can be retrived from the reg parameter in the <code>tm_load_plugin</code> function. <code>tm_global_api_registry = reg;</code></p>
</blockquote>
<p>The Machinery has a generic interface for asset importers. It requires a bunch of functions to be able to work as intended. The struct we need to implement is called <a href="https://ourmachinery.com/apidoc/foundation/asset_io.h.html#structtm_asset_io_import">tm_asset_io_i</a>. It requires us to set the following members:</p>
<table><thead><tr><th>Member</th><th>Description</th></tr></thead><tbody>
<tr><td>enabled</td><td>A function ptr that returns a bool. If the return value is true the importer is active.</td></tr>
<tr><td>can_import</td><td>A function ptr that returns <code>true</code> if this asset IO interface can import archives with the file extension <code>extension</code>. This can be achieved by comparing the file extesions.<br><br>Optional, if not implemented, nothing can be imported.</td></tr>
<tr><td>can_reimport</td><td>A function ptr that returns <code>true</code> if this asset IO interface can re-import the specified truth asset (of type <code>TM_TT_TYPE_ASSET</code>). Optional, if not implemented, nothing can be re-importe</td></tr>
<tr><td>importer_extensions_string</td><td>A function ptr that shall append the correct file extention string to the list of possible file extenstions</td></tr>
<tr><td>importer_description_string</td><td>A function ptr that shall append the correct file extention descriptions string to the list of possible file extenstions descriptions.</td></tr>
<tr><td>import_asset</td><td>The actual function that starts a import task. If non-zero, the return value is the ID of the background task from <a href="https://ourmachinery.com/apidoc/foundation/task_system.h.html#structtm_task_system_api">tm_task_system_api</a> that does the import.</td></tr>
</tbody></table>
<p>All these members expect a function pointer. Therefore, we need to provide the functionality.</p>
<p>To implement the first functions, we need to do the following steps:</p>
<pre><code class="language-c">//... other includes
#include &lt;foundation/carray_print.inl&gt;
#include &lt;foundation/string.inl&gt;
#include &lt;foundation/localizer.h&gt;
//... other code
static bool asset_io__enabled(struct tm_asset_io_o *inst)
{
    return true;
}
static bool asset_io__can_import(struct tm_asset_io_o *inst, const char *extension)
{
    return tm_strcmp_ignore_case(extension, &quot;txt&quot;) == 0;
}
static bool asset_io__can_reimport(struct tm_asset_io_o *inst, struct tm_the_truth_o *tt, tm_tt_id_t asset)
{
    const tm_tt_id_t object = tm_the_truth_api-&gt;get_subobject(tt, tm_tt_read(tt, asset), TM_TT_PROP__ASSET__OBJECT);
    return tm_tt_type(object).u64 == tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__MY_ASSET).u64;
}
static void asset_io__importer_extensions_string(struct tm_asset_io_o *inst, char **output, struct tm_temp_allocator_i *ta, const char *separator)
{
    tm_carray_temp_printf(output, ta, &quot;txt&quot;);
}
static void asset_io__importer_description_string(struct tm_asset_io_o *inst, char **output, struct tm_temp_allocator_i *ta, const char *separator)
{
    tm_carray_temp_printf(output, ta, &quot;.txt&quot;);
}
</code></pre>
<p>Let us go through them:</p>
<ul>
<li>The <code>enabled</code> function returns true because we want the importer to work. </li>
<li>The <code>asset_io__can_import</code> will compare the given extension with the one we want to support.</li>
</ul>
<blockquote>
<p>Note: <a href="https://ourmachinery.com/apidoc/foundation/string.inl.html#tm_strcmp_ignore_case()">tm_strcmp_ignore_case</a> requires a localizer. That is why we need the localizer API and the localizer header file. It is not needed if the importer shall be case-sensitive.</p>
</blockquote>
<ul>
<li>The <code>asset_io__can_reimport</code> compares the object type of the given object with the object of our type. </li>
</ul>
<blockquote>
<p><a href="https://ourmachinery.com/apidoc/foundation/the_truth_assets.h.html#enumtm_tt_prop__asset">TM_TT_PROP__ASSET__OBJECT</a> is the property of the <a href="https://ourmachinery.com/apidoc/foundation/the_truth_assets.h.html#tm_tt_type__asset">TM_TT_TYPE__ASSET</a> type which holds the object associated with the asset.</p>
</blockquote>
<p>The last two functions will append the file extension <code>.txt</code> to the file extensions and description. Note that the argument output is a <a href="https://ourmachinery.com/apidoc/foundation/carray.inl.html#carray.inl">carray</a>. That is why we can use the <a href="https://ourmachinery.com/apidoc/foundation/carray_print.inl.html#tm_carray_temp_printf()">tm_carray_temp_printf</a> function.</p>
<blockquote>
<p>Note: The <code>carray_print.h</code> requires the <a href="https://ourmachinery.com/apidoc/foundation/sprintf.h.html#structtm_sprintf_api">tm_sprintf_api</a>. Therefore, we need to include the right header here.</p>
</blockquote>
<h2 id="import-task-set-up"><a class="header" href="#import-task-set-up">Import Task set up</a></h2>
<p>The importer function <code>asset_io__import_asset</code> can spawn a task with the task system and pass through the needed information. We need to create a data structure to hold all our data.</p>
<p><em>What data does our task need?</em> </p>
<p>This task needs to know where to find the file. Moreover it needs to access some essential types such as the Truth and allocator. The struct could look like this:</p>
<pre><code class="language-c">struct task__import_txt
{
    uint64_t bytes;
    struct tm_asset_io_import args;
    char file[8];
};
</code></pre>
<p>The <code>asset_io</code> header has a nice utility struct predefined the <a href="https://ourmachinery.com/apidoc/foundation/asset_io.h.html#structtm_asset_io_import">tm_asset_io_import</a>. When an asset is being imported the caller of the  <code>asset_io__import_asset()</code> will hand through all the needed details: </p>
<ul>
<li>The right Truth object</li>
<li>the correct allocator. </li>
</ul>
<p>The function itself looks like this:</p>
<pre><code class="language-c">// .. other code
static uint64_t asset_io__import_asset(struct tm_asset_io_o *inst, const char *file, const struct tm_asset_io_import *args)
{
    const uint64_t bytes = sizeof(struct task__import_txt) + strlen(file);
    struct task__import_txt *task = tm_alloc(args-&gt;allocator, bytes);
    *task = (struct task__import_txt){
        .bytes = bytes,
        .args = *args,
    };
    strcpy(task-&gt;file, file);
    return task_system-&gt;run_task(task__import_txt, task, &quot;Import Text File&quot;);
}
</code></pre>
<blockquote>
<p><strong>Important</strong>: The task is the memory owner and needs to clean it up at the end of the execution!</p>
</blockquote>
<p>This line <code>task_system-&gt;run_task(task__import_txt, task, &quot;Import Text File&quot;);</code> will run a task and return its id. The actual task is the function <code>task__import_txt()</code>. </p>
<blockquote>
<p>Info: For more information on the task system check the <a href="https://ourmachinery.com/apidoc/foundation/task_system.h.html#structtm_task_system_api.run_task()">documentation</a>.</p>
</blockquote>
<h2 id="import-task-implementation"><a class="header" href="#import-task-implementation">Import task implementation</a></h2>
<p>The import task has the function to import data and clean up afterward.</p>
<p>It may look like this:</p>
<pre><code class="language-c">static void task__import_txt(void *data, uint64_t task_id)
{
// all our work
}
</code></pre>
<p>The data <code>ptr</code> needs to be cast into our defined data type: <code>task__import_txt</code>. You could use the task id to update its progress. We do not need to do it in this example.</p>
<blockquote>
<p>For more information on how to update the status of a task. It will be shown in the editor check out the <a href="https://ourmachinery.com/apidoc/foundation/progress_report.h.html#structtm_progress_report_api">documentation</a>.</p>
</blockquote>
<p>We are left with the following steps:</p>
<ul>
<li>Implement the actual importing (similar to the previous chapter).</li>
<li>Implement the reimport.</li>
</ul>
<p>First, we need to retrieve the basic information from the task data:</p>
<pre><code class="language-c">static void task__import_txt(void *data, uint64_t task_id)
{
    struct task__import_txt *task = (struct task__import_txt *)data;
    const struct tm_asset_io_import *args = &amp;task-&gt;args;
    const char *txt_file = task-&gt;file;
    tm_the_truth_o *tt = args-&gt;tt;
//.. more
}
</code></pre>
<p>After that, we implement the same code as in the previous chapter. We need to open the file, allocate a buffer and add the buffer to the object, either a new one (import) or an existing one (reimport).</p>
<p><strong>An important note is to do this time error checking</strong>: </p>
<ul>
<li>Does the file exist? </li>
<li>Does the file size match with the read file? </li>
</ul>
<p>To ask those questions is vital because we are in the async territory. In case of an error, we want to inform the user. Therefore, we need to get the logging API (<code>tm_logger_api = reg-&gt;get(TM_LOGGER_API_NAME);</code>) as well. You can find it in the <code>foundation/log.h</code> file.</p>
<p>The subsequent step is to check if the file exists. You can do this through the filesystem API:</p>
<pre><code class="language-c">static void task__import_txt(void *data, uint64_t task_id)
{
    struct task__import_txt *task = (struct task__import_txt *)data;
    const struct tm_asset_io_import *args = &amp;task-&gt;args;
    const char *txt_file = task-&gt;file;
    tm_the_truth_o *tt = args-&gt;tt;
    tm_file_stat_t stat = tm_os_api-&gt;file_system-&gt;stat(txt_file);
    if (stat.exists)
    {
    // .. code
    else
    {
        tm_logger_api-&gt;printf(TM_LOG_TYPE_INFO, &quot;import txt:cound not find %s \n&quot;, txt_file);
    }
}
</code></pre>
<p>Now we combine all the knowledge from this chapter and the previous chapter. We need to create a new asset via code for the import, and for the reimport, we need to update an existing file. 
Before we do all of this, let us first read the file and create the buffer.</p>
<pre><code class="language-c">static void task__import_txt(void *data, uint64_t task_id)
{
    struct task__import_txt *task = (struct task__import_txt *)data;
    const struct tm_asset_io_import *args = &amp;task-&gt;args;
    const char *txt_file = task-&gt;file;
    tm_the_truth_o *tt = args-&gt;tt;
    tm_file_stat_t stat = tm_os_api-&gt;file_system-&gt;stat(txt_file);
    if (stat.exists)
    {
        tm_buffers_i *buffers = tm_the_truth_api-&gt;buffers(tt);
        void *buffer = buffers-&gt;allocate(buffers-&gt;inst, stat.size, false);
        tm_file_o f = tm_os_api-&gt;file_io-&gt;open_input(txt_file);
        const int64_t read = tm_os_api-&gt;file_io-&gt;read(f, buffer, stat.size);
        tm_os_api-&gt;file_io-&gt;close(f);
// ..code
    else
    {
        tm_logger_api-&gt;printf(TM_LOG_TYPE_INFO, &quot;import txt:cound not find %s \n&quot;, txt_file);
    }
}
</code></pre>
<p>After this, we should ensure that the file size matches the size of the read data.</p>
<pre><code class="language-c">static void task__import_txt(void *data, uint64_t task_id)
{
    struct task__import_txt *task = (struct task__import_txt *)data;
    const struct tm_asset_io_import *args = &amp;task-&gt;args;
    const char *txt_file = task-&gt;file;
    tm_the_truth_o *tt = args-&gt;tt;
    tm_file_stat_t stat = tm_os_api-&gt;file_system-&gt;stat(txt_file);
    if (stat.exists)
    {
        tm_buffers_i *buffers = tm_the_truth_api-&gt;buffers(tt);
        void *buffer = buffers-&gt;allocate(buffers-&gt;inst, stat.size, false);
        tm_file_o f = tm_os_api-&gt;file_io-&gt;open_input(txt_file);
        const int64_t read = tm_os_api-&gt;file_io-&gt;read(f, buffer, stat.size);
        tm_os_api-&gt;file_io-&gt;close(f);
        if (read == (int64_t)stat.size)
        {
        // ..code
        }
        else
        {
            tm_logger_api-&gt;printf(TM_LOG_TYPE_INFO, &quot;import txt:cound not read %s\n&quot;, txt_file);
        }
    else
    {
        tm_logger_api-&gt;printf(TM_LOG_TYPE_INFO, &quot;import txt:cound not find %s \n&quot;, txt_file);
    }
}
</code></pre>
<p>With this out of the way, we can use our knowledge from the [last part](#): </p>
<ul>
<li>How to add an asset via code.</li>
</ul>
<p>The first step was to create the new object and add the data to it.</p>
<pre><code class="language-c">const uint32_t buffer_id = buffers-&gt;add(buffers-&gt;inst, buffer, stat.size, 0);
const tm_tt_type_t plugin_asset_type = tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__MY_ASSET);
const tm_tt_id_t asset_id = tm_the_truth_api-&gt;create_object_of_type(tt, plugin_asset_type, TM_TT_NO_UNDO_SCOPE);
tm_the_truth_object_o *asset_obj = tm_the_truth_api-&gt;write(tt, asset_id);
tm_the_truth_api-&gt;set_buffer(tt, asset_obj, TM_TT_PROP__MY_ASSET__DATA, buffer_id);
tm_the_truth_api-&gt;set_string(tt, asset_obj, TM_TT_PROP__MY_ASSET__FILE, txt_file);
 tm_the_truth_api-&gt;commit(tt, asset_obj, args-&gt;undo_scope);
</code></pre>
<p>After that, we are using the <a href="https://ourmachinery.com/apidoc/plugins/editor_views/asset_browser.h.html#structtm_asset_browser_add_asset_api">tm_asset_browser_add_asset_api</a> to add the asset to the asset browser. </p>
<pre><code class="language-c">tm_asset_browser_add_asset_api *add_asset = tm_global_api_registry-&gt;get(TM_ASSET_BROWSER_ADD_ASSET_API_NAME);
</code></pre>
<p>We are getting the API first, because we do not need it anywhere else than in this case. Then we need to extract the file name of the imported file. You can do this with the <em>path API</em>'s <code> tm_path_api-&gt;base()</code> function. Be aware this function requires a <a href="https://ourmachinery.com/apidoc/foundation/api_types.h.html#structtm_str_t">tm_str_t</a> which you an create from a normal c string (<code>const char*</code>) via <code>tm_str()</code>. To access the underlaying c string again just call <code>.data</code> on the <a href="https://ourmachinery.com/apidoc/foundation/api_types.h.html#structtm_str_t">tm_str_t</a>.</p>
<blockquote>
<p>Used to represent a string slice with pointer and length.</p>
<p>This lets you reason about parts of a string, which you are not able to do with standard NULL-terminated strings.</p>
<p><a href="https://ourmachinery.com/apidoc/foundation/api_types.h.html#structtm_str_t">documentation</a></p>
</blockquote>
<p>After this step we need to get the current folder. Therefore we are asking the <a href="https://ourmachinery.com/apidoc/plugins/editor_views/asset_browser.h.html#structtm_asset_browser_add_asset_api">tm_asset_browser_add_asset_api</a> what the current folder is. Then we decide if want to select the file. At the end we are calling add function of the <code>tm_asset_browser_add_asset_api-&gt;add()</code>. </p>
<blockquote>
<p><strong>Note:</strong> We do not have any asset labels for our current asset therefore we do not pass them to the add function, otherwise the last 2 arguments would be different than <code>0</code> and <code>0</code>.</p>
</blockquote>
<pre><code class="language-c">                const char *asset_name = tm_path_api-&gt;base(tm_str(txt_file)).data;
                tm_asset_browser_add_asset_api *add_asset = tm_global_api_registry-&gt;get(TM_ASSET_BROWSER_ADD_ASSET_API_NAME);
                const tm_tt_id_t current_dir = add_asset-&gt;current_directory(add_asset-&gt;inst, args-&gt;ui);
                const bool should_select = args-&gt;asset_browser.u64 &amp;&amp; tm_the_truth_api-&gt;version(tt, args-&gt;asset_browser) == args-&gt;asset_browser_version_at_start;
                // we do not have any asset label therefore we do not need to pass them thats why the last
                // 2 arguments are 0 and 0!
                add_asset-&gt;add(add_asset-&gt;inst, current_dir, asset_id, asset_name, args-&gt;undo_scope, should_select, args-&gt;ui,0,0);
</code></pre>
<p>That's it for the import.  Before we move on, we need to clean up! No Allocation without deallocation!</p>
<pre><code class="language-c">    tm_free(args-&gt;allocator, task, task-&gt;bytes);
</code></pre>
<blockquote>
<p>Info:  If you don't do this, the Engine will inform you that there is a memory leak in the logs/terminal.</p>
</blockquote>
<p>Now bringing it all together:</p>
<pre><code class="language-c">static void task__import_txt(void *data, uint64_t task_id)
{
    struct task__import_txt *task = (struct task__import_txt *)data;
    const struct tm_asset_io_import *args = &amp;task-&gt;args;
    const char *txt_file = task-&gt;file;
    tm_the_truth_o *tt = args-&gt;tt;
    tm_file_stat_t stat = tm_os_api-&gt;file_system-&gt;stat(txt_file);
    if (stat.exists)
    {
        tm_buffers_i *buffers = tm_the_truth_api-&gt;buffers(tt);
        void *buffer = buffers-&gt;allocate(buffers-&gt;inst, stat.size, false);
        tm_file_o f = tm_os_api-&gt;file_io-&gt;open_input(txt_file);
        const int64_t read = tm_os_api-&gt;file_io-&gt;read(f, buffer, stat.size);
        tm_os_api-&gt;file_io-&gt;close(f);
        if (read == (int64_t)stat.size)
        {
const uint32_t buffer_id = buffers-&gt;add(buffers-&gt;inst, buffer, stat.size, 0);
const tm_tt_type_t plugin_asset_type = tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__MY_ASSET);
const tm_tt_id_t asset_id = tm_the_truth_api-&gt;create_object_of_type(tt, plugin_asset_type, TM_TT_NO_UNDO_SCOPE);
tm_the_truth_object_o *asset_obj = tm_the_truth_api-&gt;write(tt, asset_id);
tm_the_truth_api-&gt;set_buffer(tt, asset_obj, TM_TT_PROP__MY_ASSET__DATA, buffer_id);
tm_the_truth_api-&gt;set_string(tt, asset_obj, TM_TT_PROP__MY_ASSET__FILE, txt_file);
 tm_the_truth_api-&gt;commit(tt, asset_obj, args-&gt;undo_scope);
                tm_the_truth_api-&gt;commit(tt, asset_obj, args-&gt;undo_scope);
                const char *asset_name = tm_path_api-&gt;base(tm_str(txt_file)).data;
                tm_asset_browser_add_asset_api *add_asset = tm_global_api_registry-&gt;get(TM_ASSET_BROWSER_ADD_ASSET_API_NAME);
                const tm_tt_id_t current_dir = add_asset-&gt;current_directory(add_asset-&gt;inst, args-&gt;ui);
                const bool should_select = args-&gt;asset_browser.u64 &amp;&amp; tm_the_truth_api-&gt;version(tt, args-&gt;asset_browser) == args-&gt;asset_browser_version_at_start;
                // we do not have any asset label therefore we do not need to pass them thats why the last
                // 2 arguments are 0 and 0!
                add_asset-&gt;add(add_asset-&gt;inst, current_dir, asset_id, asset_name, args-&gt;undo_scope, should_select, args-&gt;ui,0,0);
        }
        else
        {
            tm_logger_api-&gt;printf(TM_LOG_TYPE_INFO, &quot;import txt:cound not read %s\n&quot;, txt_file);
        }
    }
    else
    {
        tm_logger_api-&gt;printf(TM_LOG_TYPE_INFO, &quot;import txt:cound not find %s \n&quot;, txt_file);
    }
    tm_free(args-&gt;allocator, task, task-&gt;bytes);
}
</code></pre>
<h2 id="enabling-reimport"><a class="header" href="#enabling-reimport">Enabling reimport</a></h2>
<p>The previous import task would never be able to reimport an asset. Let us fix this quickly!
The <a href="https://ourmachinery.com/apidoc/foundation/asset_io.h.html#structtm_asset_io_import">tm_asset_io_import</a> has a field called <code>reimport_into</code> of type <a href="https://ourmachinery.com/apidoc/foundation/api_types.h.html#structtm_tt_id_t">tm_tt_id_t</a>, which we did not set. If the current context is an import, otherwise a valid the truth id. It enables us to check if the current context is an import or reimport. To achieve this, we need to update the <code>reimport_into</code> object with the newly created object asset_obj, and you can do this via The Truth API function <code>retarget_write.</code> It takes an object and updates it with the new content. Commit the change and destroy the temporary object (asset_obj).</p>
<pre><code class="language-c">            if (args-&gt;reimport_into.u64)
            {
                tm_the_truth_api-&gt;retarget_write(tt, asset_obj, args-&gt;reimport_into);
                tm_the_truth_api-&gt;commit(tt, asset_obj, args-&gt;undo_scope);
                tm_the_truth_api-&gt;destroy_object(tt, asset_id, args-&gt;undo_scope);
            }
</code></pre>
<p>This changes the source code as following:</p>
<pre><code class="language-c">static void task__import_txt(void *data, uint64_t task_id)
{
    struct task__import_txt *task = (struct task__import_txt *)data;
    const struct tm_asset_io_import *args = &amp;task-&gt;args;
    const char *txt_file = task-&gt;file;
    tm_the_truth_o *tt = args-&gt;tt;
    tm_file_stat_t stat = tm_os_api-&gt;file_system-&gt;stat(txt_file);
    if (stat.exists) {
        tm_buffers_i *buffers = tm_the_truth_api-&gt;buffers(tt);
        void *buffer = buffers-&gt;allocate(buffers-&gt;inst, stat.size, false);
        tm_file_o f = tm_os_api-&gt;file_io-&gt;open_input(txt_file);
        const int64_t read = tm_os_api-&gt;file_io-&gt;read(f, buffer, stat.size);
        tm_os_api-&gt;file_io-&gt;close(f);
        if (read == (int64_t)stat.size) {
            const uint32_t buffer_id = buffers-&gt;add(buffers-&gt;inst, buffer, stat.size, 0);
            const tm_tt_type_t plugin_asset_type = tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__MY_ASSET);
            const tm_tt_id_t asset_id = tm_the_truth_api-&gt;create_object_of_type(tt, plugin_asset_type, TM_TT_NO_UNDO_SCOPE);
            tm_the_truth_object_o *asset_obj = tm_the_truth_api-&gt;write(tt, asset_id);
            tm_the_truth_api-&gt;set_buffer(tt, asset_obj, TM_TT_PROP__MY_ASSET__DATA, buffer_id);
            tm_the_truth_api-&gt;set_string(tt, asset_obj, TM_TT_PROP__MY_ASSET__FILE, txt_file);
            if (args-&gt;reimport_into.u64) {
                tm_the_truth_api-&gt;retarget_write(tt, asset_obj, args-&gt;reimport_into);
                tm_the_truth_api-&gt;commit(tt, asset_obj, args-&gt;undo_scope);
                tm_the_truth_api-&gt;destroy_object(tt, asset_id, args-&gt;undo_scope);
            } else {
                tm_the_truth_api-&gt;commit(tt, asset_obj, args-&gt;undo_scope);
                const char *asset_name = tm_path_api-&gt;base(tm_str(txt_file)).data;
                struct tm_asset_browser_add_asset_api *add_asset = tm_global_api_registry-&gt;get(TM_ASSET_BROWSER_ADD_ASSET_API_NAME);
                const tm_tt_id_t current_dir = add_asset-&gt;current_directory(add_asset-&gt;inst, args-&gt;ui);
                const bool should_select = args-&gt;asset_browser.u64 &amp;&amp; tm_the_truth_api-&gt;version(tt, args-&gt;asset_browser) == args-&gt;asset_browser_version_at_start;
                add_asset-&gt;add(add_asset-&gt;inst, current_dir, asset_id, asset_name, args-&gt;undo_scope, should_select, args-&gt;ui, 0, 0);
            }
        } else {
            tm_logger_api-&gt;printf(TM_LOG_TYPE_INFO, &quot;import txt:cound not read %s\n&quot;, txt_file);
        }
    } else {
        tm_logger_api-&gt;printf(TM_LOG_TYPE_INFO, &quot;import txt:cound not find %s \n&quot;, txt_file);
    }
    tm_free(args-&gt;allocator, task, task-&gt;bytes);
}
</code></pre>
<h2 id="refactor-the-custom-ui-import-functionality"><a class="header" href="#refactor-the-custom-ui-import-functionality">Refactor the Custom UI import functionality</a></h2>
<p>The last step before this part is over is to refactor the initial import of the file when we change the property in its custom UI. The current code does everything async. Besides, if we would leave this, we would have code duplication, which we want to avoid, for better-maintained reasons.</p>
<p>You might argue that it is the same process as just reimporting an asset when we change the path. That's correct!</p>
<p>We can reuse our Import-Task. Before we can launch a task, we need to ensure we have the right setup!
We can check the documentation of <a href="https://ourmachinery.com/apidoc/foundation/asset_io.h.html#structtm_asset_io_import">tm_asset_io_import</a> to ensure we do not forget anything important. </p>
<p>After we have done that, we will find that the reimport task needs besides the file name:</p>
<ul>
<li>the allocator</li>
<li>the current Truth</li>
<li>the object to import reimport into</li>
</ul>
<p>Now we can write our reimport task code. The code itself looks like this:</p>
<pre><code class="language-c">            tm_allocator_i *allocator = tm_allocator_api-&gt;system;
            const uint64_t bytes = sizeof(struct task__import_txt) + strlen(file);
            struct task__import_txt *task = tm_alloc(allocator, bytes);
            *task = (struct task__import_txt){
                .bytes = bytes,
                .args = {
                    .allocator = allocator,
                    .tt = tt,
                    .reimport_into = object}};
            strcpy(task-&gt;file, file);
            task_system-&gt;run_task(task__import_txt, task, &quot;Import Text File&quot;);
</code></pre>
<p>First, we ask for the system allocator (This one has the same lifetime as the program is running). Then, we allocate our task, including bytes for the string. Remember the struct structure:</p>
<pre><code class="language-c">// -- struct definitions
struct task__import_txt
{
    uint64_t bytes;
    struct tm_asset_io_import args;
    char file[8];
};
// .. other code
</code></pre>
<p>After that, we initialize our struct and its members with the needed data. Moreover, we copy the chars of the file name into our struct + extra bytes, and then we ask the task system to run the task.</p>
<p>This, combined with the custom UI functions, should look similar to this:</p>
<pre><code class="language-c">//custom ui
static float properties__custom_ui(struct tm_properties_ui_args_t *args, tm_rect_t item_rect, tm_tt_id_t object, uint32_t indent)
{
    tm_the_truth_o *tt = args-&gt;tt;
    bool picked = false;
    item_rect.y = tm_properties_view_api-&gt;ui_open_path(args, item_rect, TM_LOCALIZE_LATER(&quot;Import Path&quot;), TM_LOCALIZE_LATER(&quot;Path that the text file was imported from.&quot;), object, TM_TT_PROP__MY_ASSET__FILE, &quot;txt&quot;, &quot;text files&quot;, &amp;picked);
    if (picked)
    {
        const char *file = tm_the_truth_api-&gt;get_string(tt, tm_tt_read(tt, object), TM_TT_PROP__MY_ASSET__FILE);
        {
            tm_allocator_i *allocator = tm_allocator_api-&gt;system;
            const uint64_t bytes = sizeof(struct task__import_txt) + strlen(file);
            struct task__import_txt *task = tm_alloc(allocator, bytes);
            *task = (struct task__import_txt){
                .bytes = bytes,
                .args = {
                    .allocator = allocator,
                    .tt = tt,
                    .reimport_into = object}};
            strcpy(task-&gt;file, file);
            task_system-&gt;run_task(task__import_txt, task, &quot;Import Text File&quot;);
        }
    }
    return item_rect.y;
}
</code></pre>
<p><em>(For more information on the structure of these functions, please check the previous part)</em></p>
<ul>
<li><a href="the_truth/custom_asset/part3.html#">Part 1</a></li>
<li><a href="the_truth/custom_asset/part3.html#">Part 2</a></li>
</ul>
<h2 id="the-end"><a class="header" href="#the-end">The end</a></h2>
<p>It is the end of this walkthrough. You might have gained a better understanding:</p>
<ul>
<li>Of the Truth </li>
<li>How to create an asset</li>
<li>How to import assets into the Engine</li>
<li>How to provide a custom UI. </li>
</ul>
<p>If you wanted to see a more complex example of an importer, you could check the assimp importer example <code>samples\plugins\assimp</code>.</p>
<p>All the source code is available on GitHub in the <a href="https://github.com/simon-ourmachinery/example-text-file-asset"><strong>example-text-file-asset</strong></a> repo.</p>
<p><strong>Full Source Code</strong></p>
<p><code>txt.h</code></p>
<pre><code class="language-c">#pragma once
#include &lt;foundation/api_types.h&gt;
//... more code
#define TM_TT_TYPE__MY_ASSET &quot;tm_my_asset&quot;
#define TM_TT_TYPE_HASH__MY_ASSET TM_STATIC_HASH(&quot;tm_my_asset&quot;, 0x1e12ba1f91b99960ULL)

enum {
    TM_TT_PROP__MY_ASSET__FILE,
    TM_TT_PROP__MY_ASSET__DATA,
};
</code></pre>
<p><code>txt.c</code></p>
<pre><code class="language-c">// -- api's
static struct tm_api_registry_api *tm_global_api_registry;
static struct tm_the_truth_api *tm_the_truth_api;
static struct tm_properties_view_api *tm_properties_view_api;
static struct tm_os_api *tm_os_api;
static struct tm_path_api *tm_path_api;
static struct tm_temp_allocator_api *tm_temp_allocator_api;
static struct tm_logger_api *tm_logger_api;
static struct tm_localizer_api *tm_localizer_api;
static struct tm_asset_io_api *tm_asset_io_api;
static struct tm_task_system_api *task_system;
static struct tm_allocator_api *tm_allocator_api;
static struct tm_sprintf_api *tm_sprintf_api;

// -- inlcudes

#include &lt;foundation/api_registry.h&gt;
#include &lt;foundation/asset_io.h&gt;
#include &lt;foundation/buffer.h&gt;
#include &lt;foundation/carray_print.inl&gt;
#include &lt;foundation/localizer.h&gt;
#include &lt;foundation/log.h&gt;
#include &lt;foundation/macros.h&gt;
#include &lt;foundation/os.h&gt;
#include &lt;foundation/path.h&gt;
#include &lt;foundation/sprintf.h&gt;
#include &lt;foundation/string.inl&gt;
#include &lt;foundation/task_system.h&gt;
#include &lt;foundation/temp_allocator.h&gt;
#include &lt;foundation/the_truth.h&gt;
#include &lt;foundation/the_truth_assets.h&gt;
#include &lt;foundation/undo.h&gt;

#include &lt;plugins/editor_views/asset_browser.h&gt;
#include &lt;plugins/editor_views/properties.h&gt;

#include &quot;txt.h&quot;
// -- struct definitions
struct task__import_txt
{
    uint64_t bytes;
    struct tm_asset_io_import args;
    char file[8];
};
/////
// -- functions:
////
// --- importer
static void task__import_txt(void *data, uint64_t task_id)
{
    struct task__import_txt *task = (struct task__import_txt *)data;
    const struct tm_asset_io_import *args = &amp;task-&gt;args;
    const char *txt_file = task-&gt;file;
    tm_the_truth_o *tt = args-&gt;tt;
    tm_file_stat_t stat = tm_os_api-&gt;file_system-&gt;stat(txt_file);
    if (stat.exists) {
        tm_buffers_i *buffers = tm_the_truth_api-&gt;buffers(tt);
        void *buffer = buffers-&gt;allocate(buffers-&gt;inst, stat.size, false);
        tm_file_o f = tm_os_api-&gt;file_io-&gt;open_input(txt_file);
        const int64_t read = tm_os_api-&gt;file_io-&gt;read(f, buffer, stat.size);
        tm_os_api-&gt;file_io-&gt;close(f);
        if (read == (int64_t)stat.size) {
            const uint32_t buffer_id = buffers-&gt;add(buffers-&gt;inst, buffer, stat.size, 0);
            const tm_tt_type_t plugin_asset_type = tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__MY_ASSET);
            const tm_tt_id_t asset_id = tm_the_truth_api-&gt;create_object_of_type(tt, plugin_asset_type, TM_TT_NO_UNDO_SCOPE);
            tm_the_truth_object_o *asset_obj = tm_the_truth_api-&gt;write(tt, asset_id);
            tm_the_truth_api-&gt;set_buffer(tt, asset_obj, TM_TT_PROP__MY_ASSET__DATA, buffer_id);
            tm_the_truth_api-&gt;set_string(tt, asset_obj, TM_TT_PROP__MY_ASSET__FILE, txt_file);
            if (args-&gt;reimport_into.u64) {
                tm_the_truth_api-&gt;retarget_write(tt, asset_obj, args-&gt;reimport_into);
                tm_the_truth_api-&gt;commit(tt, asset_obj, args-&gt;undo_scope);
                tm_the_truth_api-&gt;destroy_object(tt, asset_id, args-&gt;undo_scope);
            } else {
                tm_the_truth_api-&gt;commit(tt, asset_obj, args-&gt;undo_scope);
                const char *asset_name = tm_path_api-&gt;base(tm_str(txt_file)).data;
                struct tm_asset_browser_add_asset_api *add_asset = tm_global_api_registry-&gt;get(TM_ASSET_BROWSER_ADD_ASSET_API_NAME);
                const tm_tt_id_t current_dir = add_asset-&gt;current_directory(add_asset-&gt;inst, args-&gt;ui);
                const bool should_select = args-&gt;asset_browser.u64 &amp;&amp; tm_the_truth_api-&gt;version(tt, args-&gt;asset_browser) == args-&gt;asset_browser_version_at_start;
                add_asset-&gt;add(add_asset-&gt;inst, current_dir, asset_id, asset_name, args-&gt;undo_scope, should_select, args-&gt;ui, 0, 0);
            }
        } else {
            tm_logger_api-&gt;printf(TM_LOG_TYPE_INFO, &quot;import txt:cound not read %s\n&quot;, txt_file);
        }
    } else {
        tm_logger_api-&gt;printf(TM_LOG_TYPE_INFO, &quot;import txt:cound not find %s \n&quot;, txt_file);
    }
    tm_free(args-&gt;allocator, task, task-&gt;bytes);
}

static bool asset_io__enabled(struct tm_asset_io_o *inst)
{
    return true;
}
static bool asset_io__can_import(struct tm_asset_io_o *inst, const char *extension)
{
    return tm_strcmp_ignore_case(extension, &quot;txt&quot;) == 0;
}
static bool asset_io__can_reimport(struct tm_asset_io_o *inst, struct tm_the_truth_o *tt, tm_tt_id_t asset)
{
    const tm_tt_id_t object = tm_the_truth_api-&gt;get_subobject(tt, tm_tt_read(tt, asset), TM_TT_PROP__ASSET__OBJECT);
    return object.type == tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__MY_ASSET).u64;
}
static void asset_io__importer_extensions_string(struct tm_asset_io_o *inst, char **output, struct tm_temp_allocator_i *ta, const char *separator)
{
    tm_carray_temp_printf(output, ta, &quot;txt&quot;);
}
static void asset_io__importer_description_string(struct tm_asset_io_o *inst, char **output, struct tm_temp_allocator_i *ta, const char *separator)
{
    tm_carray_temp_printf(output, ta, &quot;.txt&quot;);
}
static uint64_t asset_io__import_asset(struct tm_asset_io_o *inst, const char *file, const struct tm_asset_io_import *args)
{
    const uint64_t bytes = sizeof(struct task__import_txt) + strlen(file);
    struct task__import_txt *task = tm_alloc(args-&gt;allocator, bytes);
    *task = (struct task__import_txt){
        .bytes = bytes,
        .args = *args,
    };
    strcpy(task-&gt;file, file);
    return task_system-&gt;run_task(task__import_txt, task, &quot;Import Text File&quot;);
}
static struct tm_asset_io_i txt_asset_io = {
    .enabled = asset_io__enabled,
    .can_import = asset_io__can_import,
    .can_reimport = asset_io__can_reimport,
    .importer_extensions_string = asset_io__importer_extensions_string,
    .importer_description_string = asset_io__importer_description_string,
    .import_asset = asset_io__import_asset
};

// -- asset on its own

//custom ui
static float properties__custom_ui(struct tm_properties_ui_args_t *args, tm_rect_t item_rect, tm_tt_id_t object, uint32_t indent)
{
    tm_the_truth_o *tt = args-&gt;tt;
    bool picked = false;
    item_rect.y = tm_properties_view_api-&gt;ui_open_path(args, item_rect, TM_LOCALIZE_LATER(&quot;Import Path&quot;), TM_LOCALIZE_LATER(&quot;Path that the text file was imported from.&quot;), object, TM_TT_PROP__MY_ASSET__FILE, &quot;txt&quot;, &quot;text files&quot;, &amp;picked);
    if (picked) {
        const char *file = tm_the_truth_api-&gt;get_string(tt, tm_tt_read(tt, object), TM_TT_PROP__MY_ASSET__FILE);
        {
            tm_allocator_i *allocator = tm_allocator_api-&gt;system;
            const uint64_t bytes = sizeof(struct task__import_txt) + strlen(file);
            struct task__import_txt *task = tm_alloc(allocator, bytes);
            *task = (struct task__import_txt){
                .bytes = bytes,
                .args = {
                    .allocator = allocator,
                    .tt = tt,
                    .reimport_into = object }
            };
            strcpy(task-&gt;file, file);
            task_system-&gt;run_task(task__import_txt, task, &quot;Import Text File&quot;);
        }
    }
    return item_rect.y;
}

// -- create truth type
static void create_truth_types(struct tm_the_truth_o *tt)
{
    static tm_the_truth_property_definition_t my_asset_properties[] = {
        { &quot;import_path&quot;, TM_THE_TRUTH_PROPERTY_TYPE_STRING },
        { &quot;data&quot;, TM_THE_TRUTH_PROPERTY_TYPE_BUFFER },
    };
    const tm_tt_type_t type = tm_the_truth_api-&gt;create_object_type(tt, TM_TT_TYPE__MY_ASSET, my_asset_properties, TM_ARRAY_COUNT(my_asset_properties));
    tm_the_truth_api-&gt;set_aspect(tt, type, TM_TT_ASPECT__FILE_EXTENSION, &quot;txt&quot;);
    static tm_properties_aspect_i properties_aspect = {
        .custom_ui = properties__custom_ui,
    };
    tm_the_truth_api-&gt;set_aspect(tt, type, TM_TT_ASPECT__PROPERTIES, &amp;properties_aspect);
}

// -- asset browser regsiter interface
static tm_tt_id_t asset_browser_create(struct tm_asset_browser_create_asset_o *inst, tm_the_truth_o *tt, tm_tt_undo_scope_t undo_scope)
{
    const tm_tt_type_t type = tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__MY_ASSET);
    return tm_the_truth_api-&gt;create_object_of_type(tt, type, undo_scope);
}
static tm_asset_browser_create_asset_i asset_browser_create_my_asset = {
    .menu_name = TM_LOCALIZE_LATER(&quot;New Text File&quot;),
    .asset_name = TM_LOCALIZE_LATER(&quot;New Text File&quot;),
    .create = asset_browser_create,
};

// -- load plugin
TM_DLL_EXPORT void tm_load_plugin(struct tm_api_registry_api *reg, bool load)
{
    tm_the_truth_api = reg-&gt;get(TM_THE_TRUTH_API_NAME);
    tm_properties_view_api = reg-&gt;get(TM_PROPERTIES_VIEW_API_NAME);
    tm_os_api = reg-&gt;get(TM_OS_API_NAME);
    tm_path_api = reg-&gt;get(TM_PATH_API_NAME);
    tm_temp_allocator_api = reg-&gt;get(TM_TEMP_ALLOCATOR_API_NAME);
    tm_allocator_api = reg-&gt;get(TM_ALLOCATOR_API_NAME);
    tm_logger_api = reg-&gt;get(TM_LOGGER_API_NAME);
    tm_localizer_api = reg-&gt;get(TM_LOCALIZER_API_NAME);
    tm_asset_io_api = reg-&gt;get(TM_ASSET_IO_API_NAME);
    task_system = reg-&gt;get(TM_TASK_SYSTEM_API_NAME);
    tm_sprintf_api = reg-&gt;get(TM_SPRINTF_API_NAME);
    tm_global_api_registry = reg;
    if (load)
        tm_asset_io_api-&gt;add_asset_io(&amp;txt_asset_io);
    else
        tm_asset_io_api-&gt;remove_asset_io(&amp;txt_asset_io);
    tm_add_or_remove_implementation(reg, load, TM_THE_TRUTH_CREATE_TYPES_INTERFACE_NAME, create_truth_types);
    tm_add_or_remove_implementation(reg, load, TM_ASSET_BROWSER_CREATE_ASSET_INTERFACE_NAME, &amp;asset_browser_create_my_asset);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-drag-and-drop-to-assets"><a class="header" href="#adding-drag-and-drop-to-assets">Adding Drag and Drop to Assets</a></h1>
<p>This walkthrough shows you how to enable a asset to be drag and dropped. You should have basic knowledge about how to write a custom plugin. If not, you might want to check this <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/extending_the_machinery/the_plugin_system.html">Guide</a>. The goal of this walkthrough is to enable you to drag and drop your asset into the Scene!</p>
<p>You will learn:</p>
<ul>
<li>how to use an aspect in practice</li>
<li>How to extend an already existing asset.</li>
<li>How to use an entity-component manager.</li>
</ul>
<p>This walkthrough will refer to the text asset example as the asset we want to extend! If you have not followed it here is the link: <a href="https://ourmachinery.github.io/themachinery-books/tutorials//the_truth/custom_asset/index.html">Custom Asset</a></p>
<p><strong>Table of Content</strong></p>
<ul>
<li><a href="the_truth/drag_and_drop.html#about-aspects">About aspects</a></li>
<li><a href="the_truth/drag_and_drop.html#adding-drag-and-drop-to-our-asset">Adding Drag and Drop to our asset</a>
<ul>
<li><a href="the_truth/drag_and_drop.html#asset-scene-aspect">Asset Scene Aspect</a></li>
</ul>
</li>
<li><a href="the_truth/drag_and_drop.html#the-story-component">The story component</a>
<ul>
<li><a href="the_truth/drag_and_drop.html#custom-ui">Custom UI</a></li>
</ul>
</li>
<li><a href="the_truth/drag_and_drop.html#using-the-asset-picker-property-aspect">Using the Asset Picker Property Aspect</a></li>
<li><a href="the_truth/drag_and_drop.html#drag-and-drop-a-text-asset-into-the-scene-and-create-an-entity">Drag and drop a Text Asset into the Scene and create an entity</a></li>
<li><a href="the_truth/drag_and_drop.html#modify-a-already-existing-asset">Modify a already existing asset</a></li>
</ul>
<h2 id="about-aspects"><a class="header" href="#about-aspects">About aspects</a></h2>
<p>An “aspect” is an interface (struct of function pointers) identified by a unique identifier. The Truth allows you to associate aspects with object types. This lets you extend The Truth with new functionality. For example, you could add an interface for debug printing an object:</p>
<pre><code class="language-c"> #define TM_TT_ASPECT__DEBUG_PRINT TM_STATIC_HASH(&quot;tm_debug_print_aspect_i&quot;, 0x39821c78639e0773ULL)

 typedef struct tm_debug_print_aspect_i {
    void (*debug_print)(tm_the_truth_o *tt, uint64_t o);
} tm_debug_print_aspect_i;
</code></pre>
<p>You could then use this code to debug print an object <code>o</code> with:</p>
<pre><code class="language-c">tm_debug_print_aspect_i *dp = tm_the_truth_api-&gt;get_aspect(tt, tm_tt_type(o), TM_DEBUG_PRINT_ASPECT);
if (dp)
    dp-&gt;debug_print(tt, o);
</code></pre>
<blockquote>
<p><strong>Note</strong>: that plugins can extend the system with completely new aspects.</p>
</blockquote>
<p>The best example of how the Engine is using the aspect system is the <a href="https://ourmachinery.com/apidoc/plugins/editor_views/properties.h.html#tm_tt_aspect__properties">TM_TT_ASPECT__PROPERTIES</a> which helps us to defines custom UIs for Truth objects.</p>
<h2 id="adding-drag-and-drop-to-our-asset"><a class="header" href="#adding-drag-and-drop-to-our-asset">Adding Drag and Drop to our asset</a></h2>
<p>In this example, we are going back to our text asset sample. In that sample, we have the following function to register the asset to the Truth:</p>
<pre><code class="language-c">// -- create truth type
static void create_truth_types(struct tm_the_truth_o *tt)
{
    static tm_the_truth_property_definition_t my_asset_properties[] = {
        { &quot;import_path&quot;, TM_THE_TRUTH_PROPERTY_TYPE_STRING },
        { &quot;data&quot;, TM_THE_TRUTH_PROPERTY_TYPE_BUFFER },
    };
    const tm_tt_type_t type = tm_the_truth_api-&gt;create_object_type(tt, TM_TT_TYPE__TXT_ASSET, my_asset_properties, TM_ARRAY_COUNT(txt_asset_properties));
    tm_the_truth_api-&gt;set_aspect(tt, type, TM_TT_ASPECT__FILE_EXTENSION, &quot;txt&quot;);
    static tm_properties_aspect_i properties_aspect = {
        .custom_ui = properties__custom_ui,
    };
    tm_the_truth_api-&gt;set_aspect(tt, type, TM_TT_ASPECT__PROPERTIES, &amp;properties_aspect);
}
</code></pre>
<p>We need to make use of the <a href="https://ourmachinery.com/apidoc/plugins/the_machinery_shared/asset_aspects.h.html#tm_tt_aspect__asset_scene">TM_TT_ASPECT__ASSET_SCENE</a> aspect. This aspect allows the associated Truth Type to be dragged and dropped to the Scene if wanted! We can find it in the <code>plugins/the_machinery_shared/asset_aspects.h</code> header.</p>
<h3 id="asset-scene-aspect"><a class="header" href="#asset-scene-aspect">Asset Scene Aspect</a></h3>
<p>This aspect expects an instance of the <a href="https://ourmachinery.com/apidoc/plugins/the_machinery_shared/asset_aspects.h.html#structtm_asset_scene_api">tm_asset_scene_api</a>. When we provide a call-back called</p>
<p><code>bool (*droppable)(struct tm_asset_scene_o *inst, struct tm_the_truth_o *tt, tm_tt_id_t asset);</code> we tell the scene that we can drag the asset out of the asset browser. We need to return true for this. In this case you need to provide the <code>create_entity</code> function. When you drag your asset into the Scene, this function is called by the Engine. In this function, you can create a new entity and attach it to the parent entity ( which might be the world.  If you drag it on top of another entity, you can attach the newly created entity as a child entity to this one. </p>
<p>Before we can make use of this we need some component to be created for our Text Asset! Lets call it Story Component.</p>
<h2 id="the-story-component"><a class="header" href="#the-story-component">The story component</a></h2>
<p>Let us create a use case for our text file. Let us assume we wanted to make a very simple story-based game, and all our text files are the basis for our stories. This means we need to create first a story component.</p>
<blockquote>
<p>Note: For more details on how to create a component, follow this <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book//gameplay_coding/ecs/write_a_custom_component.html">guide</a>.</p>
</blockquote>
<p>Here we have the whole source code for the story component:</p>
<pre><code class="language-c">// more apis
static struct tm_entity_api *tm_entity_api;
// more includes
#include &lt;plugins/entity/entity.h&gt;
#include &lt;plugins/the_machinery_shared/component_interfaces/editor_ui_interface.h&gt;
// other types
struct tm_component_manager_o
{
    tm_entity_context_o *ctx;
    tm_allocator_i allocator;
};

// more code

static const char *component__category(void)
{
    return TM_LOCALIZE(&quot;Story&quot;);
}

static tm_ci_editor_ui_i *editor_aspect = &amp;(tm_ci_editor_ui_i){
    .category = component__category
};

// This code can be eliminated if needed / wanted by using the [TM_TT_PROP_ASPECT__PROPERTIES__ASSET_PICKER](https://ourmachinery.com/apidoc/plugins/editor_views/properties.h.html#tm_tt_prop_aspect__properties__asset_picker)
static float properties__component_custom_ui(struct tm_properties_ui_args_t *args, tm_rect_t item_rect, tm_tt_id_t object, uint32_t indent)
{
    TM_INIT_TEMP_ALLOCATOR(ta);
    tm_tt_type_t asset_type = tm_the_truth_api-&gt;object_type_from_name_hash(args-&gt;tt, TM_TT_TYPE_HASH__ASSET);
    // get all instances of `TM_TT_TYPE_HASH__TXT_ASSET`
    tm_tt_id_t *ids = tm_the_truth_api-&gt;all_objects_of_type(args-&gt;tt, tm_the_truth_api-&gt;object_type_from_name_hash(args-&gt;tt, TM_TT_TYPE_HASH__TXT_ASSET), ta);
    tm_tt_id_t *items = 0;
    const char **names = 0;
    tm_carray_temp_push(names, &quot;Select&quot;, ta);
    tm_carray_temp_push(items, (tm_tt_id_t){ 0 }, ta);
    for (uint32_t i = 0; i &lt; tm_carray_size(ids); ++i) {
        // we make sure a Asset Type is the owner of the object! This is important since
        // the Asset Truth type has the name field! [TM_TT_PROP__ASSET__NAME](https://ourmachinery.com/apidoc/foundation/the_truth_assets.h.html#enumtm_tt_prop__asset)
        tm_tt_id_t owner = tm_the_truth_api-&gt;owner(args-&gt;tt, ids[i]);
        if (tm_tt_type(owner).u64 == asset_type.u64) {
            // if the owner is a asset we add it's name to our names array and use the id and add it to ower items!
            tm_carray_temp_push(names, tm_the_truth_api-&gt;get_string(args-&gt;tt, tm_tt_read(args-&gt;tt, owner), TM_TT_PROP__ASSET__NAME), ta);
            tm_carray_temp_push(items, ids[i], ta);
        }
    }
    // creates a popup picker and the user can choose what reference they want to put into the property!
    item_rect.y = tm_properties_view_api-&gt;ui_reference_popup_picker(args, item_rect, &quot;Asset&quot;, NULL, object, TM_TT_PROP__STORY_COMPONENT__ASSET, names, items, (uint32_t)tm_carray_size(items));
    TM_SHUTDOWN_TEMP_ALLOCATOR(ta); // always make sure you call the shutdown function on the temp allocator
    return item_rect.y;
}


// -- create truth type
static void create_truth_types(struct tm_the_truth_o *tt)
{
// ..other code
    tm_the_truth_property_definition_t story_component_properties[] = {
        [TM_TT_PROP__STORY_COMPONENT__ASSET] = { &quot;story_asset&quot;, .type = TM_THE_TRUTH_PROPERTY_TYPE_REFERENCE, .type_hash = TM_TT_TYPE_HASH__TXT_ASSET }
    };
    static tm_properties_aspect_i properties_component_aspect = {
        .custom_ui = properties__component_custom_ui,
    };

    const tm_tt_type_t story_component_type = tm_the_truth_api-&gt;create_object_type(tt, TM_TT_TYPE__STORY_COMPONENT, story_component_properties, TM_ARRAY_COUNT(story_component_properties));
    tm_the_truth_api-&gt;set_aspect(tt, story_component_type, TM_CI_EDITOR_UI, editor_aspect);
    tm_the_truth_api-&gt;set_aspect(tt, story_component_type, TM_TT_ASPECT__PROPERTIES, &amp;properties_component_aspect);
}
// ..other code
// -- story component
static bool component__load_asset(tm_component_manager_o *man, tm_entity_t e, void *c_vp, const tm_the_truth_o *tt, tm_tt_id_t asset)
{
    struct tm_story_component_t *c = c_vp;
    const tm_the_truth_object_o *asset_r = tm_tt_read(tt, asset);
    tm_tt_id_t id = tm_the_truth_api-&gt;get_reference(tt, asset_r, TM_TT_PROP__STORY_COMPONENT__ASSET);
    if (id.u64) {
        tm_tt_buffer_t buffer = tm_the_truth_api-&gt;get_buffer(tt, tm_tt_read(tt, id), TM_TT_PROP__MY_ASSET__DATA);
        c-&gt;text = tm_alloc(&amp;man-&gt;allocator, buffer.size);
        c-&gt;size = buffer.size;
        memcpy(c-&gt;text, buffer.data, buffer.size);
    }
    return true;
}

static void component__remove(tm_component_manager_o *manager, tm_entity_t e, void *data)
{
    tm_story_component_t *sc = (tm_story_component_t *)data;
    tm_free(&amp;manager-&gt;allocator, sc-&gt;text, sc-&gt;size);
}

static void component__destroy(tm_component_manager_o *manager)
{
    tm_entity_api-&gt;call_remove_on_all_entities(manager-&gt;ctx, tm_entity_api-&gt;lookup_component_type(manager-&gt;ctx, TM_TT_TYPE_HASH__STORY_COMPONENT));
    // Free the actual manager struct and the allocator used to allocate it.
    tm_entity_context_o *ctx = manager-&gt;ctx;
    tm_allocator_i allocator = manager-&gt;allocator;
    tm_free(&amp;allocator, manager, sizeof(tm_component_manager_o));
    tm_entity_api-&gt;destroy_child_allocator(ctx, &amp;allocator);
}

static void component__create(struct tm_entity_context_o *ctx)
{
    // Allocate a new manager for this component type (freed in component__destroy).
    tm_allocator_i allocator;
    tm_entity_api-&gt;create_child_allocator(ctx, TM_TT_TYPE__STORY_COMPONENT, &amp;allocator);
    tm_component_manager_o *story_manager = tm_alloc(&amp;allocator, sizeof(tm_component_manager_o));

    *story_manager = (tm_component_manager_o){
        .ctx = ctx,
        .allocator = allocator
    };

    tm_component_i component = {
        .name = TM_TT_TYPE__STORY_COMPONENT,
        .bytes = sizeof(struct tm_story_component_t),
        .load_asset = component__load_asset,
        .destroy = component__destroy,
        .remove = component__remove,
        .manager = (tm_component_manager_o *)story_manager
    };
    tm_entity_api-&gt;register_component(ctx, &amp;component);
};
// -- load plugin
TM_DLL_EXPORT void tm_load_plugin(struct tm_api_registry_api *reg, bool load)
{
// other code
    tm_entity_api = reg-&gt;get(TM_ENTITY_API_NAME);
// ... other code
    tm_add_or_remove_implementation(reg, load, TM_THE_TRUTH_CREATE_TYPES_INTERFACE_NAME, create_truth_types);
    tm_add_or_remove_implementation(reg, load, TM_ENTITY_CREATE_COMPONENT_INTERFACE_NAME, component__create);
}
</code></pre>
<p>First, we create our component, and we need a way to guarantee that our truth data exists during runtime as well. Therefore, we use the Entity Manager to allocate our Story data and store just a pointer and its size to the allocated data in the Manager.</p>
<pre><code class="language-c">
struct tm_component_manager_o
{
    tm_entity_context_o *ctx;
    tm_allocator_i allocator;
};
static void component__create(struct tm_entity_context_o *ctx)
{
    // Allocate a new manager for this component type (freed in component__destroy).
    tm_allocator_i allocator;
    tm_entity_api-&gt;create_child_allocator(ctx, TM_TT_TYPE__STORY_COMPONENT, &amp;allocator);
    tm_component_manager_o *story_manager = tm_alloc(&amp;allocator, sizeof(tm_component_manager_o));

    *story_manager = (tm_component_manager_o){
        .ctx = ctx,
        .allocator = allocator
    };

    tm_component_i component = {
        .name = TM_TT_TYPE__STORY_COMPONENT,
        .bytes = sizeof(struct tm_story_component_t),
        .load_asset = component__load_asset,
        .destroy = component__destroy,
        .remove = component__remove,
        .manager = (tm_component_manager_o *)story_manager
    };
    tm_entity_api-&gt;register_component(ctx, &amp;component);
};

</code></pre>
<p>The most important function here is the <code>component__load_asset</code> function, in which we translate the Truth Representation into an ECS representation. We load the text buffer, allocate it with the Manager, and store a pointer in our component. With this, we could create a reference-counted system in which multiple components point to the same story data, and only when the last component goes we deallocate this. Another alternative would be to avoid loading when we create the component, and the story is already allocated.</p>
<pre><code class="language-c">static bool component__load_asset(tm_component_manager_o *man, tm_entity_t e, void *c_vp, const tm_the_truth_o *tt, tm_tt_id_t asset)
{
    struct tm_story_component_t *c = c_vp;
    const tm_the_truth_object_o *asset_r = tm_tt_read(tt, asset);
    tm_tt_id_t id = tm_the_truth_api-&gt;get_reference(tt, asset_r, TM_TT_PROP__STORY_COMPONENT__ASSET);
    if (id.u64) {
        tm_tt_buffer_t buffer = tm_the_truth_api-&gt;get_buffer(tt, tm_tt_read(tt, id), TM_TT_PROP__MY_ASSET__DATA);
        c-&gt;text = tm_alloc(&amp;man-&gt;allocator, buffer.size);
        c-&gt;size = buffer.size;
        memcpy(c-&gt;text, buffer.data, buffer.size);
    }
    return true;
}
</code></pre>
<p>When the Entity context gets destroyed, we need to clean up and destroy our Manager. Important that we call <code>call_remove_on_all_entities</code> to make sure all instances of the component are gone.</p>
<pre><code class="language-c">static void component__remove(tm_component_manager_o *manager, tm_entity_t e, void *data)
{
    tm_story_component_t *sc = (tm_story_component_t *)data;
    tm_free(&amp;manager-&gt;allocator, sc-&gt;text, sc-&gt;size);
}

static void component__destroy(tm_component_manager_o *manager)
{
    tm_entity_api-&gt;call_remove_on_all_entities(manager-&gt;ctx, tm_entity_api-&gt;lookup_component_type(manager-&gt;ctx, TM_TT_TYPE_HASH__STORY_COMPONENT));
    // Free the actual manager struct and the allocator used to allocate it.
    tm_entity_context_o *ctx = manager-&gt;ctx;
    tm_allocator_i allocator = manager-&gt;allocator;
    tm_free(&amp;allocator, manager, sizeof(tm_component_manager_o));
    tm_entity_api-&gt;destroy_child_allocator(ctx, &amp;allocator);
}
</code></pre>
<h4 id="custom-ui-1"><a class="header" href="#custom-ui-1">Custom UI</a></h4>
<p><strong>This part is optional!</strong>, see next part where we use the <a href="https://ourmachinery.com/apidoc/plugins/editor_views/properties.h.html#tm_tt_prop_aspect__properties__asset_picker">TM_TT_PROP_ASPECT__PROPERTIES__ASSET_PICKER</a>.</p>
<p>We also can to provide a custom UI for our reference to the asset! When we define our Truth type we tell the system that it should be a reference <strong>only</strong> of type <code>TM_TT_TYPE_HASH__TXT_ASSET</code>.</p>
<pre><code class="language-c">    tm_the_truth_property_definition_t story_component_properties[] = {
        [TM_TT_PROP__STORY_COMPONENT__ASSET] = { &quot;story_asset&quot;, .type = TM_THE_TRUTH_PROPERTY_TYPE_REFERENCE, .type_hash = TM_TT_TYPE_HASH__TXT_ASSET }
    };
</code></pre>
<p>This makes sure that in the Editor the user cannot store any other Truth type in this property. The Truth will check for it</p>
<p>We need to add the <a href="https://ourmachinery.com/apidoc/plugins/editor_views/properties.h.html#tm_tt_aspect__properties">TM_TT_ASPECT__PROPERTIES</a> aspect to our type to make sure it has a custom UI.</p>
<pre><code class="language-c">    static tm_properties_aspect_i properties_component_aspect = {
        .custom_ui = properties__component_custom_ui,
    };

    const tm_tt_type_t story_component_type = tm_the_truth_api-&gt;create_object_type(tt, TM_TT_TYPE__STORY_COMPONENT, story_component_properties, TM_ARRAY_COUNT(story_component_properties));
    tm_the_truth_api-&gt;set_aspect(tt, story_component_type, TM_TT_ASPECT__PROPERTIES, &amp;properties_component_aspect);
</code></pre>
<p>And than we need to define our custom UI:</p>
<pre><code class="language-c">static float properties__component_custom_ui(struct tm_properties_ui_args_t *args, tm_rect_t item_rect, tm_tt_id_t object, uint32_t indent)
{
    TM_INIT_TEMP_ALLOCATOR(ta);
    tm_tt_type_t asset_type = tm_the_truth_api-&gt;object_type_from_name_hash(args-&gt;tt, TM_TT_TYPE_HASH__ASSET);
    // get all instances of `TM_TT_TYPE_HASH__TXT_ASSET`
    tm_tt_id_t *ids = tm_the_truth_api-&gt;all_objects_of_type(args-&gt;tt, tm_the_truth_api-&gt;object_type_from_name_hash(args-&gt;tt, TM_TT_TYPE_HASH__TXT_ASSET), ta);
    tm_tt_id_t *items = 0;
    const char **names = 0;
    tm_carray_temp_push(names, &quot;Select&quot;, ta);
    tm_carray_temp_push(items, (tm_tt_id_t){ 0 }, ta);
    for (uint32_t i = 0; i &lt; tm_carray_size(ids); ++i) {
        // we make sure a Asset Type is the owner of the object! This is important since
        // the Asset Truth type has the name field! [TM_TT_PROP__ASSET__NAME](https://ourmachinery.com/apidoc/foundation/the_truth_assets.h.html#enumtm_tt_prop__asset)
        tm_tt_id_t owner = tm_the_truth_api-&gt;owner(args-&gt;tt, ids[i]);
        if (tm_tt_type(owner).u64 == asset_type.u64) {
            // if the owner is a asset we add it's name to our names array and use the id and add it to ower items!
            tm_carray_temp_push(names, tm_the_truth_api-&gt;get_string(args-&gt;tt, tm_tt_read(args-&gt;tt, owner), TM_TT_PROP__ASSET__NAME), ta);
            tm_carray_temp_push(items, ids[i], ta);
        }
    }
    // creates a popup picker and the user can choose what reference they want to put into the property!
    item_rect.y = tm_properties_view_api-&gt;ui_reference_popup_picker(args, item_rect, &quot;Asset&quot;, NULL, object, TM_TT_PROP__STORY_COMPONENT__ASSET, names, items, (uint32_t)tm_carray_size(items));
    TM_SHUTDOWN_TEMP_ALLOCATOR(ta); // always make sure you call the shutdown function on the temp allocator
    return item_rect.y;
}
</code></pre>
<p>In there we get all objects of type <code>TM_TT_TYPE_HASH__TXT_ASSET</code> we know that this type can only exist as a sub object of the Asset Truth Type.</p>
<blockquote>
<p>The type can only be created a part of the asset at this point!</p>
</blockquote>
<p>This information is important because we need a name for our asset and therefore we just iterate over all our TXT Assets and check if they are owned by a Truth Asset type. If yes we get the name from it and store it in a names array. At the end we add all the IDs of the objects in a array so the user can select them in the drop down menu of the <code>tm_properties_view_api.ui_reference_popup_picker()</code>.</p>
<h2 id="using-the-asset-picker-property-aspect"><a class="header" href="#using-the-asset-picker-property-aspect">Using the Asset Picker Property Aspect</a></h2>
<p>Instead of implementing our own UI, which can be full of boilerplate code we can also use the following aspect on our truth type: <a href="https://ourmachinery.com/apidoc/plugins/editor_views/properties.h.html#tm_tt_prop_aspect__properties__asset_picker">TM_TT_PROP_ASPECT__PROPERTIES__ASSET_PICKER</a> or if we want to store a entity an provide a entity from the scene: <a href="https://ourmachinery.com/apidoc/plugins/editor_views/properties.h.html#tm_tt_prop_aspect__properties__use_local_entity_picker">TM_TT_PROP_ASPECT__PROPERTIES__USE_LOCAL_ENTITY_PICKER</a>. The following code can be adjusted. In your <code>create_truth_types()</code> we need to add this aspect to our type property like this:</p>
<pre><code class="language-c">// -- create truth type
static void create_truth_types(struct tm_the_truth_o *tt)
{
// ..other code
    tm_the_truth_property_definition_t story_component_properties[] = {
        [TM_TT_PROP__STORY_COMPONENT__ASSET] = { &quot;story_asset&quot;, .type = TM_THE_TRUTH_PROPERTY_TYPE_REFERENCE, .type_hash = TM_TT_TYPE_HASH__TXT_ASSET }
    };
    static tm_properties_aspect_i properties_component_aspect = {
        .custom_ui = properties__component_custom_ui,
    };

    const tm_tt_type_t story_component_type = tm_the_truth_api-&gt;create_object_type(tt, TM_TT_TYPE__STORY_COMPONENT, story_component_properties, TM_ARRAY_COUNT(story_component_properties));
    tm_the_truth_api-&gt;set_aspect(tt, story_component_type, TM_CI_EDITOR_UI, editor_aspect);
    tm_the_truth_api-&gt;set_aspect(tt, story_component_type, TM_TT_ASPECT__PROPERTIES, &amp;properties_component_aspect);
    tm_the_truth_api-&gt;set_property_aspect(tt, story_component_type, TM_TT_PROP__STORY_COMPONENT__ASSET, TM_TT_PROP_ASPECT__PROPERTIES__ASSET_PICKER, TM_TT_TYPE_HASH__TXT_ASSET);
}
</code></pre>
<h2 id="drag-and-drop-a-text-asset-into-the-scene-and-create-an-entity"><a class="header" href="#drag-and-drop-a-text-asset-into-the-scene-and-create-an-entity">Drag and drop a Text Asset into the Scene and create an entity</a></h2>
<p>Finally, we can do what we came here to do: Make our Asset drag and droppable! We make use of the <a href="https://ourmachinery.com/apidoc/plugins/the_machinery_shared/asset_aspects.h.html#tm_tt_aspect__asset_scene">TM_TT_ASPECT__ASSET_SCENE</a>!</p>
<p>We define the aspect as described above:</p>
<pre><code class="language-c">#include &lt;plugins/the_machinery_shared/asset_aspects.h&gt;
//.. other code
tm_asset_scene_api scene_api = {
    .droppable = droppable,
    .create_entity = create_entity,
};
</code></pre>
<p>In the Create Truth Type function you need to add the aspect <a href="https://ourmachinery.com/apidoc/plugins/the_machinery_shared/asset_aspects.h.html#tm_tt_aspect__asset_scene">TM_TT_ASPECT__ASSET_SCENE</a>:</p>
<pre><code class="language-c">static void create_truth_types(struct tm_the_truth_o *tt)
{
    static tm_the_truth_property_definition_t my_asset_properties[] = {
        { &quot;import_path&quot;, TM_THE_TRUTH_PROPERTY_TYPE_STRING },
        { &quot;data&quot;, TM_THE_TRUTH_PROPERTY_TYPE_BUFFER },
    };
    const tm_tt_type_t type = tm_the_truth_api-&gt;create_object_type(tt, TM_TT_TYPE__MY_ASSET, my_asset_properties, TM_ARRAY_COUNT(my_asset_properties));
    tm_the_truth_api-&gt;set_aspect(tt, type, TM_TT_ASPECT__FILE_EXTENSION, &quot;txt&quot;);
    static tm_properties_aspect_i properties_aspect = {
        .custom_ui = properties__custom_ui,
    };
    tm_the_truth_api-&gt;set_aspect(tt, type, TM_TT_ASPECT__PROPERTIES, &amp;properties_aspect);
    tm_the_truth_api-&gt;set_aspect(tt, type, TM_TT_ASPECT__ASSET_SCENE, &amp;scene_api); // &lt;&lt;---

    // .. more code
}
</code></pre>
<p>Than, we provide a <code>droppable()</code> function:</p>
<pre><code class="language-c">bool droppable(struct tm_asset_scene_o *inst, struct tm_the_truth_o *tt, tm_tt_id_t asset)
{
    return true;
}
</code></pre>
<p>After this, the more important function comes:</p>
<pre><code class="language-c">#include &lt;plugins/entity/transform_component.h&gt;
#include &lt;plugins/the_machinery_shared/scene_common.h&gt;
// ... more code
tm_tt_id_t create_entity(struct tm_asset_scene_o *inst, struct tm_the_truth_o *tt,
    tm_tt_id_t asset, const char *name, const tm_transform_t *local_transform,
    tm_tt_id_t parent_entity, struct tm_undo_stack_i *undo_stack)
{
    const tm_tt_undo_scope_t undo_scope = tm_the_truth_api-&gt;create_undo_scope(tt, TM_LOCALIZE(&quot;Create Entity From Creation Graph&quot;));
    const tm_tt_type_t entity_type = tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__ENTITY);
    const tm_tt_id_t entity = tm_the_truth_api-&gt;create_object_of_type(tt, entity_type, undo_scope);
    tm_the_truth_object_o *entity_w = tm_the_truth_api-&gt;write(tt, entity);
    tm_the_truth_api-&gt;set_string(tt, entity_w, TM_TT_PROP__ENTITY__NAME, name);
    // add story:
    {
        tm_tt_type_t asset_type = tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__STORY_COMPONENT);
        const tm_tt_id_t component = tm_the_truth_api-&gt;create_object_of_type(tt, asset_type, undo_scope);
        tm_the_truth_object_o *component_w = tm_the_truth_api-&gt;write(tt, component);
        tm_the_truth_api-&gt;set_reference(tt, component_w, TM_TT_PROP__STORY_COMPONENT__ASSET, asset);
        tm_the_truth_api-&gt;add_to_subobject_set(tt, entity_w, TM_TT_PROP__ENTITY__COMPONENTS, &amp;component_w, 1);
        tm_the_truth_api-&gt;commit(tt, component_w, undo_scope);
    }
    // add transform:
    {
        const tm_tt_type_t transform_component_type = tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__TRANSFORM_COMPONENT);
        const tm_tt_id_t component = tm_the_truth_api-&gt;create_object_of_type(tt, transform_component_type, undo_scope);
        tm_the_truth_object_o *component_w = tm_the_truth_api-&gt;write(tt, component);
        tm_the_truth_api-&gt;add_to_subobject_set(tt, entity_w, TM_TT_PROP__ENTITY__COMPONENTS, &amp;component_w, 1);
        tm_the_truth_api-&gt;commit(tt, component_w, undo_scope);
    }

    tm_the_truth_api-&gt;commit(tt, entity_w, undo_scope);

    tm_scene_common_api-&gt;place_entity(tt, entity, local_transform, parent_entity, undo_scope);

    undo_stack-&gt;add(undo_stack-&gt;inst, tt, undo_scope);

    return entity;
}
// -- load plugin
TM_DLL_EXPORT void tm_load_plugin(struct tm_api_registry_api *reg, bool load)
{
// other code
     tm_scene_common_api = reg-&gt;get(TM_SCENE_COMMON_API_NAME);
    tm_entity_api = reg-&gt;get(TM_ENTITY_API_NAME);
// ... other code
    tm_add_or_remove_implementation(reg, load, TM_THE_TRUTH_CREATE_TYPES_INTERFACE_NAME, create_truth_types);
    tm_add_or_remove_implementation(reg, load, TM_ENTITY_CREATE_COMPONENT_INTERFACE_NAME, component__create);
}
</code></pre>
<p>First, we create an entity:</p>
<pre><code class="language-c">tm_tt_id_t create_entity(struct tm_asset_scene_o *inst, struct tm_the_truth_o *tt,
    tm_tt_id_t asset, const char *name, const tm_transform_t *local_transform,
    tm_tt_id_t parent_entity, struct tm_undo_stack_i *undo_stack)
{
    const tm_tt_undo_scope_t undo_scope = tm_the_truth_api-&gt;create_undo_scope(tt, TM_LOCALIZE(&quot;Create Entity From Creation Graph&quot;));
    const tm_tt_type_t entity_type = tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__ENTITY);
    const tm_tt_id_t entity = tm_the_truth_api-&gt;create_object_of_type(tt, entity_type, undo_scope);
    tm_the_truth_object_o *entity_w = tm_the_truth_api-&gt;write(tt, entity);
    tm_the_truth_api-&gt;set_string(tt, entity_w, TM_TT_PROP__ENTITY__NAME, name);
//...
}
</code></pre>
<p>Suppose it needs a transform. If not, we don't! In this case, we add the transform to the entity, just to make a point:</p>
<pre><code class="language-c">tm_tt_id_t create_entity(struct tm_asset_scene_o *inst, struct tm_the_truth_o *tt,
    tm_tt_id_t asset, const char *name, const tm_transform_t *local_transform,
    tm_tt_id_t parent_entity, struct tm_undo_stack_i *undo_stack)
{
    const tm_tt_undo_scope_t undo_scope = tm_the_truth_api-&gt;create_undo_scope(tt, TM_LOCALIZE(&quot;Create Entity From Creation Graph&quot;));
    const tm_tt_type_t entity_type = tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__ENTITY);
    const tm_tt_id_t entity = tm_the_truth_api-&gt;create_object_of_type(tt, entity_type, undo_scope);
    tm_the_truth_object_o *entity_w = tm_the_truth_api-&gt;write(tt, entity);
    tm_the_truth_api-&gt;set_string(tt, entity_w, TM_TT_PROP__ENTITY__NAME, name);
    // add transform:
    {
        const tm_tt_type_t transform_component_type = tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__TRANSFORM_COMPONENT);
        const tm_tt_id_t component = tm_the_truth_api-&gt;create_object_of_type(tt, transform_component_type, undo_scope);
        tm_the_truth_object_o *component_w = tm_the_truth_api-&gt;write(tt, component);
        tm_the_truth_api-&gt;add_to_subobject_set(tt, entity_w, TM_TT_PROP__ENTITY__COMPONENTS, &amp;component_w, 1);
        tm_the_truth_api-&gt;commit(tt, component_w, undo_scope);
    }
    // ...
}
</code></pre>
<p>Then, we add the story component to the entity we follow the same steps as before.</p>
<pre><code class="language-c">tm_tt_id_t create_entity(struct tm_asset_scene_o *inst, struct tm_the_truth_o *tt,
    tm_tt_id_t asset, const char *name, const tm_transform_t *local_transform,
    tm_tt_id_t parent_entity, struct tm_undo_stack_i *undo_stack)
{
    const tm_tt_undo_scope_t undo_scope = tm_the_truth_api-&gt;create_undo_scope(tt, TM_LOCALIZE(&quot;Create Entity From Creation Graph&quot;));
    const tm_tt_type_t entity_type = tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__ENTITY);
    const tm_tt_id_t entity = tm_the_truth_api-&gt;create_object_of_type(tt, entity_type, undo_scope);
    tm_the_truth_object_o *entity_w = tm_the_truth_api-&gt;write(tt, entity);
    tm_the_truth_api-&gt;set_string(tt, entity_w, TM_TT_PROP__ENTITY__NAME, name);
    // add transform:
    {
        const tm_tt_type_t transform_component_type = tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__TRANSFORM_COMPONENT);
        const tm_tt_id_t component = tm_the_truth_api-&gt;create_object_of_type(tt, transform_component_type, undo_scope);
        tm_the_truth_object_o *component_w = tm_the_truth_api-&gt;write(tt, component);
        tm_the_truth_api-&gt;add_to_subobject_set(tt, entity_w, TM_TT_PROP__ENTITY__COMPONENTS, &amp;component_w, 1);
        tm_the_truth_api-&gt;commit(tt, component_w, undo_scope);
    }
// add story:
    {
        tm_tt_type_t asset_type = tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__STORY_COMPONENT);
        const tm_tt_id_t component = tm_the_truth_api-&gt;create_object_of_type(tt, asset_type, undo_scope);
        tm_the_truth_object_o *component_w = tm_the_truth_api-&gt;write(tt, component);
        tm_the_truth_api-&gt;set_reference(tt, component_w, TM_TT_PROP__STORY_COMPONENT__ASSET, asset);
        tm_the_truth_api-&gt;add_to_subobject_set(tt, entity_w, TM_TT_PROP__ENTITY__COMPONENTS, &amp;component_w, 1);
        tm_the_truth_api-&gt;commit(tt, component_w, undo_scope);
    }
}
</code></pre>
<p>After all this, we can commit our changes to the Truth. After this we could place it in the scene with the <code>tm_scene_common_api.place_entity()</code>. This step is not needed but is nice to do!</p>
<p>Do not forget to add the undo scope to make sure we can undo our action and return the created entity!</p>
<pre><code class="language-c">tm_tt_id_t create_entity(struct tm_asset_scene_o *inst, struct tm_the_truth_o *tt,
    tm_tt_id_t asset, const char *name, const tm_transform_t *local_transform,
    tm_tt_id_t parent_entity, struct tm_undo_stack_i *undo_stack)
{
    const tm_tt_undo_scope_t undo_scope = tm_the_truth_api-&gt;create_undo_scope(tt, TM_LOCALIZE(&quot;Create Entity From Creation Graph&quot;));
    const tm_tt_type_t entity_type = tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__ENTITY);
    const tm_tt_id_t entity = tm_the_truth_api-&gt;create_object_of_type(tt, entity_type, undo_scope);
    tm_the_truth_object_o *entity_w = tm_the_truth_api-&gt;write(tt, entity);
    tm_the_truth_api-&gt;set_string(tt, entity_w, TM_TT_PROP__ENTITY__NAME, name);
    // add transform:
    {
        const tm_tt_type_t transform_component_type = tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__TRANSFORM_COMPONENT);
        const tm_tt_id_t component = tm_the_truth_api-&gt;create_object_of_type(tt, transform_component_type, undo_scope);
        tm_the_truth_object_o *component_w = tm_the_truth_api-&gt;write(tt, component);
        tm_the_truth_api-&gt;add_to_subobject_set(tt, entity_w, TM_TT_PROP__ENTITY__COMPONENTS, &amp;component_w, 1);
        tm_the_truth_api-&gt;commit(tt, component_w, undo_scope);
    }
// add story:
    {
        tm_tt_type_t asset_type = tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__STORY_COMPONENT);
        const tm_tt_id_t component = tm_the_truth_api-&gt;create_object_of_type(tt, asset_type, undo_scope);
        tm_the_truth_object_o *component_w = tm_the_truth_api-&gt;write(tt, component);
        tm_the_truth_api-&gt;set_reference(tt, component_w, TM_TT_PROP__STORY_COMPONENT__ASSET, asset);
        tm_the_truth_api-&gt;add_to_subobject_set(tt, entity_w, TM_TT_PROP__ENTITY__COMPONENTS, &amp;component_w, 1);
        tm_the_truth_api-&gt;commit(tt, component_w, undo_scope);
    }
tm_the_truth_api-&gt;commit(tt, entity_w, undo_scope);

    tm_scene_common_api-&gt;place_entity(tt, entity, local_transform, parent_entity, undo_scope);

    undo_stack-&gt;add(undo_stack-&gt;inst, tt, undo_scope);

    return entity;
    }
</code></pre>
<p>Now we have added the ability to add this to our asset!</p>
<blockquote>
<p><strong>Note:</strong> This is all not done at run time, since we are dealing with the Truth here and not with the ECS our changes will apply first to the ECS when we simulate the game!</p>
</blockquote>
<h2 id="modify-a-already-existing-asset"><a class="header" href="#modify-a-already-existing-asset">Modify a already existing asset</a></h2>
<p>It is important to understand that you can add this to any truth type even if you do not define them in your plugin. Lets assume you have created a new plugin which uses the txt file asset. You are not the owner of this plugin and its source code so you cannot modify it like we did above. What you can do on the other hand you can add the aspect to the truth type:</p>
<pre><code class="language-c">// -- load plugin
TM_DLL_EXPORT void tm_load_plugin(struct tm_api_registry_api *reg, bool load)
{
// other code
     tm_scene_common_api = reg-&gt;get(TM_SCENE_COMMON_API_NAME);
    tm_entity_api = reg-&gt;get(TM_ENTITY_API_NAME);
// ... other code
    tm_add_or_remove_implementation(reg, load, TM_THE_TRUTH_CREATE_TYPES_INTERFACE_NAME, create_truth_types);
}
</code></pre>
<p>and then in the <code>create_truth_types</code> function you can add the aspect to the truth type:</p>
<pre><code class="language-c">// -- create truth type
static void create_truth_types(struct tm_the_truth_o *tt)
{
    tm_tt_type_t asset_type = tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__TXT_ASSET);
    if(asset_type.u64){
        if(tm_the_truth_api-&gt;get_aspect(tt, asset_type, TM_TT_ASPECT__ASSET_SCENE))
	    	tm_the_truth_api-&gt;set_aspect(tt, asset_type, TM_TT_ASPECT__ASSET_SCENE, &amp;scene_api);
    }
}
</code></pre>
<p>In here we get the <code>asset_type</code> from the Truth. Important here is we need to make sure the type exists already! if not it makes no sense to add the aspect to it. More over we need to make sure that the asset has not already this aspect. Since a Object can have only one aspect at the same time!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="open-a-special-tab-for-an-asset"><a class="header" href="#open-a-special-tab-for-an-asset">Open a special tab for an Asset</a></h1>
<p>This walkthrough shows you how to enable an asset to open a specific tab. You should have basic knowledge about how to write a custom plugin. If not, you might want to check this <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/extending_the_machinery/the_plugin_system.html">Guide</a>. This walkthrough aims to enable you to double-click an asset and open it in a specific tab.</p>
<p>You will learn:</p>
<ul>
<li>Create a basic tab</li>
<li>Open an asset</li>
<li>How to use a temporary temporray allocator</li>
</ul>
<p>This walkthrough will refer to the text asset example as the asset we want to extend! If you have not followed it, here is the link: <a href="https://ourmachinery.github.io/themachinery-books/tutorials//the_truth/custom_asset/index.html">Custom Asset</a>.</p>
<p><strong>Table of Content</strong></p>
<ul>
<li><a href="the_truth/open_asset.html#new-tab">New Tab</a>
<ul>
<li><a href="the_truth/open_asset.html#implementing-the-functions">Implementing the functions</a>
<ul>
<li><a href="the_truth/open_asset.html#the-create-function">The Create Function</a></li>
<li><a href="the_truth/open_asset.html#the-update-function">The Update Function</a></li>
<li><a href="the_truth/open_asset.html#the-set-root--root-function">The set root / root function</a></li>
</ul>
</li>
<li><a href="the_truth/open_asset.html#let-us-test-the-tab">Let us test the Tab</a></li>
<li><a href="the_truth/open_asset.html#source-code">Source Code</a></li>
</ul>
</li>
<li><a href="the_truth/open_asset.html#open-the-tab">Open the Tab</a></li>
</ul>
<h2 id="new-tab"><a class="header" href="#new-tab">New Tab</a></h2>
<p>The first cause of action is to create the Tab we want to open. </p>
<blockquote>
<p><strong>Note:</strong> We can use the basic tab Template from the Engine: <strong>File -&gt; New Plugin -&gt; New Tab.</strong> </p>
</blockquote>
<p>In this walkthrough, we aim to have a simple tab that shows the content of our text file.</p>
<p>The Steps of creating a tab are similar to the ones of a standard plugin:</p>
<ol>
<li>We create a new file. For example: <code>txt_tab.c</code></li>
<li>We need to include some files for a tab plugin:</li>
</ol>
<pre><code class="language-c">static struct tm_api_registry_api *tm_global_api_registry;

static struct tm_ui_api *tm_ui_api;
static struct tm_temp_allocator_api *tm_temp_allocator_api;

extern struct tm_the_truth_api *tm_the_truth_api;
static struct tm_localizer_api *tm_localizer_api;

#include &lt;foundation/allocator.h&gt;
#include &lt;foundation/api_registry.h&gt;
#include &lt;foundation/string.inl&gt;
#include &lt;foundation/temp_allocator.h&gt;
#include &lt;foundation/the_truth.h&gt;

#include &lt;plugins/ui/docking.h&gt;
#include &lt;plugins/ui/ui.h&gt;

#include &lt;the_machinery/the_machinery_tab.h&gt;

#include &quot;txt.h&quot;
</code></pre>
<blockquote>
<p><strong>Note:</strong> With extern we can use the truth api from the <code>txt.c</code> file so we do not need to get it from the registry!</p>
</blockquote>
<ul>
<li>The docking header file provides us the default tab type</li>
<li>The UI header gives us access to the UI API</li>
<li>The txt header gives us access to our custom types</li>
</ul>
<ol>
<li>We create a new load function on the bottom of the file:</li>
</ol>
<pre><code class="language-c">void load_txt_tab(struct tm_api_registry_api *reg, bool load)
{
    tm_global_api_registry = reg;

    tm_ui_api = reg-&gt;get(TM_UI_API_NAME);
    tm_temp_allocator_api = reg-&gt;get(TM_TEMP_ALLOCATOR_API_NAME);
}
</code></pre>
<p>In our main file the <code>txt.c</code> we need to add this function and call it:</p>
<pre><code class="language-c">extern void load_txt_tab(struct tm_api_registry_api* reg, bool load);

// -- load plugin
TM_DLL_EXPORT void tm_load_plugin(struct tm_api_registry_api *reg, bool load)
{
    // more code
    load_txt_tab(reg,load);
}
</code></pre>
<ol start="2">
<li>Above this function we initialize a object of the type <a href="https://ourmachinery.com/apidoc/the_machinery/the_machinery_tab.h.html#structtm_the_machinery_tab_vt">tm_the_machinery_tab_vt</a></li>
</ol>
<pre><code class="language-c">static tm_the_machinery_tab_vt *tab_vt = &amp;(tm_the_machinery_tab_vt){
// ...
};

void load_txt_tab(struct tm_api_registry_api *reg, bool load){
    //...
}
</code></pre>
<ol start="3">
<li>We add to the <code>txt.h</code> the name of our Tab as well as its hash</li>
</ol>
<pre><code class="language-c">#define TM_TXT_TAB_VT_NAME &quot;tm_txt_tab&quot;
#define TM_TXT_TAB_VT_NAME_HASH TM_STATIC_HASH(&quot;tm_txt_tab&quot;, 0x2cd261be98a99bc3ULL)
</code></pre>
<ol start="4">
<li>To this Virtual Table, we add the name and its hash as well as the following functions:</li>
</ol>
<pre><code class="language-c">static const char *tab__create_menu_name(void)
{
    return &quot;Text Tab&quot;;
}

static const char *tab__title(tm_tab_o *tab, struct tm_ui_o *ui)
{
    return &quot;Text Tab&quot;;
}

static tm_the_machinery_tab_vt *tab_vt = &amp;(tm_the_machinery_tab_vt){
    .name = TM_TXT_TAB_VT_NAME,
    .name_hash = TM_TXT_TAB_VT_NAME_HASH,
    .create_menu_name = tab__create_menu_name,
    .create = tab__create,
    .destroy = tab__destroy,
    .title = tab__title,
    .ui = tab__ui,
    .set_root = tab__set_root,
    .root = tab__root,
};
</code></pre>
<ol start="5">
<li>On top of our file, we define the opaque type: <a href="https://ourmachinery.com/apidoc/plugins/ui/docking.h.html#tm_tab_o">tm_tab_o</a> and provide some fields to it:</li>
</ol>
<pre><code class="language-c">struct tm_tab_o
{
    tm_tab_i tm_tab_i;
    tm_allocator_i *allocator;

    tm_tt_id_t asset;
    tm_the_truth_o *tt;
};
</code></pre>
<p>The most important fields here are the <strong>asset</strong> and <strong>tt</strong> filed. They will store the currently used asset and truth. Those fields allow us to access both in various functions.</p>
<h3 id="implementing-the-functions"><a class="header" href="#implementing-the-functions">Implementing the functions</a></h3>
<p>Now that we have done all the boilerplate code, let us focus on the three functions that count:</p>
<ul>
<li>The create function</li>
<li>The UI Update</li>
<li>The Set Root function</li>
</ul>
<h4 id="the-create-function"><a class="header" href="#the-create-function">The Create Function</a></h4>
<pre><code class="language-c">static tm_tab_i *tab__create(tm_tab_create_context_t *context, tm_ui_o *ui)
{
    tm_allocator_i *allocator = context-&gt;allocator;
    uint64_t *id = context-&gt;id;

    static tm_the_machinery_tab_vt *vt = 0;
    if (!vt)
        vt = tm_global_api_registry-&gt;get(TM_TXT_TAB_VT_NAME);

    tm_tab_o *tab = tm_alloc(allocator, sizeof(tm_tab_o));
    *tab = (tm_tab_o){
        .tm_tab_i = {
            .vt = (tm_tab_vt *)vt,
            .inst = (tm_tab_o *)tab,
            .root_id = *id,
        },
        .allocator = allocator,
    };

    *id += 1000000;
    return &amp;tab-&gt;tm_tab_i;
}
</code></pre>
<p>In this function, we store the allocator first. </p>
<blockquote>
<p><strong>Tipp:</strong> if you wanted to create a child allocator, you could do this for your Tab. A child allocator may be very useful when doing many allocations: <code>tm_allocator_api.create_child()</code>.</p>
</blockquote>
<p>As the next step, we initialize the virtual table of or Tab, but only if the static variable was not initialized. </p>
<pre><code class="language-c">    static tm_the_machinery_tab_vt *vt = 0;
    if (!vt)
        vt = tm_global_api_registry-&gt;get(TM_TXT_TAB_VT_NAME);
</code></pre>
<p>We need to initialize the tab interface so other engine parts can communicate with a generic interface to the Tab. We store a pointer to our Tab within this interface so other callers of the standard generic interface can access this instance and pass it along to the functions. After this, we allocate the Tab itself.</p>
<pre><code class="language-c">    tm_tab_o *tab = tm_alloc(allocator, sizeof(tm_tab_o));
    *tab = (tm_tab_o){
        .tm_tab_i = {
            .vt = (tm_tab_vt *)vt,
            .inst = (tm_tab_o *)tab,
            .root_id = *id,
        },
        .allocator = allocator,
    };
</code></pre>
<p>In the end, we return the pointer to the interface, so the docking system has it</p>
<h4 id="the-update-function"><a class="header" href="#the-update-function">The Update Function</a></h4>
<pre><code class="language-c">static void tab__ui(tm_tab_o *tab, tm_ui_o *ui, const tm_ui_style_t *uistyle_in, tm_rect_t rect)
{
    tm_ui_style_t *uistyle = (tm_ui_style_t[]){ *uistyle_in };
    if (tab-&gt;asset.u64) {
        TM_INIT_TEMP_ALLOCATOR(ta);
        tm_tt_buffer_t buffer = tm_the_truth_api-&gt;get_buffer(tab-&gt;tt, tm_tt_read(tab-&gt;tt, tab-&gt;asset), TM_TT_PROP__MY_ASSET__DATA);
        char *content = tm_temp_alloc(ta, buffer.size + 1);
        tm_strncpy_safe(content, buffer.data, buffer.size);

        tm_ui_text_t *text = &amp;(tm_ui_text_t){ .text = content, .rect = rect };
        tm_ui_api-&gt;wrapped_text(ui, uistyle, text);
        TM_SHUTDOWN_TEMP_ALLOCATOR(ta);
    } else {
        rect.h = 20;
        tm_ui_text_t *text = &amp;(tm_ui_text_t){ .align = TM_UI_ALIGN_CENTER, .text = &quot;Please open a .txt asset.&quot;, .rect = rect };
        tm_ui_api-&gt;text(ui, uistyle, text);
    }
}
</code></pre>
<p>At first, we create a copy of the UI Style. With this copy, we can do what we want since the input style is a const pointer. After this, we check if the asset is present. If not, we print a message on the Tab that the user must select a <code>txt</code> asset.</p>
<pre><code class="language-c">static void tab__ui(tm_tab_o *tab, tm_ui_o *ui, const tm_ui_style_t *uistyle_in, tm_rect_t rect)
{  
tm_ui_style_t *uistyle = (tm_ui_style_t[]){ *uistyle_in };
    if (tab-&gt;asset.u64) {
        //...
    } else {
        rect.h = 20;
        tm_ui_text_t *text = &amp;(tm_ui_text_t){ .align = TM_UI_ALIGN_CENTER, .text = &quot;Please open a .txt asset.&quot;, .rect = rect };
        tm_ui_api-&gt;text(ui, uistyle, text);
    }
}
</code></pre>
<p>We need an allocator to copy the data of the buffer into a proper string. The allocator is needed since we never added a null terminator to the end of the string when we save it into the buffer.</p>
<p>In this case, we need a temporary allocator. Since we do not want to keep the memory forever, we need to initialize a temp allocator with <a href="https://ourmachinery.com/apidoc/foundation/temp_allocator.h.html#tm_init_temp_allocator()">TM_INIT_TEMP_ALLOCATOR</a> and provide a name. Do not forget to free the memory at the end. </p>
<pre><code class="language-c">static void tab__ui(tm_tab_o *tab, tm_ui_o *ui, const tm_ui_style_t *uistyle_in, tm_rect_t rect)
{
    tm_ui_style_t *uistyle = (tm_ui_style_t[]){ *uistyle_in };
    if (tab-&gt;asset.u64) {
        TM_INIT_TEMP_ALLOCATOR(ta);
            //..
        TM_SHUTDOWN_TEMP_ALLOCATOR(ta);
    } else {
        rect.h = 20;
        tm_ui_text_t *text = &amp;(tm_ui_text_t){ .align = TM_UI_ALIGN_CENTER, .text = &quot;Please open a .txt asset.&quot;, .rect = rect };
        tm_ui_api-&gt;text(ui, uistyle, text);
    }
}
</code></pre>
<blockquote>
<p><strong>Note:</strong> If the memory is smaller than 1024 bytes, the memory is allocated to the stack. Moreover, an alternative is the frame allocator in which the memory is freed every frame.</p>
</blockquote>
<p>The next step is it to ask the truth for the buffer and allocate the right amount of memory. Since we want to copy the data into a null-terminated string, we should add 1 to the data size.</p>
<pre><code class="language-c"> tm_tt_buffer_t buffer = tm_the_truth_api-&gt;get_buffer(tab-&gt;tt, tm_tt_read(tab-&gt;tt, tab-&gt;asset), TM_TT_PROP__MY_ASSET__DATA);
char *content = tm_temp_alloc(ta, buffer.size + 1);
</code></pre>
<p>To ensure our string is clean and filled with nulls, we use the inline string file (hence we add the <code>foundation/string.inl</code> to our includes). We have the <a href="https://ourmachinery.com/apidoc/foundation/string.inl.html#tm_strncpy_safe()">tm_strncpy_safe</a> within this header file, which fills up a string with null terminator.</p>
<pre><code class="language-c">tm_strncpy_safe(content, buffer.data, buffer.size);
</code></pre>
<p>The last step before we are done is actually to make the text appear on the screen. We make use of the <code>tm_ui_api.wrapped_text()</code> since this function will print the string in multiple lines if need be.</p>
<pre><code class="language-c">tm_ui_text_t *text = &amp;(tm_ui_text_t){ .text = content, .rect = rect };
tm_ui_api-&gt;wrapped_text(ui, uistyle, text);
</code></pre>
<h4 id="the-set-root--root-function"><a class="header" href="#the-set-root--root-function">The set root / root function</a></h4>
<p>The last function which we need is the set root function. This function allows us to set a root object of the Tab from the outside. Its code is quite straightforward:</p>
<pre><code class="language-c">void tab__set_root(tm_tab_o *inst, struct tm_the_truth_o *tt, tm_tt_id_t root)
{
    inst-&gt;asset = root;
    inst-&gt;tt = tt;
}

static tm_tab_vt_root_t tab__root(tm_tab_o *tab)
{
    return (tm_tab_vt_root_t){ tab-&gt;tt, tab-&gt;asset };
}
</code></pre>
<h3 id="let-us-test-the-tab"><a class="header" href="#let-us-test-the-tab">Let us test the Tab</a></h3>
<p>Let us open the Tab from the <strong>Tabs</strong> menu!</p>
<p>[image]</p>
<h3 id="source-code"><a class="header" href="#source-code">Source Code</a></h3>
<pre><code class="language-c">static struct tm_api_registry_api *tm_global_api_registry;

static struct tm_ui_api *tm_ui_api;
static struct tm_temp_allocator_api *tm_temp_allocator_api;

extern struct tm_the_truth_api *tm_the_truth_api;
static struct tm_localizer_api *tm_localizer_api;

#include &lt;foundation/allocator.h&gt;
#include &lt;foundation/api_registry.h&gt;
#include &lt;foundation/string.inl&gt;
#include &lt;foundation/temp_allocator.h&gt;
#include &lt;foundation/the_truth.h&gt;

#include &lt;plugins/ui/docking.h&gt;
#include &lt;plugins/ui/ui.h&gt;

#include &lt;the_machinery/the_machinery_tab.h&gt;


#include &quot;txt.h&quot;

struct tm_tab_o
{
    tm_tab_i tm_tab_i;
    tm_allocator_i *allocator;

    tm_tt_id_t asset;
    tm_the_truth_o *tt;
};

static void tab__ui(tm_tab_o *tab, tm_ui_o *ui, const tm_ui_style_t *uistyle_in, tm_rect_t rect)
{
    tm_ui_style_t *uistyle = (tm_ui_style_t[]){ *uistyle_in };
    if (tab-&gt;asset.u64) {
        TM_INIT_TEMP_ALLOCATOR(ta);
        tm_tt_buffer_t buffer = tm_the_truth_api-&gt;get_buffer(tab-&gt;tt, tm_tt_read(tab-&gt;tt, tab-&gt;asset), TM_TT_PROP__MY_ASSET__DATA);
        char *content = tm_temp_alloc(ta, buffer.size + 1);
        tm_strncpy_safe(content, buffer.data, buffer.size);

        tm_ui_text_t *text = &amp;(tm_ui_text_t){ .text = content, .rect = rect };
        tm_ui_api-&gt;wrapped_text(ui, uistyle, text);
        TM_SHUTDOWN_TEMP_ALLOCATOR(ta);
    } else {
        rect.h = 20;
        tm_ui_text_t *text = &amp;(tm_ui_text_t){ .align = TM_UI_ALIGN_CENTER, .text = &quot;Please open a .txt asset.&quot;, .rect = rect };
        tm_ui_api-&gt;text(ui, uistyle, text);
    }
}

static const char *tab__create_menu_name(void)
{
    return &quot;Text Tab&quot;;
}

static const char *tab__title(tm_tab_o *tab, struct tm_ui_o *ui)
{
    return &quot;Text Tab&quot;;
}

static tm_tab_i *tab__create(tm_tab_create_context_t *context, tm_ui_o *ui)
{
    tm_allocator_i *allocator = context-&gt;allocator;
    uint64_t *id = context-&gt;id;

    static tm_the_machinery_tab_vt *vt = 0;
    if (!vt)
        vt = tm_global_api_registry-&gt;get(TM_TXT_TAB_VT_NAME);

    tm_tab_o *tab = tm_alloc(allocator, sizeof(tm_tab_o));
    *tab = (tm_tab_o){
        .tm_tab_i = {
            .vt = (tm_tab_vt *)vt,
            .inst = (tm_tab_o *)tab,
            .root_id = *id,
        },
        .allocator = allocator,
    };

    *id += 1000000;
    return &amp;tab-&gt;tm_tab_i;
}

static void tab__destroy(tm_tab_o *tab)
{
    tm_free(tab-&gt;allocator, tab, sizeof(*tab));
}

void tab__set_root(tm_tab_o *inst, struct tm_the_truth_o *tt, tm_tt_id_t root)
{
    inst-&gt;asset = root;
    inst-&gt;tt = tt;
}

static tm_tab_vt_root_t tab__root(tm_tab_o *tab)
{
    return (tm_tab_vt_root_t){ tab-&gt;tt, tab-&gt;asset };
}

static tm_the_machinery_tab_vt *tab_vt = &amp;(tm_the_machinery_tab_vt){
    .name = TM_TXT_TAB_VT_NAME,
    .name_hash = TM_TXT_TAB_VT_NAME_HASH,
    .create_menu_name = tab__create_menu_name,
    .create = tab__create,
    .destroy = tab__destroy,
    .title = tab__title,
    .ui = tab__ui,
    .set_root = tab__set_root,
    .root = tab__root,
};

void load_txt_tab(struct tm_api_registry_api *reg, bool load)
{
    tm_global_api_registry = reg;

    tm_ui_api = reg-&gt;get(TM_UI_API_NAME);
    tm_temp_allocator_api = reg-&gt;get(TM_TEMP_ALLOCATOR_API_NAME);

    tm_set_or_remove_api(reg, load, TM_TXT_TAB_VT_NAME, tab_vt);
    tm_add_or_remove_implementation(reg, load, TM_TAB_VT_INTERFACE_NAME, tab_vt);
}

</code></pre>
<h2 id="open-the-tab"><a class="header" href="#open-the-tab">Open the Tab</a></h2>
<p>After all the previous steps, we can finally make our Text Asset open this Tab!</p>
<p>At first, we need to remove the static of our truth API since we require it in the <code>txt_tab.c</code>.</p>
<pre><code class="language-c">struct tm_the_truth_api *tm_the_truth_api;
</code></pre>
<p>When that is done, we need to include two more files and get two  more APIs.</p>
<pre><code class="language-c">// open asset
static struct tm_the_machinery_api* tm_the_machinery_api;
static struct tm_docking_api* tm_docking_api;
//...

#include &lt;plugins/ui/docking.h&gt;
#include &lt;the_machinery/the_machinery_tab.h&gt;
#include &lt;the_machinery/the_machinery.h&gt;
//...
extern void load_txt_tab(struct tm_api_registry_api* reg, bool load);

TM_DLL_EXPORT void tm_load_plugin(struct tm_api_registry_api *reg, bool load)
{
    //...
    // loads the txt tab!
    tm_the_machinery_api = reg-&gt;get(TM_THE_MACHINERY_API_NAME);
    tm_docking_api = reg-&gt;get(TM_DOCKING_API_NAME);
    load_txt_tab(reg,load);
      //...
}
</code></pre>
<p>To open an asset, we need to add another aspect to our type. It is the <a href="https://ourmachinery.com/apidoc/plugins/the_machinery_shared/asset_aspects.h.html#tm_tt_aspect__asset_open">TM_TT_ASPECT__ASSET_OPEN</a> aspect! This aspect requires a implementation of the <a href="https://ourmachinery.com/apidoc/plugins/the_machinery_shared/asset_aspects.h.html#structtm_asset_open_aspect_i">tm_asset_open_aspect_i</a>. </p>
<pre><code class="language-c">static void create_truth_types(struct tm_the_truth_o *tt)
{
    //...
    tm_the_truth_api-&gt;set_aspect(tt,type,TM_TT_ASPECT__ASSET_OPEN,open_i);
    //...
}
</code></pre>
<p>We add this implementation of the <a href="https://ourmachinery.com/apidoc/plugins/the_machinery_shared/asset_aspects.h.html#structtm_asset_open_aspect_i">tm_asset_open_aspect_i</a> above the <code>create_truth_types</code> function.</p>
<pre><code class="language-c">void open_asset(struct tm_application_o *app, struct tm_ui_o *ui, struct tm_tab_i *from_tab,
        tm_the_truth_o *tt, tm_tt_id_t asset, enum tm_asset_open_mode open_mode){
    
    const tm_docking_find_tab_opt_t opt = {
        .from_tab = from_tab,
        .in_ui = ui,
        .exclude_pinned = true,
    };

    const bool pin = open_mode == TM_ASSET_OPEN_MODE_CREATE_TAB_AND_PIN;
    tm_tab_i *tab = tm_the_machinery_api-&gt;create_or_select_tab(app,ui,TM_TXT_TAB_VT_NAME,&amp;opt);

    if (pin)
        tm_docking_api-&gt;pin_object(tab, tt, asset);
    else
        tab-&gt;vt-&gt;set_root(tab-&gt;inst, tt, asset);   
    
}

static tm_asset_open_aspect_i* open_i = &amp;(tm_asset_open_aspect_i){
    .open = open_asset,
};

static void create_truth_types(struct tm_the_truth_o *tt)
{
    //...
}
</code></pre>
<p>The open function gives us all the important information:</p>
<ol>
<li>The App data</li>
<li>The UI</li>
<li>Which Tab requested this action</li>
<li>The current Truth</li>
<li>the asset</li>
<li>How we will open the Tab.</li>
</ol>
<p>At first, we define the search criteria for the <code>create_or_select_tab</code> of the Machinery API. In this case we want to exclude pinned tabs since the user might have a reason for why they are pinned!</p>
<pre><code class="language-c">    const tm_docking_find_tab_opt_t opt = {
        .from_tab = from_tab,
        .in_ui = ui,
        .exclude_pinned = true,
    };
</code></pre>
<p>Now we can create or select a tab by calling the <code>create_or_select_tab</code> function.</p>
<pre><code class="language-c">tm_tab_i *tab = tm_the_machinery_api-&gt;create_or_select_tab(app,ui,TM_TXT_TAB_VT_NAME,&amp;opt);
</code></pre>
<p>The last step is actually to pass some data along! In this case, we need to check if something is pinned or not! Hence we check if the <code>open_mode</code> is equal to pinning. If yes, we ask the docking API to pin our Tab.</p>
<pre><code class="language-c">    const bool pin = open_mode == TM_ASSET_OPEN_MODE_CREATE_TAB_AND_PIN;
    if (pin)
        tm_docking_api-&gt;pin_object(tab, tt, asset);
    else
        tab-&gt;vt-&gt;set_root(tab-&gt;inst, tt, asset);   
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ui"><a class="header" href="#ui">UI</a></h1>
<p>The Machinery's <a href="https://ourmachinery.com/apidoc/plugins/ui">UI system</a>, is a Immediate Mode GUI (IMGUI). Besides the information you can find here or in our API Documentation there are several Blog Posts you should check out:</p>
<ul>
<li><a href="https://ourmachinery.com/post/one-draw-call-ui/">One Draw Call UI</a></li>
<li><a href="https://ourmachinery.com/post/ui-rendering-using-primitive-buffers/">UI rendering using Primitive Buffers</a></li>
<li><a href="https://ourmachinery.com/post/implementing-drag-and-drop-in-an-imgui/">Implementing drag-and-drop in an IMGUI</a></li>
<li><a href="https://ourmachinery.com/post/localization-in-the-machinerys-ui/">Localization in The Machinery’s UI</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-custom-ui-controls"><a class="header" href="#build-custom-ui-controls">Build Custom UI Controls</a></h1>
<p>These walkthroughs we will teach you how to extend The Machinery's <a href="https://ourmachinery.com/apidoc/plugins/ui">UI system</a>.</p>
<p>In following following parts 1 - 3 we will cover the following topics:</p>
<ul>
<li><a href="https://ourmachinery.github.io/themachinery-books/tutorials//ui/build_custom_ui_controls/part1.html">Create a custom circular button</a></li>
<li><a href="ui/build_custom_ui_controls/index.html#">Add a texture to our custom control</a></li>
<li><a href="ui/build_custom_ui_controls/index.html#">Setup a UI Renderer</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-custom-ui-controls-part-i"><a class="header" href="#build-custom-ui-controls-part-i">Build Custom UI Controls, Part I</a></h1>
<p>Hi, we are starting a 3-part tutorial series about The Machinery UI system. In Part I, we’ll talk about the basics and create a custom circular button. In Part II, we’ll create a custom button with textures support. To show the results of the first two parts, we’ll be using a simple custom tab, so in Part III, we’ll see how to set up your UI and render it on screen.</p>
<p>During this tutorial, you’ll implement the <code>tm_ui_custom_controls</code> plugin, which will contain the <code>tm_ui_custom_controls_api</code> for draw custom controls in UI and <code>tm_ui_custom_controls_tab</code> custom tab in order to visualize results in a separate tab.</p>
<p><strong>Table of Content</strong></p>
<ul>
<li><a href="ui/build_custom_ui_controls/part1.html#environment-setup">Environment setup</a></li>
<li><a href="ui/build_custom_ui_controls/part1.html#circular-custom-button">Circular Custom Button:</a></li>
<li><a href="ui/build_custom_ui_controls/part1.html#drawing-text">Drawing text</a></li>
</ul>
<h2 id="environment-setup"><a class="header" href="#environment-setup">Environment setup</a></h2>
<p>During this tutorial, you’ll build the <code>tm_ui_custom_controls</code> plugin, which will contain the <code>tm_ui_custom_controls_api</code> for draw custom controls and <code>tm_ui_custom_controls_tab</code> custom tab in order to visualize results in a separate tab.</p>
<blockquote>
<p>The source code is hosted on <a href="https://github.com/raphael-ourmachinery/tm-custom-control-tutorial">https://github.com/raphael-ourmachinery/tm-custom-control-tutorial</a>, copy the contents of <code>skel/</code> folder to a separate directory, the final result will be available in <code>part1/</code> folder. </p>
</blockquote>
<p>Below is a list of files of our project:</p>
<ul>
<li><code>skel/libs.json</code>: specify premake5 binaries that will be downloaded from The Machinery server;</li>
<li><code>skel/(premake5.lua/build.bat/build.sh)</code>: build scripts that use <code>tmbuild.exe</code> to build our shared library. Note that we are targeting <code>TM_SDK_DIR/bin/plugins</code>, so our plugin will be automatically loaded by the engine. You’ll need to set the <code>TM_SDK_DIR</code> environment variable pointing to The Machinery directory. </li>
<li><code>skel/src/custom_tab.(c/h)</code>: this is a minimal version of the custom tab sample, which makes it easier to see our custom button;</li>
<li><code>skel/src/ui_custom_controls_loader.(c/h)</code>: load the necessary APIs, it contains the definition of <code>tm_load_plugin()</code> needed our plugin be loaded by the plugins system;</li>
<li><code>skel/src/ui_custom_controls.(c/h)</code>: implementation of our circular button, later you can extend the API with your custom controls too.</li>
</ul>
<h2 id="circular-custom-button"><a class="header" href="#circular-custom-button">Circular Custom Button:</a></h2>
<p>The Machinery uses an immediate-mode UI. You can read more about it on <a href="https://ourmachinery.com/post/one-draw-call-ui/">One Draw Call UI</a> blog post. To draw 2D shapes, we’ll be using the <a href="https://ourmachinery.com/apidoc/plugins/ui/draw2d.h.html#structtm_draw2d_api"><code>tm_draw2d_api</code></a> implemented in <a href="https://ourmachinery.com/apidoc/plugins/ui/draw2d.h.html"><code>draw2d.h</code></a>, which supplies functions to draw basic 2D shapes. As we are implementing a circular button, we’ll we need to draw a circle using the following function:</p>
<pre><code>tm_draw2d_api→fill_circle(tm_draw2d_vbuffer_t *vbuffer, tm_draw2d_ibuffer_t *ibuffer, const tm_draw2d_style_t *style, tm_vec2_t pos, float radius)
</code></pre>
<p>You can note this function takes a vertex and an index buffer as arguments. In the following tutorials, we’ll learn more about it, but for now, you only need to know is that <a href="https://ourmachinery.com/apidoc/plugins/ui/draw2d.h.html#structtm_draw2d_api"><code>tm_draw2d_api</code></a> will fill them, and we need to call <a href="https://ourmachinery.com/apidoc/plugins/ui/ui.h.html#structtm_ui_api.buffers()"><code>tm_ui_api-&gt;buffers()</code></a> to get the buffers. Later the engine will use <a href="https://ourmachinery.com/apidoc/plugins/ui/ui_renderer.h.html#structtm_ui_renderer_api">tm_ui_renderer_api</a> to draw the UI using one draw call.</p>
<p>Let’s add some more information <code>tm_ui_circular_button_t</code> and use it on <code>circular_button()</code>:</p>
<ul>
<li>ui_custom_controls.h:</li>
</ul>
<pre><code class="language-C">    ...
    
    typedef struct tm_ui_circular_button_t
    {
        uint64_t id;
    
        tm_vec2_t center;
        float radius;
        tm_color_srgb_t background_color;
    } tm_ui_circular_button_t;
    
    ...
</code></pre>
<ul>
<li>ui_custom_controls.c:</li>
</ul>
<pre><code class="language-C">    ...
    
    bool circular_button(struct tm_ui_o *ui, const struct tm_ui_style_t *uistyle, const tm_ui_circular_button_t *c)
    {
        // tm_ui_buffer_t contains information needed when creating a custom control
        tm_ui_buffers_t uib = tm_ui_api-&gt;buffers(ui);
    
        // convert tm_ui_style_t to tm_draw2d_style_t
        tm_draw2d_style_t style;
        tm_ui_api-&gt;to_draw_style(ui, &amp;style, uistyle);
        style.color = c-&gt;background_color;
    
        tm_draw2d_api-&gt;fill_circle(uib.vbuffer, uib.ibuffers[uistyle-&gt;buffer], &amp;style, c-&gt;center, c-&gt;radius);
    
        return false;
    }
    
    ...
</code></pre>
<p>For control interaction logic, we'll need interfaces from <a href="https://ourmachinery.com/apidoc/plugins/ui/ui_custom.h.html#ui_custom.h">ui_custom.h</a>, actually all editor's UI is implemented using them.  <a href="https://ourmachinery.com/apidoc/plugins/ui/ui.h.html#structtm_ui_buffers_t">tm_ui_buffers_t</a> that we got earlier has two important members, <a href="https://ourmachinery.com/apidoc/plugins/ui/ui_custom.h.html#structtm_ui_activation_t">tm_ui_activation_t</a> one keeps the information about activation and hovering state of UI controls, and <a href="https://ourmachinery.com/apidoc/plugins/ui/ui_custom.h.html#structtm_ui_input_state_t">tm_ui_input_state_t</a> maintains the input state. The table below lists some important concepts of our UI system. You can read it at once, or skip for now and return when necessary:</p>
<table><thead><tr><th><strong>Concept</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>ID</td><td>Each control in the UI has a unique 64-bit identifier. Since controls are not explicitly created and destroyed, the ID is the only thing that identifies a control from one frame to the next.<br><br>You create a new ID by calling <a href="https://ourmachinery.com/apidoc/plugins/ui/ui.h.html#structtm_ui_api.make_id()"><code>tm_ui_api-&gt;make_id()</code></a>. IDs are assigned sequentially by the UI. You have to be a bit careful with this if you have controls that sometimes are visible and sometimes not, such as <em>context menus</em>. If you only generate the ID for the context menu when it is visible, it will change the numbering of the subsequent controls depending on whether the menu is visible or not. Since controls are identified by their IDs, this can lead to controls being misidentified.<br><br>A good strategy is to generate the IDs for all the controls that you <em>might</em> show upfront, so that the ID assignment is stable.<br><br>Note: We may change this in the future if we can find a more stable way of assigning IDs.</td></tr>
<tr><td>Hover</td><td>The UI system keeps track of which control the mouse pointer is <em>hovering</em> over, by storing its ID in a <em>hover</em> variable.<br><br>You never set the <em>hover</em> variable directly. Instead, in your control’s update, you check if the mouse is over your control with <a href="https://ourmachinery.com/apidoc/plugins/ui/ui.h.html#structtm_ui_api.is_hovering()"><code>tm_ui_api-&gt;is_hovering()</code></a>, and if it is you set <code>next_hover</code> to its ID. At the end of the frame, the UI assigns the value of <code>next_hover</code> to the <code>hover</code> variable.<br><br>The reason for this two-step process is that multiple controls or objects might be drawn on top of each other in the same area of the UI. The last object drawn will be on top and we want the <em>hover</em> variable to reflect whatever the user sees on the screen.</td></tr>
<tr><td>Overlay</td><td>The UI is actually drawn in two layers, one <em>Base</em> and one <em>Overlay</em> layer. The controls in the overlay layer are drawn on top of the controls in the <em>Base</em> layer, even if they are drawn earlier in the draw order. We use the Overlay layer for things like drop-down menus that should appear on top of other controls.<br><br>If an earlier control set <em>next_hover</em> to a control in the Overlay layer, this shouldn’t be changed by a later control in the base layer, because the Overlay layer control will appear on top of that one. We use a variable <code>next_hover_in_overlay</code> to keep track of if the current <code>next_hover</code> value represents an ID in the Overlay layer. In this case, it shouldn’t be changed by base layer controls.<br><br>In practice, the Overlay layer is implemented by keeping track of two index buffers in the drawing system, one for the base layer and one for the overlay layer. (Note that the two layers still share a single vertex buffer.) At the end of drawing, we merge the two buffers into one, by simply concatenating the Overlay buffer at the end of the base Buffer, thus making sure the overlay controls are drawn later, on top of the base control. With this approach, we can still draw everything with a single draw call.<br><br>Note that as a consequence of how we render our UI — we only have a single Vulkan context and everything is drawn with the same draw call — drop-down menus and other pop-up controls cannot extrude past the edges of the system window — everything is drawn with the system window rect.</td></tr>
<tr><td>Active</td><td>Similar to <em>Hover</em>, <em>Active</em> is a variable that keeps track of the currently active control, i.e. the control the user is currently interacting with.<br><br>We need to keep track of the active control for two reasons. First, we often want to draw the active control in a special way, such as showing a highlight and a caret in an active text box.<br><br>Second, the active control typically needs to keep track of some extra state. For example, an active slider needs to keep track of the slider’s initial position so that it can pop back to that if the user drags the mouse outside the slider.<br><br>The UI system uses a single large <code>char[]</code> buffer to keep track of the current active control’s state. This buffer is shared by all controls. Since there can only be one active control at a time, only one control will be using this buffer at a time. When a new control becomes active the buffer is zeroed (this should be a valid initial state for the active data).<br><br>Typically a control becomes active if the user presses the left mouse button while the control is being <em>hovered</em>. In this case, the control will call <a href="https://ourmachinery.com/apidoc/plugins/ui/ui.h.html#structtm_ui_api.set_active()"><code>tm_ui_api-&gt;set_active()</code></a>. Though there are other ways a control can become active too, such as by tabbing. To implement tab focus, you need to call <a href="https://ourmachinery.com/apidoc/plugins/ui/ui.h.html#structtm_ui_api.focus_on_tab()"><code>tm_ui_api-&gt;focus_on_tab()</code></a> in the control’s code.</td></tr>
<tr><td>Clipping</td><td>The drawing system has support for <em>Clipping</em> <em>Rects.</em> This is mostly useful when you need to clip text to a control’s rect. You create a new clipping rect by calling <a href="https://ourmachinery.com/apidoc/plugins/ui/draw2d.h.html#structtm_draw2d_api.add_clip_rect()"><code>tm_draw2d_api-&gt;add_clip_rect()</code></a> or <a href="https://ourmachinery.com/apidoc/plugins/ui/draw2d.h.html#structtm_draw2d_api.add_sub_clip_rect()"><code>tm_draw2d_api-&gt;add_sub_clip_rect()</code></a>. This gives you a clipping ID that can be passed as part of the Draw or UI style.</td></tr>
<tr><td>Responder scopes</td><td><em>Responder Scopes</em> are used to control which controls can respond to keyboard input. Typically, when a control is <em>Active</em>, it, and all its parent controls can respond to keyboard input. For example, if the control is inside a scrollview, the scrollview will respond to scroll keypresses, while the tab that hosts the scrollview may respond to commands such as Ctrl+F.<br><br>Being an immediate GUI system, <em>The Machinery</em> doesn’t have an explicit concept of “child” and “parent” controls. Instead we use the concept of <em>Responder Scopes</em>. A parent control first calls <a href="https://ourmachinery.com/apidoc/plugins/ui/ui.h.html#structtm_ui_api.begin_responder_scope()"><code>begin_responder_scope()</code></a>, then draws all its child controls and finally calls <a href="https://ourmachinery.com/apidoc/plugins/ui/ui.h.html#structtm_ui_api.end_responder_scope()"><code>end_responder_scope()</code></a>. This establishes a parent-child relationship for the purpose of keyboard interaction.<br><br>When a control becomes <em>Active</em>, the current set of Responder Scopes is saved as the <em>Responder Chain</em>. This is the list of controls that can respond to a keyboard action. To test if your control should act on keyboard input, you can call <a href="https://ourmachinery.com/apidoc/plugins/ui/ui.h.html#structtm_ui_api.in_responder_chain()"><code>in_responder_chain()</code></a>.<br><br>Note: We currently don’t have any mechanism to check if other controls in the Responder Chain have “consumed” keyboard input, so if you have multiple controls in the same chain that respond to the same keyboard command, you may run into trouble.</td></tr>
</tbody></table>
<p>Bellow, we have a higher-level view of the steps needed to implement our interaction logic:</p>
<ol>
<li>Create a id with <a href="https://ourmachinery.com/apidoc/plugins/ui/ui.h.html#structtm_ui_api.make_id()"><code>tm_ui_api→make_id()</code></a>;</li>
<li>Check if the button is already active with <a href="https://ourmachinery.com/apidoc/plugins/ui/ui.h.html#structtm_ui_api.is_active()"><code>tm_ui_api→is_active()</code></a>, it will return a pointer for a 16Kb buffer that you can use to keep custom data needed while the button is active;</li>
<li>Check if the mouse is hovering the button, and set activation <code>next_hover</code> variable according. At the end of the frame, the UI system will set hover to our control id case no other control changed next_hover after us;</li>
<li>Case the hover variable contains our control id and mouse is pressed, set it as the active one, which is done which <a href="https://ourmachinery.com/apidoc/plugins/render_graph/render_graph.h.html#structtm_render_graph_setup_api.set_active()"><code>tm_ui_api→set_active()</code></a>, a pointer to the 16Kb buffer will be returned so you can cast it to control custom data, note that we need to pass a hash to the function identifying this data;</li>
<li>Case our button is active and mouse was released, the control is considered clicked, and we call <a href="https://ourmachinery.com/apidoc/plugins/ui/ui.h.html#structtm_ui_api.clear_active()"><code>tm_ui_api→clear_active()</code></a> to deactivate him;</li>
<li>Now we can check if the mouse is hovering our control and use either the active or hovering color depending on we are the active control or not;</li>
</ol>
<p>With this in mind, the complete code will be the following:</p>
<ul>
<li>ui_custom_controls.h:</li>
</ul>
<pre><code class="language-C">    ...
    typedef struct tm_ui_circular_button_data_t {
        const char *name;
        uint32_t frames_active;
    } tm_ui_circular_button_data_t;
    
    typedef struct tm_ui_circular_button_t
    {
        uint64_t id;
    
        tm_vec2_t center;
        float radius;
        tm_color_srgb_t background_color;
        tm_color_srgb_t hover_color;
        tm_color_srgb_t clicked_color;
    
        const char *text;
        const struct tm_color_srgb_t text_color;
    } tm_ui_circular_button_t;
    ...
</code></pre>
<ul>
<li>ui_custom_controls.c:</li>
</ul>
<pre><code class="language-C">    ...
    
    bool circular_button(struct tm_ui_o *ui, const struct tm_ui_style_t *uistyle, const tm_ui_circular_button_t *c)
    {
        // Step 1
        // tm_ui_buffer_t contains information needed when creating a custom control
        tm_ui_buffers_t uib = tm_ui_api-&gt;buffers(ui);
        const uint64_t id = c-&gt;id ? c-&gt;id : tm_ui_api-&gt;make_id(ui);
        
        // Step 2
        // is_active will return a pointer for user defined data up to 16KB
        tm_ui_circular_button_data_t *active = (tm_ui_circular_button_data_t *)tm_ui_api-&gt;is_active(ui, id, TM_UI_ACTIVE_DATA__CIRCULAR_BUTTON);
        if (active) {
            TM_LOG(&quot;active data -&gt; name: %s, frames_active: %u\n&quot;, active-&gt;name, active-&gt;frames_active);
            active-&gt;frames_active++;
        }
    
        // convert tm_ui_style_t to tm_draw2d_style_t
        tm_draw2d_style_t style;
        tm_ui_api-&gt;to_draw_style(ui, &amp;style, uistyle);
        style.color = c-&gt;background_color;
        
        // Step 3
        bool clicked = false;
        bool inside = tm_vec2_in_circle(uib.input-&gt;mouse_pos, c-&gt;center, c-&gt;radius);
        if (inside)
            uib.activation-&gt;next_hover = id;
        
        // Step 4
        if (uib.activation-&gt;hover == id &amp;&amp; uib.input-&gt;left_mouse_pressed) {
            active = tm_ui_api-&gt;set_active(ui, id, TM_UI_ACTIVE_DATA__CIRCULAR_BUTTON);
            if (active)
                *active = (tm_ui_circular_button_data_t){ .name = &quot;circular_button&quot;, .frames_active = 0 };
            tm_ui_api-&gt;set_responder_chain(ui, 0);
        }
        
        // Step 5
        if (active &amp;&amp; uib.input-&gt;left_mouse_released) {
            clicked = inside;
            tm_ui_api-&gt;clear_active(ui);
        }
        
        // Step 6
        if (inside) {
            if (active)
                style.color = c-&gt;clicked_color;
            else if (uib.activation-&gt;hover == id)
                style.color = c-&gt;hover_color;
        }
    
        tm_ui_api-&gt;reserve_draw_memory(ui);
        tm_draw2d_api-&gt;fill_circle(uib.vbuffer, uib.ibuffers[uistyle-&gt;buffer], &amp;style, c-&gt;center, c-&gt;radius);
    
        return clicked;
    }
    
    ...
</code></pre>
<h2 id="drawing-text"><a class="header" href="#drawing-text">Drawing text</a></h2>
<p>The last thing we need is to draw some text inside our button. You'll need to call <a href="https://ourmachinery.com/apidoc/plugins/ui/draw2d.h.html#structtm_draw2d_api.draw_glyphs()"><code>tm_draw2d_api→draw_glyphs()</code></a> to fill UI buffers with text information. It takes as one of its arguments an array of glyphs indices that point to the corresponding <a href="https://ourmachinery.com/apidoc/plugins/ui/draw2d.h.html#structtm_font_glyph_t">tm_font_glyph_t</a> glyph inside the <a href="https://ourmachinery.com/apidoc/plugins/ui/draw2d.h.html#structtm_font_t">tm_font_t</a> structure. To get this information, we first need to convert the desired text to an array of codepoints using <a href="https://ourmachinery.com/apidoc/foundation/unicode.h.html#structtm_unicode_api.utf8_decode_n()"><code>tm_unicode_api→utf8_decode_n()</code></a> and pass them to <a href="https://ourmachinery.com/apidoc/plugins/ui/draw2d.h.html#structtm_font_api.glyphs()"><code>tm_font_api→glyphs()</code></a> . Thus, add the following lines to the source code:</p>
<p>With this in mind, the complete code will be the following:</p>
<ul>
<li>ui_custom_controls.h:</li>
</ul>
<pre><code class="language-C">    ...
    
    typedef struct tm_ui_circular_button_t
    {
       ...
        uint32_t icon;
        const char *text;
        const struct tm_color_srgb_t text_color;
    } tm_ui_circular_button_t;
    ...
</code></pre>
<ul>
<li>ui_custom_controls.c:</li>
</ul>
<pre><code class="language-C">    ...
    
    bool circular_button(struct tm_ui_o *ui, const struct tm_ui_style_t *uistyle, const tm_ui_circular_button_t *c)
    {
        ...
        // Inscribe a quad in button circle
        const float side = c-&gt;radius * sqrtf(2);
        tm_rect_t text_rect = tm_rect_center_dim(c-&gt;center, (tm_vec2_t){ side, side });
    
        tm_ui_api-&gt;reserve_draw_memory(ui);
        style.clip = tm_draw2d_api-&gt;add_sub_clip_rect(uib.vbuffer, style.clip, text_rect);
    
        // Get glyphs from our text
        uint16_t glyphs[128];
        uint32_t n = 0;
        {
            uint32_t codepoints[128];
            n = tm_unicode_api-&gt;utf8_decode_n(codepoints, 128, tm_or(c-&gt;text, &quot;&quot;));
            tm_font_api-&gt;glyphs(style.font-&gt;info, glyphs, codepoints, 128);
        }
        tm_vec2_t text_pos = {
            .x = c-&gt;center.x - side / 2.f,
            .y = middle_baseline(text_rect.y, text_rect.h, style.font-&gt;info, 1.f),
        };
        style.color = c-&gt;text_color;
        tm_draw2d_api-&gt;draw_glyphs(uib.vbuffer, uib.ibuffers[uistyle-&gt;buffer], &amp;style, text_pos, glyphs, n);
    
        return clicked;
    }
    
    ...
</code></pre>
<p>We now have a custom button implementation that can be used across your projects. Please extend it and show us your results.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="toolbars-and-overlays"><a class="header" href="#toolbars-and-overlays">Toolbars and Overlays</a></h1>
<p>In the Machinery, tabs can provide toolbars. If you wish to use custom toolbars within The Machinery tabs, you do not need to use anything within <a href="https://ourmachinery.com/apidoc/plugins/ui/toolbar.h.html#structtm_toolbar_api">tm_toolbar_api</a>. The docking system will ask your tab for a list of toolbars to draw each frame. See <a href="https://ourmachinery.com/apidoc/plugins/ui/docking.h.html#structtm_tab_vt.toolbars()">tm_tab_vt-&gt;toolbars()</a>.</p>
<p><img src="https://paper-attachments.dropbox.com/s_688CFE67758A45D845E788E6DA05448A2BCF730C2B07FEF2D06AB18D2C46F736_1625428649231_new_order_toolbars.gif" alt="" /></p>
<p>In this walkthrough, we will learn how to write our little toolbar for our newly added tab! This walkthrough requires you to know how our plugin system works.</p>
<p><strong>Table of Content</strong></p>
<ul>
<li><a href="ui/toolbars-overlays.html#implement-a-toolbar-in-a-tab">Implement a Toolbar in a Tab</a></li>
<li><a href="ui/toolbars-overlays.html#tab-overlays">Tab Overlays</a></li>
<li><a href="ui/toolbars-overlays.html#how-to-use-toolbars-outside-of-the-machinery-tabs">How to use toolbars outside of The Machinery tabs</a></li>
</ul>
<h2 id="implement-a-toolbar-in-a-tab"><a class="header" href="#implement-a-toolbar-in-a-tab">Implement a Toolbar in a Tab</a></h2>
<p>To begin with, we need to create a new tab plugin. We go on <strong>File -&gt; New Plugin -&gt; Tab.</strong> </p>
<p>A file dialog pops up, and we can decide where to store our plugin.</p>
<p><img src="https://www.dropbox.com/s/jhrqv8t8bbhr20u/tm_tut_new_tab.png?dl=1" alt="" /></p>
<p>We open the <code>custom_tab.c</code> (or however we called it) file with our favorite editor.</p>
<p>We search for the line in which we define the tab itself:</p>
<pre><code class="language-c">//...code
static tm_the_machinery_tab_vt* custom_tab_vt = &amp;(tm_the_machinery_tab_vt){
    .name = TM_CUSTOM_TAB_VT_NAME,
    .name_hash = TM_CUSTOM_TAB_VT_NAME_HASH,
    .create_menu_name = tab__create_menu_name,
    .create = tab__create,
    .destroy = tab__destroy,
    .title = tab__title,
    .ui = tab__ui
};
//...code
</code></pre>
<p>To our definition, we add a <a href="https://ourmachinery.com/apidoc/plugins/ui/docking.h.html#structtm_tab_vt.toolbars()"><code>toolbars()</code></a>. This function returns a C-Array of toolbar definitions.  The array is allocated with the passed in the temporary allocator.</p>
<blockquote>
<p><strong>Note:</strong> A temporary allocator (<a href="https://ourmachinery.com/apidoc/foundation/temp_allocator.h.html">tm_temp_allocator_api</a>) Provides a system for temporary memory allocations. I.e., short-lived memory allocations that are automatically freed when the allocator is destroyed. Temp allocators typically use a pointer bump allocator to allocate memory from one or more big memory blocks and then free the entire block when the allocator is destroyed.</p>
<p><strong>Important:</strong> You need to include  the api first<code>#include &lt;foundation/temp_allocator.h&gt;</code> and get the api from the registry!</p>
</blockquote>
<pre><code class="language-c">static tm_the_machinery_tab_vt* custom_tab_vt = &amp;(tm_the_machinery_tab_vt){
    .name = TM_CUSTOM_TAB_VT_NAME,
    .name_hash = TM_CUSTOM_TAB_VT_NAME_HASH,
    .create_menu_name = tab__create_menu_name,
    .create = tab__create,
    .destroy = tab__destroy,
    .title = tab__title,
    .ui = tab__ui
    .toolbars = tab__toolbars, // we added this line
};
</code></pre>
<p>After we have added this, we need actually to define the function itself:</p>
<pre><code class="language-c">static struct tm_toolbar_i *tab__toolbars(tm_tab_o *tab, tm_temp_allocator_i *ta)
{
// code
}
</code></pre>
<p>Within this function, we define our toolbars. Our toolbar will have an essential job! It will have a button that prints &quot;Hello World&quot;.</p>
<p>To make this work, we need to create a C-Array of <a href="https://ourmachinery.com/apidoc/plugins/ui/toolbar.h.html#structtm_toolbar_i">tm_toolbar_i</a> objects and add our toolbar to it. This interface expects the following things:</p>
<table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody>
<tr><td>id</td><td>An application-wide unique ID for the toolbar. <strong>Cannot be zero.</strong></td></tr>
<tr><td>owner</td><td>A pointer that can be accessed through the <code>toolbar</code> argument to the functions of this struct. Often used to store state for the toolbar, for example if you drawing toolbars inside a tab then you might want to store a pointer to that tab here.</td></tr>
<tr><td>ui</td><td>Called when <a href="https://ourmachinery.com/apidoc/plugins/ui/toolbar.h.html#structtm_toolbar_api.ui()"><code>ui()</code></a> of [<a href="https://ourmachinery.com/apidoc/plugins/ui/toolbar.h.html#structtm_toolbar_api">tm_toolbar_api</a>](https://ourmachinery.com/apidoc/plugins/ui/toolbar.h.html#structtm_toolbar_api) wants to draw the toolbar. Make sure to respect <code>draw_mode</code> and return the rect that encompasses all the drawn controls. For toolbars inside horizontal and vertical containers, you can use <a href="https://ourmachinery.com/apidoc/plugins/ui/toolbar.h.html#tm_toolbar_rect_split_off()"><code>tm_toolbar_rect_split_off()</code></a> and <a href="https://ourmachinery.com/apidoc/plugins/ui/toolbar.h.html#tm_toolbar_rect_advance()"><code>tm_toolbar_rect_advance()</code></a> to easily manage the rect sizes while drawing your toolbar.</br>If you need to store state, the make sure to set <code>owner</code> when you create the [<a href="https://ourmachinery.com/apidoc/plugins/ui/toolbar.h.html#structtm_toolbar_i">tm_toolbar_i</a>](https://ourmachinery.com/apidoc/plugins/ui/toolbar.h.html#structtm_toolbar_i) object and get it from the passed <code>toolbar</code> pointer.</td></tr>
<tr><td>draw_mode_mask</td><td>A combination of supported draw modes, ORed together values of <a href="https://ourmachinery.com/apidoc/plugins/ui/toolbar.h.html#enumtm_toolbar_draw_mode"><code>enum tm_toolbar_draw_mode</code></a>. The <code>ui</code> function will be passed the currently used draw mode and is expected to handle it.</td></tr>
</tbody></table>
<blockquote>
<p><strong>Note:</strong> For a complete list please check the <a href="https://ourmachinery.com/apidoc/plugins/ui/toolbar.h.html#structtm_toolbar_i">documentation</a></p>
</blockquote>
<table><thead><tr><th>Mask</th><th>Description</th></tr></thead><tbody>
<tr><td>TM_TOOLBAR_DRAW_MODE_HORIZONTAL</td><td>You an draw the toolbar horizontal.</td></tr>
<tr><td>TM_TOOLBAR_DRAW_MODE_VERTICAL</td><td>You an draw the toolbar vertical.</td></tr>
<tr><td>TM_TOOLBAR_DRAW_MODE_WIDGET</td><td>The toolbar is an overlay</td></tr>
</tbody></table>
<p>Let us provide the essential things:</p>
<ol>
<li>The id is to be able to identify the toolbar.</li>
<li>The UI function is to be able to draw something.</li>
<li>The draw_mode_mask to indicate where we want the toolbar to be drawn.</li>
</ol>
<pre><code class="language-c">static struct tm_toolbar_i *tab__toolbars(tm_tab_o *tab, tm_temp_allocator_i *ta)
{
struct tm_toolbar_i *toolbars = 0;
    tm_carray_temp_push(toolbars,
        ((tm_toolbar_i){
            .id = TM_STRHASH_U64(TM_STATIC_HASH(&quot;my_tab&quot;, 0xcffc3169d97098acULL)),
            .ui = ui,
            .draw_mode_mask = TM_TOOLBAR_DRAW_MODE_HORIZONTAL | TM_TOOLBAR_DRAW_MODE_VERTICAL,
        }),
        ta);
}
</code></pre>
<p>In our UI function, we can add the button via the [<a href="https://ourmachinery.com/apidoc/plugins/ui/ui.h.html#structtm_ui_api">tm_ui_api</a>](https://ourmachinery.com/apidoc/plugins/ui/ui.h.html#structtm_ui_api). Then log the string &quot;Hello World&quot; to the screen with the <a href="https://ourmachinery.com/apidoc/foundation/log.h.html#log.h">logger API</a>.</p>
<blockquote>
<p><strong>Note:</strong> You need include the <code>plugins/ui/ui.h</code> and the <code>foundation/log.h</code> as well as get the API's first!</p>
</blockquote>
<pre><code class="language-c">static tm_rect_t ui(tm_toolbar_i *toolbar, struct tm_ui_o *ui, const struct tm_ui_style_t *uistyle, tm_rect_t toolbar_r, enum tm_toolbar_draw_mode dm)
{
    // TODO: add code
}
</code></pre>
<h2 id="tab-overlays"><a class="header" href="#tab-overlays">Tab Overlays</a></h2>
<p><img src="https://paper-attachments.dropbox.com/s_538DCFE5C2E14B8A7C343B96D5CD2C3E2C191E06DD3EF47F66924FDF7AE2C192_1617105468374_image.png" alt="An image with visualization modes enabled using the Visualize overlay, as well as a Renderer Statistics overlay. The Visualize overlay is found in Top right toolbar → Render → Lighting Module → Show as overlay. The Statistics overlay is found in Top right toolbar → Statistics." /></p>
<p>As an extension to the dockable toolbars the engine support overlays that hover on top of the tabs. Also, any toolbar can be pulled off and be made into a hovering overlay.</p>
<p>An overlay is just a toolbar that does not belong to any of the four toolbar containers that run along the edge of the tab. Toolbars have three rendering modes — horizontal, vertical, and widget. The widget mode is new, it is the richer, window-like mode seen in the picture above. </p>
<p>In the scene and simulate tabs, we’ve added:</p>
<ul>
<li>A rendering visualization overlay. Found in <code>Render → Lighting Module → Show as overlay</code> in the top right toolbar.</li>
<li>A Statistics button (also top right toolbar) that makes it possible to popup statistics overlays, previously found within the Statistics tab.</li>
</ul>
<p>The tab should return all toolbars it wishes to draw each frame, see <a href="https://ourmachinery.com/apidoc/plugins/ui/docking.h.html#structtm_tab_vt.toolbars()"><code>tm_tab_vt-&gt;toolbars()</code></a>. If you wish to support widget mode drawing, then make sure to set the bitmask <a href="https://ourmachinery.com/apidoc/plugins/ui/toolbar.h.html#structtm_tab_toolbar_i.draw_mode_mask"><code>tm_toolbar_i-&gt;draw_mode_mask</code></a> a value that contains [<a href="https://ourmachinery.com/apidoc/plugins/ui/toolbar.h.html#enumtm_toolbar_draw_mode">TM_TOOLBAR_DRAW_MODE_WIDGET</a>](https://ourmachinery.com/apidoc/plugins/ui/toolbar.h.html#enumtm_toolbar_draw_mode).</p>
<p>Toolbars are generalized and they are not coupled to the docking system and the tabs, so you could use them within other contexts if you wish. </p>
<h2 id="how-to-use-toolbars-outside-of-the-machinery-tabs"><a class="header" href="#how-to-use-toolbars-outside-of-the-machinery-tabs">How to use toolbars outside of The Machinery tabs</a></h2>
<p>See the documentation under <code>How to use toolbars outside of The Machinery tabs</code> in <a href="https://ourmachinery.com/apidoc/plugins/ui/toolbar.h.html">toolbar.h</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
