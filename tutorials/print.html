<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Machinery Tutorial Book</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Welcome</a></li><li class="chapter-item expanded "><a href="creation_graph/index.html"><strong aria-hidden="true">2.</strong> Creation Graph</a></li><li class="chapter-item expanded "><a href="physics/index.html"><strong aria-hidden="true">3.</strong> Physics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="physics/triggers.html"><strong aria-hidden="true">3.1.</strong> Triggers</a></li></ol></li><li class="chapter-item expanded "><a href="the_truth/index.html"><strong aria-hidden="true">4.</strong> The Truth</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="the_truth/custom_asset/index.html"><strong aria-hidden="true">4.1.</strong> Creating a custom asset</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="the_truth/custom_asset/part1.html"><strong aria-hidden="true">4.1.1.</strong> Part 1</a></li><li class="chapter-item expanded "><a href="the_truth/custom_asset/part2.html"><strong aria-hidden="true">4.1.2.</strong> Part 2</a></li><li class="chapter-item expanded "><a href="the_truth/custom_asset/part3.html"><strong aria-hidden="true">4.1.3.</strong> Part 3</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="ui/index.html"><strong aria-hidden="true">5.</strong> UI</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ui/build_custom_ui_controls/index.html"><strong aria-hidden="true">5.1.</strong> Build Custom UI Controls</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ui/build_custom_ui_controls/part1.html"><strong aria-hidden="true">5.1.1.</strong> Part 1</a></li></ol></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">The Machinery Tutorial Book</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/OurMachinery/themachinery-books" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="welcome"><a class="header" href="#welcome">Welcome</a></h1>
<p>Hi,</p>
<p>This book is here to give you guidance on how to work with the engine. We are constantly working on improving the onboarding as much as possible. If you have not read about the basic concepts of the engine you might want to start at there before you move on to this book <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/index.html">The Machinery Book</a>.</p>
<p>Besides this book we have several other resources which might be good to checkout:</p>
<ul>
<li><a href="https://ourmachinery.com/apidoc/apidoc.html">Our API Documentation</a></li>
<li><a href="https://ourmachinery.com/post/">Our Blog</a></li>
<li><a href="https://anchor.fm/ourmachinery">Our Podcast</a></li>
<li><a href="https://discord.gg/SHHSZaH">Our Discord</a></li>
<li><a href="https://github.com/OurMachinery/themachinery-public/discussions">Our Github Discussion Board</a></li>
</ul>
<p>Enjoy!</p>
<p><em>The Machinery Team</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creation-graph"><a class="header" href="#creation-graph">Creation Graph</a></h1>
<p>In The Machinery, we provide full control over how data enters the engine and what data-processing
steps that get executed, allowing technical artists to better optimize content and setup custom,
game-specific asset pipelines. </p>
<p>This is handled through <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book//creation_graphs/concept.html"><em>Creation Graphs</em></a>. A <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book//creation_graphs/concept.html"><em>Creation Graphs</em></a> is essentially a generic framework for
processing arbitrary data on the CPUs and GPUs, exposed through a graph front-end view. While we can
use <em>Creation Graphs</em> for any type of data processing.</p>
<p>The following section will guide you from basic use cases to more advanced use cases.</p>
<p>We have a couple of blog posts which might also be a valid source of information and interesting to
you.</p>
<ul>
<li><a href="https://ourmachinery.com/post/creation-graphs/">Creation Graphs</a></li>
<li><a href="https://ourmachinery.com/post/more-on-creation-graphs/">More on Creation Graphs</a></li>
<li><a href="https://ourmachinery.com/post/summer-fun-with-creation-graphs/">Summer Fun with Creation Graphs</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="physics"><a class="header" href="#physics">Physics</a></h2>
<p>The Machinery integrates Nvidia's PhysX toolkit and uses it for physics simulation of entities. This section will not attempt to describe in detail how physics simulation works, for that we refer to <a href="https://docs.nvidia.com/gameworks/content/gameworkslibrary/physx/guide/Manual/Index.html">the PhysX documentation</a>. 
We will only talk about how physics is set up in The Machinery.</p>
<p><strong>Table of Content</strong></p>
<ul>
<li><a href="physics/index.html#the-physics-simulation-system">The physics simulation system</a>
<ul>
<li><a href="physics/index.html#physics-assets">Physics Assets</a></li>
<li><a href="physics/index.html#physics-components">Physics Components</a></li>
</ul>
</li>
<li><a href="physics/index.html#physics-scripting">Physics scripting</a></li>
<li><a href="physics/index.html#missing-features">Missing Features</a></li>
<li><a href="physics/index.html#tutorials">Tutorials</a></li>
</ul>
<h2 id="the-physics-simulation-system"><a class="header" href="#the-physics-simulation-system">The physics simulation system</a></h2>
<p>The physics simulation system introduces two new assets: <em>Physics Material</em> and <em>Physics Collision</em>
as well as four new components: <em>Physics Shape Component</em>, <em>Physics Body Component</em>, <em>Physics
Joint Component</em>, and <em>Physics Mover Component</em>.</p>
<h3 id="physics-assets"><a class="header" href="#physics-assets">Physics Assets</a></h3>
<p>A <em>Physics Material</em> asset specifies the physical properties of a physics object: <em>friction</em> (how
&quot;slippery&quot; the object is) and <em>restitution</em> (how &quot;bouncy&quot; the object is). Note that if you don't
assign a material to a physics shape it will get default values for <em>friction</em> and <em>constitution</em>.</p>
<p>A <em>Physics Collision</em> asset describes a <em>collision class</em>. <em>Collision Classes</em> control which physics
shapes collide with each other. For example, a common thing to do is to have a <em>debris</em> class for
small objects and set it up so that <em>debris</em> collide with regular objects, but not with other
<em>debris</em>. That way, you are not wasting resources on computing collisions between lots of tiny
objects. (Note that the debris objects still need to collide with regular objects, or they would
just fall through the world.)</p>
<p>In addition to deciding who collides with who, the collision class also decides which collisions
generate callback events. These events can be handled in the <em>Entity Graph</em>.</p>
<p>If you don't assign a collision class to a physics shape, it will get the <em>Default</em> collision class.</p>
<h3 id="physics-components"><a class="header" href="#physics-components">Physics Components</a></h3>
<p>The <em>Physics Shape Component</em> can be added to an entity to give it a collision shape for physics.
Entities with shape components will collide with each other when physics is simulated.</p>
<p>A physics shape can either be specified as geometry (sphere, capsule, plane, box) or it can be
computed from a graphics mesh (convex, mesh). Note that if you use computed geometry, you must press
the <strong>Cook</strong> button in the Properties UI to explicitly compute the geometry for the object.</p>
<p><img src="physics/index.html#" alt="Convex shape." /></p>
<p>If you just give an entity a <em>Physics Shape Component</em> it will become a static physics object. Other
moving objects can still collide with it, but the object itself won't move.</p>
<p>To create a moving physics object, you need to add a <em>Physics Body Component</em>. The body component
lets you specify dynamic properties such as damping, mass, and inertia tensor. It also lets you
specify whether the object should be <em>kinematic</em> or not. A <em>kinematic</em> object is being moved by
<em>animation</em>. Its movement is not affected by physics, but it can still affect other physical
objects by colliding with them and pushing them around. In contrast, if the object is <em>not
kinematic</em> it will be completely controlled by physics. If you place it above ground, it will fall
down as soon as you start the simulation.</p>
<p>Note that parameters such as <em>damping</em> and <em>mass</em> do not really affect kinematic objects, since
the animations will move them the same way, regardless of their mass or damping. However, these
parameters can still be important because gameplay code could at some point change the object
from being kinematic to non-kinematic. If the gameplay code never makes the body non-kinematic, the
mass doesn't matter.</p>
<p>The <em>Physics Joint Component</em> can be used to add <em>joints</em> to the physics simulation. Joints can tie
together physics bodies in various ways. For example, if you tie together two bodies with a hinge
joint they will swing as if they were connected by a hinge. For a more thorough description of
joints, we refer to the PhysX documentation.</p>
<p>The <em>Physics Mover Component</em> implements a physics-based character controller. If you add it to an
entity, it will keep the entity's feet on the ground, prevent it from going through walls, etc. For
an example of how to use the character controller, check out the <code>animation</code> or <code>gameplay</code> sample
projects.</p>
<h2 id="physics-scripting"><a class="header" href="#physics-scripting">Physics scripting</a></h2>
<p>Physics can be scripted using the visual scripting language in the <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/editing_workflows/visual-scripting.html"><em>Entity Graph</em></a>.</p>
<p>We can divide the PhysX scripting nodes into a few categories.</p>
<p><strong>Nodes that query the state of a physics body:</strong></p>
<ul>
<li>Get Angular Velocity</li>
<li>Get Velocity</li>
<li>Is Joint Broken</li>
<li>Is Kinematic</li>
</ul>
<p><strong>Nodes that manipulate physics bodies:</strong></p>
<ul>
<li>Add Force</li>
<li>Add Torque</li>
<li>Break Joint</li>
<li>Push</li>
<li>Set Angular Velocity</li>
<li>Set Kinematic</li>
<li>Set Velocity</li>
</ul>
<p><strong>Event nodes that get triggered when something happens in the scene:</strong></p>
<ul>
<li>On Contact Event</li>
<li>On Joint Break Event</li>
<li>On Trigger Event</li>
</ul>
<p><strong>Nodes that query the world for physics bodies:</strong></p>
<ul>
<li>Overlap</li>
<li>Raycast</li>
<li>Sweep</li>
</ul>
<blockquote>
<p><strong>Note</strong> that the query nodes may return more than one result. They will do that by triggering their
<em>Out</em> event multiple times, each time with one of the result objects. (In the future we might change
this and have the nodes actually return arrays of objects.)</p>
</blockquote>
<p>From C you can access those features via the <a href="https://ourmachinery.com/apidoc/plugins/physx/physx_scene.h.html#structtm_physx_scene_api">tm_physx_scene_api</a>.</p>
<h2 id="missing-features"><a class="header" href="#missing-features">Missing Features</a></h2>
<p>Note that The Machinery doesn't currently support all the features found in PhysX. The most
glaring omissions are:</p>
<ul>
<li>D6 joints and joint motors.</li>
<li>Vehicles.</li>
</ul>
<p>We will add more support going forward.</p>
<p>For an example of how to use physics, see the <a href="https://ourmachinery.com/samples.html">Physics Sample Project</a>.</p>
<h2 id="tutorials"><a class="header" href="#tutorials">Tutorials</a></h2>
<p>For more information and guides checkout out the <a href="https://ourmachinery.github.io/themachinery-books/tutorials/">The Machinery Tutorials Book</a> as well as our <a href="https://ourmachinery.com/samples.html">Physics Sample</a>.</p>
<p>In this section we will discuss some of the Samples in more detail. </p>
<p>You can download the Physics Sample projects from the Download Tab: <em><strong>Help -&gt; Download Sample Projects</strong></em> </p>
<p><img src="https://www.dropbox.com/s/1w81dsmhazf6pfn/tm_tut_physics_sample_download.png?dl=1" alt="Where to find the samples" /></p>
<p>After you have downloaded the Physic Sample Project, you can open it. Its folder structure looks as following in the default view:</p>
<p><img src="https://www.dropbox.com/s/igj4b4ao1ntb4zw/tm_tut_physics_scenes.png?dl=1" alt="Where to find the scene" /></p>
<p>All examples are in the folder <code>Scenes</code>. When you open that folder, you can see all the sample Scenes (Entities). Double click on the Sample of your choice, and the Editor will load the Scene for you.</p>
<p>Each of the Sample Scenes is composed of multiple Entity Prototypes. You can find them in the &quot;Special Objects&quot; or in the &quot;Shapes&quot; folder in the Asset Browser.</p>
<p><img src="https://www.dropbox.com/s/cafrzpkal6sd1y7/tm_tut_physics_special_objects.png?dl=1" alt="Special Objects folder" /></p>
<p><em>Special Objects</em> are entities with Graph Component attached and have the logic with them.</p>
<p><img src="https://www.dropbox.com/s/og7wipthmw1hl7d/tm_tut_physics_shapes.png?dl=1" alt="" /></p>
<p><em>Shapes</em> are reused Entities to demonstrate different kind of Physic Bodies.</p>
<blockquote>
<p><strong>Note:</strong> If you change any of those Prototypes all the none modified instances will change as well. Keep this in mind when playing around with the samples.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="triggers"><a class="header" href="#triggers">Triggers</a></h2>
<p>This walkthrough shows you how to create a trigger with the Graph Component. You can find the &quot;source code&quot; in our <a href="https://ourmachinery.com/samples.html">Physic Samples</a>.</p>
<p><strong>Table of Content</strong></p>
<ul>
<li><a href="physics/triggers.html#assemble-a-trigger">Assemble a Trigger</a>
<ul>
<li><a href="physics/triggers.html#create-the-trigger-entity">Create the Trigger Entity</a></li>
<li><a href="physics/triggers.html#add-the-logic-to-the-graph">Add the logic to the graph</a></li>
<li><a href="physics/triggers.html#create-the-ball">Create the ball</a></li>
<li><a href="physics/triggers.html#creating-the-scene">Creating the Scene</a></li>
<li><a href="physics/triggers.html#spawn-balls">Spawn balls</a></li>
</ul>
</li>
<li><a href="physics/triggers.html#conclusion">Conclusion</a></li>
</ul>
<h2 id="assemble-a-trigger"><a class="header" href="#assemble-a-trigger">Assemble a Trigger</a></h2>
<p>What is a trigger? </p>
<p>Something that reacts when something intersects/touches them, either constantly or just the first/last time.</p>
<blockquote>
<p><strong>Note:</strong> In Unreal Engine, this might be called Trigger Actors / Trigger Box. </p>
</blockquote>
<p>In the Machinery, we have two types of triggers we can use:</p>
<ul>
<li>PhysX's Trigger- Physical Based Trigger</li>
<li>Volume-Component - The Trigger is based on the Volume Component.</li>
</ul>
<p>In this walkthrough, we are focused on <strong>PhysX's Trigger</strong> <strong>Event.</strong></p>
<p>This walkthrough will be to create a Trigger that adds Velocity to a Ball Shot from the Camera. Therefore we need to make the following Entities:</p>
<ul>
<li>The Trigger</li>
<li>A world (plane)</li>
<li>A Ball</li>
</ul>
<h3 id="create-the-trigger-entity"><a class="header" href="#create-the-trigger-entity">Create the Trigger Entity</a></h3>
<p>Let us create a folder in the Project root and call it &quot;Special Objects&quot;. It will be the folder in which we keep all our <em>Special Objects</em> for now and for what might come.</p>
<p>In this folder, we create an Entity with the name &quot;Trigger&quot;. We add two extra components:</p>
<ul>
<li>A Graph Component for some logic</li>
<li>A Physic Shape to make sure the Physics World can see it</li>
</ul>
<p>When adding the Physic Shape, we need to consider the Type. By default, the Type is Sphere, but that would not suit our needs since we want it to be a red box. We change the Type to Box and tick the Checkbox &quot;Is Trigger&quot; to make sure it is a Trigger. We can also change the Half Extent value if we like.</p>
<p>If you look now into the Scene Tab, you see nothing. To change that, you can turn on the Debug Visualization:</p>
<p><img src="https://www.dropbox.com/s/jp8oxoz8zl0f5d7/tm_tut_physics_viz.png?dl=1" alt="" /></p>
<p>Having a Trigger that cannot be seen might be applicable for some games. In our case, we choose to make the Trigger Visible with a box.</p>
<p>Luckily the core provides a Box Entity for us: <code>core/geometry/box.entity</code>. </p>
<p><img src="https://www.dropbox.com/s/xd9gjg8pbw6p8kj/tm_tut_physics_core_gom.png?dl=1" alt="" /></p>
<p>This location is something we keep in mind!</p>
<p>Let us also add the Box (<code>core/geometry/box.entity</code>) from the core to our Entity as a child. This Box makes it easier for us to test it later because we can see it in the Scene Window.</p>
<h3 id="add-the-logic-to-the-graph"><a class="header" href="#add-the-logic-to-the-graph">Add the logic to the graph</a></h3>
<p>We double-click the Graph Component to open the Graph Editor. The Graph Editor is Empty. We want to add an <code>Init Event</code> and then a &quot;Physx On Trigger Event&quot;. We need to connect the Start Listing connector with the &quot;Init Event Connector&quot;.</p>
<p>To get the current Entity, we add the node &quot;Scene Entity&quot; and connect the outgoing connector with the &quot;Physx On Trigger Event&quot; Entity connector. </p>
<p>The goal was to apply Velocity to any entity that touches the Trigger the first time. That is why we add a connector from the &quot;First Touch&quot; to the newly added Physx Set Velocity node.</p>
<p>We connect the Entity from the &quot;Physx Set Velocity&quot; entity connector to the <em>Touched Entity Connector</em> at the &quot;Physx On Trigger Event&quot; node. </p>
<p>We need to get the current Velocity of this Entity. We can do this by using the &quot;Physx Get Velocity&quot; node. The result we modify with, let us say -1 and apply it at the end. (<em>The smaller the value, the stronger the ball will bounce off.</em>)</p>
<p><img src="https://www.dropbox.com/s/g8yhrs5e7wugau4/tm_tut_physics_graph_trigger_event.png?dl=1" alt="" /></p>
<p>This is how our trigger Entity looks like:</p>
<p><img src="https://www.dropbox.com/s/njipx8mfsjsqcgj/tm_tut_physics_trigger_entity.png?dl=1" alt="" /></p>
<blockquote>
<p><strong>Note:</strong> The Box Entity will be displayed yellow because it is a prototype instance of the Entity within the <code>core/geometry/</code> folder. Any changes to this prototype will apply to this instance as well. </p>
</blockquote>
<h3 id="create-the-ball"><a class="header" href="#create-the-ball">Create the ball</a></h3>
<p>The Trigger is quite useless unless it can interact with something! That is why we want to shoot a ball from the Camera to the player.</p>
<p>Again the core comes to our rescue and provides us with a Sphere in the <code>core/geometry/</code>! We will use this for our ball!</p>
<p>We open the &quot;Special Objects&quot; folder and add a new Entity called &quot;Ball&quot;. With a double-click, we open it and add a &quot;Physics Shape&quot; and &quot;Physics Body&quot; Component. In the  &quot;Physics Shape Component,&quot; we leave the Type to Sphere. </p>
<blockquote>
<p><strong>Note:</strong> We can also visualize the Sphere Physics Shape in the Scene the same way we visualized them for the Box.</p>
</blockquote>
<p>After this, we need to ensure that our ball has CCD is enabled. Also, the Inertia Tensor should be set to 0.4, and Angular Damping should be set to 0.05.</p>
<p>Now that we have adjusted all the components let us add the actual ball. Again we can drag and drop the <code>sphere.entity</code> from the <code>core/geometry/</code> folder onto our Entity.</p>
<p><img src="https://www.dropbox.com/s/xd9gjg8pbw6p8kj/tm_tut_physics_core_gom.png?dl=1" alt="" /></p>
<h3 id="creating-the-scene"><a class="header" href="#creating-the-scene">Creating the Scene</a></h3>
<p>After we have nearly all the components to create our little Scene, all that is missing is the playground. The playground can be defined as just a plane with a trigger on it.</p>
<p>We can create a new Folder in the Asset Browser root and call it &quot;Scenes&quot;. In there, we create a new Entity and call it &quot;Triggers&quot;. We open this Entity.</p>
<p>The first thing we do is add a new Empty Child entity. We call it Floor or Plane. </p>
<blockquote>
<p><strong>Note:</strong> Right-click on the Main Entity &quot;Add Child Entity.&quot;</p>
</blockquote>
<p>We add a Physics Shape Component to this Entity and change its Type to Plane.</p>
<p>If we do not use the Physics Visualization mode, we see nothing in the Scene Tab. We can change this by adding a new Child Entity to our floor Entity. We right-click on the Plane / Floor Entity <strong>-&gt;Add Child Entity -&gt; From Asset</strong>, and we search for the Plane Entity. It is also located in the core.</p>
<p>When we look at the Scene Tab now, we see our new floor entity! Let us drag in our Trigger. We need to drag and drop the Trigger Entity from the Asset Browser in the Scene and adjust it with the Tools within the Scene Tab.</p>
<p>The result could look like this:</p>
<p><img src="https://www.dropbox.com/s/w4xqxvhcblinopu/tm_tut_physics_trigger_scene.png?dl=1" alt="" /></p>
<blockquote>
<p><strong>Note:</strong> We should add a Light Entity. Otherwise, it might be quite dark. Luckily the core has our back also here. We can just right-click the main Entity and <strong>Add Child Entity -&gt; From Asset -&gt; Light</strong>.</p>
</blockquote>
<h3 id="spawn-balls"><a class="header" href="#spawn-balls">Spawn balls</a></h3>
<p>The Scene itself is not what we want because we cannot spawn balls yet. To do this, we add a graph to the Scene itself.</p>
<p>In there, we add a &quot;Tick Event&quot; we need to poll every tick if the space key has was pressed. If you pressed space, we would spawn the ball from the camera direction. </p>
<p>We push the ball via &quot;Physx Push&quot; with a calculated velocity.</p>
<p><img src="https://www.dropbox.com/s/q9k4qp08lumgzef/tm_tut_physics_graph_spawn_ball.png?dl=1" alt="" /></p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>All of the above described &quot;code you can&quot; find when you download the Physics Sample projects from the Download Tab: <em><strong>Help -&gt; Download Sample Projects</strong></em> </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-truth"><a class="header" href="#the-truth">The Truth</a></h1>
<p>The Machinery uses a powerful data model to represent edited assets. This model has built-in support for serialization, streaming, copy/paste, drag-and-drop as well as unlimited undo/redo. It supports an advanced hierarchical prefab model for making derivative object instances and propagating changes. It even has full support for real-time collaboration. Multiple people can work together in the same game project, Google Docs-style. Since all of these features are built into the data model itself, your custom, game-specific data will get them automatically, without you having to write a line of code.</p>
<h2 id="the-data-model"><a class="header" href="#the-data-model">The Data Model</a></h2>
<p>The Machinery stores its data as <strong>objects with properties</strong>. Each object has a type and the type defines what properties the object has. Available property types are <em>bools, integers, floats, strings, buffers, references</em>, <em>sub-objects</em> and <em>sets of references or sub-objects</em>.</p>
<p>The object/properties model gives us us <em>forward and backward compatibility</em> and allows us to implement operations such as <em>cloning</em> without knowing any details about the data. We can also represent modifications to the data in a uniform way <code>(object, property, old-value, new-value)</code> for undo/redo and collaboration.</p>
<p>The model is <strong>memory-based</strong> rather than disk-based. I.e. the in-memory representation of the data is considered <em>authoritative.</em> Read/write access to the data is provided by a thread-safe API. If two systems want to co-operate, they do so by talking to the same in-memory model, not by sharing files on disk. Of course, we still need to save data out disk at some point for persistence, but this is just a “backup” of the memory model and we might use different disk formats for different purposes (i.e. a git-friendly representation for collaborative work vs single binary for solo projects).</p>
<p>Since we have a memory-based model which supports cloning and change tracking, copy/paste and undo can be defined in terms of the data model. Real-time collaboration is also supported, by serializing modifications and transmitting them over the network. Since the runtime has equal access to the data model, modifying the data from within a VR session is also possible.</p>
<p>We make a clear <strong>distinction between “buffer data” and “object data”</strong>. <em>Object data</em> is stuff that can be reasoned about on a per-property level. I.e. if user A changes one property of an object, and user B changes another, we can merge those changes. <em>Buffer data</em> are binary blobs of data that are opaque to the data model. We use it for large pieces of binary data, such as textures, meshes and sound files. Since the data model cannot reason about the content of these blobs it can’t for example merge changes made to the same texture by different users.</p>
<p>Making the distinction between buffer data and object data is important because we pay an overhead for representing data as objects. We only want to pay that overhead when the benefits outweigh the costs. Most of a game’s data (in terms of bytes) is found in things like textures, meshes, audio data, etc and does not really gain anything from being stored in a JSON-like object tree.</p>
<p>In The Truth, <strong>references are represented by IDs</strong>. Each object has a unique ID and we reference other objects by their IDs. Since references have their own property type in The Truth, it is easy for us to reason about references and find all the dependencies of an object.</p>
<p>Sub-objects in The Truth are references to <em>owned</em> objects. They work just as references, but have special behaviours in some situations. For examples, when an object is cloned, all its sub-objects will be cloned too, while its references will not.</p>
<p>For more information checkout the <a href="https://ourmachinery.com/apidoc/foundation/the_truth.h.html">documentation</a> and these blog posts: <a href="https://ourmachinery.com/post/the-story-behind-the-truth-designing-a-data-model/">The Story behind The Truth: Designing a Data Model</a>  or this <a href="https://ourmachinery.com/post/multi-threading-the-truth/">one</a>.</p>
<h2 id="tutorials-1"><a class="header" href="#tutorials-1">Tutorials</a></h2>
<p>This section shall introduce you to some more complex topics such as <a href="https://ourmachinery.github.io/themachinery-books/tutorials//the_truth/custom_asset/index.html"><em>How to create your own asset.</em></a></p>
<p>For more information checkout the <a href="https://ourmachinery.com/apidoc/foundation/the_truth.h.html">documentation</a> and these blog posts: <a href="https://ourmachinery.com/post/the-story-behind-the-truth-designing-a-data-model/">The Story behind The Truth: Designing a Data Model</a>  or this <a href="https://ourmachinery.com/post/multi-threading-the-truth/">one</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-custom-asset"><a class="header" href="#creating-a-custom-asset">Creating a custom asset</a></h1>
<p>This walkthrough series shows you how to add a custom asset to the Engine. You should have basic knowledge about how to write a custom plugin. If not, you might want to check this <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/extending_the_machinery/the_plugin_system.html">Guide</a>. The goal for this walkthrough is to write a text file asset.</p>
<p>In the parts 1 - 3 we will cover the following topics:</p>
<ul>
<li><a href="https://ourmachinery.github.io/themachinery-books/tutorials/the_truth/custom_asset/part1.html#creating-an-asset-the-truth-type">How to create your asset</a></li>
<li><a href="https://ourmachinery.github.io/themachinery-books/tutorials/the_truth/custom_asset/part1.html#what-is-the-difference-between-truth-type-and-asset">What is the difference between a Truth Type and an Asset?</a></li>
<li><a href="https://ourmachinery.github.io/themachinery-books/tutorials/the_truth/custom_asset/part1.html#appendix-adding-an-asset-via-code-to-the-asset-browser">Add a asset via code to the project</a></li>
<li><a href="https://ourmachinery.github.io/themachinery-books/tutorials/the_truth/custom_asset/part2.html#text-file-asset">How to associate data with your asset</a></li>
<li><a href="https://ourmachinery.github.io/themachinery-books/tutorials/the_truth/custom_asset/part2.html#custom-ui">How to add a custom UI to your asset</a></li>
<li><a href="https://ourmachinery.github.io/themachinery-books/tutorials/the_truth/custom_asset/part3.html#custom-importer-for-text-files">How to create your importer</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-a-custom-asset-part-1"><a class="header" href="#create-a-custom-asset-part-1">Create a custom asset part 1</a></h1>
<p>This walkthrough shows you how to add a custom asset to the Engine. You should have basic knowledge about how to write a custom plugin. If not, you might want to check this <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/extending_the_machinery/the_plugin_system.html">Guide</a>. The goal for this walkthrough is to write a text file asset.</p>
<p>In the parts 1 - 3 we will cover the following topics:</p>
<ul>
<li>How to create your asset</li>
<li>How to associate data with your asset</li>
<li>How to add a custom UI to your asset</li>
<li>How to create your importer</li>
</ul>
<p>This part will cover the following topics:</p>
<ul>
<li>What to think of in advance?</li>
<li>Creating an essential asset The Truth type</li>
<li>Being able to add the asset to the asset browser
<ul>
<li>Via context Menu</li>
<li>Via code</li>
</ul>
</li>
</ul>
<p>The next part will explore how to store more complex data in an asset file and how to get this data back into the Engine.</p>
<blockquote>
<p>You can find the whole source code in its git repo: <a href="https://github.com/simon-ourmachinery/example-text-file-asset">example-text-file-asset</a></p>
</blockquote>
<p><strong>Table of Content</strong></p>
<ul>
<li><a href="the_truth/custom_asset/part1.html#first-step-what-kind-of-asset-do-we-want-to-create">First step: What kind of asset do we want to create?</a></li>
<li><a href="the_truth/custom_asset/part1.html#creating-an-asset-the-truth-type">Creating an asset The Truth Type</a>
<ul>
<li><a href="the_truth/custom_asset/part1.html#what-is-the-difference-between-truth-type-and-asset">What is the difference between Truth Type and Asset?</a></li>
</ul>
</li>
<li><a href="the_truth/custom_asset/part1.html#making-the-asset-browser-able-to-create-it">Making the Asset Browser able to create it</a></li>
<li><a href="the_truth/custom_asset/part1.html#what-is-next">What is next?</a></li>
<li><a href="the_truth/custom_asset/part1.html#appendix-adding-an-asset-via-code-to-the-asset-browser">Appendix: Adding an asset via code to the Asset Browser</a></li>
<li><a href="the_truth/custom_asset/part1.html#full-example-of-basic-asset">Full example of basic asset</a></li>
</ul>
<h2 id="first-step-what-kind-of-asset-do-we-want-to-create"><a class="header" href="#first-step-what-kind-of-asset-do-we-want-to-create"><strong>First step:</strong> What kind of asset do we want to create?</a></h2>
<p>Sometimes it is needed to add a custom asset to the Engine to support different asset types which are not supported yet. The first step is that we need to decide what our asset shall represent. In this case, it will be a text file. Those decisions have some influence on the details of the implementation. How ever the steps discussed below are the same in any case.</p>
<h2 id="creating-an-asset-the-truth-type"><a class="header" href="#creating-an-asset-the-truth-type">Creating an asset The Truth Type</a></h2>
<p>The Engine needs to know that there shall be a new asset type. That is why we need to register a new Truth type. Those steps are the same for every truth type, be it an asset or not.</p>
<p>We need to define a globally accessible definition for the name of the type and its hash value. The usual place for this is a header file.</p>
<p>Example Header file: <code>my_asset.h</code></p>
<pre><code class="language-c">#pragma once
#include &quot;entity_api_types.h&quot;
//... more code
#define TM_TT_TYPE__MY_ASSET &quot;tm_my_asset&quot;
#define TM_TT_TYPE_HASH__MY_ASSET TM_STATIC_HASH(&quot;tm_my_asset&quot;, 0xc0995d6c144ac64aULL)
</code></pre>
<p>(Do not forget to run hash.exe when you create a <a href="https://ourmachinery.com/apidoc/foundation/api_types.h.html#tm_static_hash()">TM_STATIC_HASH</a>, mode information here.)</p>
<p>Now we need to define the layout of our asset type. We should always do this during plugin load. (<code>tm_load_plugin</code>) 
During this call we need to register a function to the <a href="https://ourmachinery.com/apidoc/foundation/the_truth.h.html#tm_the_truth_create_types_interface_name">TM_THE_TRUTH_CREATE_TYPES_INTERFACE_NAME</a> interface. 
This function is typically called <code>create_truth_types</code>, but its name can be arbitrary.</p>
<blockquote>
<p><strong>Note:</strong> An interface is an abstract structure that maps a struct (the interface) to a hash value/name. It allows for customization points. In The Machinery, the Engine uses this extensively.</p>
</blockquote>
<p>Example <code>tm_load_plugin</code> function for <code>my_asset.c</code></p>
<pre><code class="language-c">TM_DLL_EXPORT void tm_load_plugin(struct tm_api_registry_api *reg, bool load)
{
tm_add_or_remove_implementation(reg, load, TM_THE_TRUTH_CREATE_TYPES_INTERFACE_NAME, create_truth_types);
}
</code></pre>
<p>After we did this, let us implement the actual function. First, we need to create a Truth type:
We use the function <code>tm_the_truth_api-&gt;create_object_type(tm_the_truth_o *tt, const char *name, const tm_the_truth_property_definition_t *properties, uint32_t num_properties);</code> . This one will register in the Truth a new type with the name and the properties we give the type. </p>
<p>At this point, we have a normal The Truth type. But we wanted to create an asset! </p>
<h4 id="what-is-the-difference-between-truth-type-and-asset"><a class="header" href="#what-is-the-difference-between-truth-type-and-asset">What is the difference between Truth Type and Asset?</a></h4>
<p>An asset is just a normal truth type. The structure of an asset in the truth is defined in the <code>foundation/the_truth_assets.h</code>. An asset itself is, therefore, nothing else than a wrapper around our actual asset. It provides a generic interface to provide some standard information.</p>
<p>The structure of an asset type looks like this:</p>
<pre><code class="language-c">enum {
    // Name of the asset.
    TM_TT_PROP__ASSET__NAME, // string
    // Directory where the asset resides. For top-level assets, this is `NULL`.
    TM_TT_PROP__ASSET__DIRECTORY, // reference [[TM_TT_TYPE__ASSET_DIRECTORY]]
    // Labels applied to this asset.
    TM_TT_PROP__ASSET__UUID_LABELS, // subobject_set(UINT64_T) storing the UUID of the associated label.
    // Subobject with the actual data of the asset. The type of this subobject depends on the type
    // of data storedin this asset.
    TM_TT_PROP__ASSET__OBJECT, // subobject(*)
    // Thumbnail image associated with asset
    TM_TT_PROP__ASSET__THUMBNAIL, // buffer
};
</code></pre>
<p>The truth type of the text file we just created will live as a subobject of the Asset Truth Type in the property field: <a href="https://ourmachinery.com/apidoc/foundation/the_truth_assets.h.html#enumtm_tt_prop__asset">TM_TT_PROP__ASSET__OBJECT</a>.</p>
<p>Let us move on and go back and finish the definition of our type. Let us add a file extension to our type. All we need to do is add an aspect of type <a href="https://ourmachinery.com/apidoc/foundation/the_truth_assets.h.html#tm_tt_aspect__file_extension">TM_TT_ASPECT__FILE_EXTENSION</a> to our Truth Type. You can find it in the following header file <code>foundation/the_truth_assets.h</code>.</p>
<blockquote>
<p><strong>Note:</strong> The Machinery will automatically prefix your file extension with <strong>tm_</strong></p>
</blockquote>
<p>In code, this looks as follows:</p>
<pre><code class="language-c">static void create_truth_types(struct tm_the_truth_o *tt)
{
    const tm_tt_type_t type = tm_the_truth_api-&gt;create_object_type(tt, TM_TT_TYPE__MY_ASSET, 0, 0);
    tm_the_truth_api-&gt;set_aspect(tt, type, TM_TT_ASPECT__FILE_EXTENSION, &quot;my_asset&quot;);
}
</code></pre>
<p>We create a type of name <code>TM_TT_TYPE__MY_ASSET</code> with no properties and a file extension my_asset (<code>.tm_my_asset</code> in your explorer). </p>
<h2 id="making-the-asset-browser-able-to-create-it"><a class="header" href="#making-the-asset-browser-able-to-create-it">Making the Asset Browser able to create it</a></h2>
<p>Now that there is a basic asset type, you might want the asset browser to create it via the <code>New Asset</code> context menu. All you need to do is register the asset to the <a href="https://ourmachinery.com/apidoc/plugins/editor_views/asset_browser.h.html#tm_asset_browser_create_asset_interface_name">TM_ASSET_BROWSER_CREATE_ASSET_INTERFACE_NAME</a> interface. This interface requires an implementation of the type <a href="https://ourmachinery.com/apidoc/plugins/editor_views/asset_browser.h.html#structtm_asset_browser_create_asset_i">tm_asset_browser_create_asset_i</a>:</p>
<pre><code class="language-c">typedef struct tm_asset_browser_create_asset_i
{
    struct tm_asset_browser_create_asset_o *inst;
    // TM_LOCALIZE_LATER() name of menu option to display for creating the asset (e.g. &quot;New
    // Entity&quot;).
    const char *menu_name;
    // TM_LOCALIZE_LATER() name of the newly created asset (e.g. &quot;New Entity&quot;);
    const char *asset_name;
    // Create callback, should return The Truth ID for the newly created asset.
    tm_tt_id_t (*create)(struct tm_asset_browser_create_asset_o *inst, struct tm_the_truth_o *tt, tm_tt_undo_scope_t undo_scope);
} tm_asset_browser_create_asset_i;
</code></pre>
<p>Source: <code>plugins/editor_views/asset_browser.h</code></p>
<p>For our basic type, this interface can be defined as follows:</p>
<pre><code class="language-c">static tm_tt_id_t asset_browser_create(struct tm_asset_browser_create_asset_o *inst, tm_the_truth_o *tt, tm_tt_undo_scope_t undo_scope)
{
    const tm_tt_type_t type = tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE__MY_ASSET);
    return tm_the_truth_api-&gt;create_object_of_type(tt, type, undo_scope);
}

static tm_asset_browser_create_asset_i asset_browser_create_my_asset = {
    .menu_name = TM_LOCALIZE_LATER(&quot;New My Asset&quot;),
    .asset_name = TM_LOCALIZE_LATER(&quot;New My Asset&quot;),
    .create = asset_browser_create,
};
</code></pre>
<p>What is happening?</p>
<ul>
<li>In this case, the function <code>asset_browser_create</code> creates the object of our type. Here we could do more complex things if the asset were more complicated. </li>
<li>The <em>menu name</em> is for the context menu, while the <em>asset name</em> functions as the default asset name. </li>
</ul>
<p>Now we register our code to the interface. We do this also in the load plugin function.</p>
<p>Example <code>tm_load_plugin</code> function for <code>my_asset.c</code></p>
<pre><code class="language-c">TM_DLL_EXPORT void tm_load_plugin(struct tm_api_registry_api *reg, bool load)
{
tm_add_or_remove_implementation(reg, load, TM_THE_TRUTH_CREATE_TYPES_INTERFACE_NAME, create_truth_types);
   tm_add_or_remove_implementation(reg, load, TM_ASSET_BROWSER_CREATE_ASSET_INTERFACE_NAME, &amp;asset_browser_create_my_asset);
}
</code></pre>
<p>When we open the Engine, we can open the Asset Browser and create our asset:</p>
<p><img src="https://paper-attachments.dropbox.com/s_080D43F0A98EB2BE6BBB6D719C7B3B910F38D78674006103833AED0070469AD4_1609883533160_image.png" alt="" /></p>
<p>What happens is not existing! But we are getting there! Check out the <a href="the_truth/custom_asset/part1.html#">next part</a> for more complex and existing actions.</p>
<h2 id="what-is-next"><a class="header" href="#what-is-next">What is next?</a></h2>
<p>The next part will refactor the current code and show you how to make your code and asset more useful by implementing the action asset.</p>
<p><a href="https://ourmachinery.github.io/themachinery-books/tutorials//the_truth/custom_asset/part2.html">Part 2</a></p>
<h2 id="appendix-adding-an-asset-via-code-to-the-asset-browser"><a class="header" href="#appendix-adding-an-asset-via-code-to-the-asset-browser">Appendix: Adding an asset via code to the Asset Browser</a></h2>
<p>Sometimes it is necessary to create an asset via code. The Asset Browser plugin provides a solution for this the <a href="https://ourmachinery.com/apidoc/plugins/editor_views/asset_browser.h.html#structtm_asset_browser_add_asset_api">tm_asset_browser_add_asset_api</a>. With this API assets can be created and added to the current project.</p>
<p>To add an asset to the asset browser a few steps are needed. </p>
<ol>
<li>First, we need to pick the correct type. We need to request it from the truth via the type hash (in this example, <code>TM_TT_TYPE_HASH__MY_ASSET</code>). </li>
<li>Secondly, we should create an object of the correct type. </li>
<li>Then we can request the asset browser API if the API not globally accessible.</li>
</ol>
<blockquote>
<p>If we already requested the API, we do not need to do this step and can use the already defined instance of the API.</p>
</blockquote>
<ol start="4">
<li>We need to create a undo scope. (We could also use <a href="https://ourmachinery.com/apidoc/foundation/the_truth.h.html#tm_tt_no_undo_scope">TM_TT_NO_UNDO_SCOPE</a>) but its not recommended!</li>
<li>Then, we should decide if we should highlight the new asset in the Asset Browser. (<code>should_select=true</code>) If that's needed, an instance of the current UI is required. </li>
<li>Then, the magic can happen and we can call the function <code>add</code> of the <a href="https://ourmachinery.com/apidoc/plugins/editor_views/asset_browser.h.html#structtm_asset_browser_add_asset_api">tm_asset_browser_add_asset_api</a> </li>
</ol>
<p>The following code example will demonstrate how to add my_asset via code to the current project.</p>
<pre><code class="language-c">// ... other includes
#include &lt;foundation/the_truth.h&gt;
#include &lt;foundation/undo.h&gt;

#include &lt;plugins/editor_views/asset_browser.h&gt;

#include &quot;my_asset.h&quot;
//... other code

static void add_my_asset_to_project(tm_the_truth_o *tt,struct tm_ui_o *ui,const char*asset_name, tm_tt_id_t target_dir){
    const tm_tt_type_t my_asset_type_id= tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__MY_ASSET);
    const tm_tt_id_t asset_id = tm_the_truth_api-&gt;create_object_of_type(tt, my_asset_type_id, TM_TT_NO_UNDO_SCOPE);
tm_asset_browser_add_asset_api *add_asset = tm_global_api_registry-&gt;get(TM_ASSET_BROWSER_ADD_ASSET_API_NAME);
const tm_tt_undo_scope_t undo_scope = tm_the_truth_api-&gt;create_undo_scope(tt, TM_LOCALIZE(&quot;Add My Asset to Project&quot;));
bool should_select = true;
// we do not have any asset label therefore we do not need to pass them thats why the last
// 2 arguments are 0 and 0!
add_asset-&gt;add(add_asset-&gt;inst, target_dir, asset_id, asset_name, undo_scope,should_select,ui,0,0);
}
</code></pre>
<h2 id="full-example-of-basic-asset"><a class="header" href="#full-example-of-basic-asset">Full example of basic asset</a></h2>
<p><code>my_asset.h</code></p>
<pre><code class="language-c">#pragma once
#include &lt;foundation/api_types.h&gt;
//... more code
#define TM_TT_TYPE__MY_ASSET &quot;tm_my_asset&quot;
#define TM_TT_TYPE_HASH__MY_ASSET TM_STATIC_HASH(&quot;tm_my_asset&quot;, 0x1e12ba1f91b99960ULL)
</code></pre>
<p>(Do not forget to run hash.exe when you create a <a href="https://ourmachinery.com/apidoc/foundation/api_types.h.html#tm_static_hash()">TM_STATIC_HASH</a>)</p>
<p><code>my_asset.c</code></p>
<pre><code class="language-c">// -- api's
static struct tm_the_truth_api *tm_the_truth_api;
// -- inlcudes
#include &lt;foundation/api_registry.h&gt;
#include &lt;foundation/the_truth.h&gt;
#include &lt;foundation/undo.h&gt;
#include &lt;foundation/the_truth_assets.h&gt;
#include &lt;foundation/localizer.h&gt;

#include &lt;plugins/editor_views/asset_browser.h&gt;

#include &quot;my_asset.h&quot;

// -- create truth type
static void create_truth_types(struct tm_the_truth_o *tt)
{
    // we have properties this is why the last arguments are &quot;0, 0&quot;
    const tm_tt_type_t type = tm_the_truth_api-&gt;create_object_type(tt, TM_TT_TYPE__MY_ASSET, 0, 0);
    tm_the_truth_api-&gt;set_aspect(tt, type, TM_TT_ASPECT__FILE_EXTENSION, &quot;my_asset&quot;);
}

// -- asset browser regsiter interface
static tm_tt_id_t asset_browser_create(struct tm_asset_browser_create_asset_o *inst, tm_the_truth_o *tt, tm_tt_undo_scope_t undo_scope)
{
    const tm_tt_type_t type = tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__MY_ASSET);
    return tm_the_truth_api-&gt;create_object_of_type(tt, type, undo_scope);
}
static tm_asset_browser_create_asset_i asset_browser_create_my_asset = {
    .menu_name = TM_LOCALIZE_LATER(&quot;New My Asset&quot;),
    .asset_name = TM_LOCALIZE_LATER(&quot;New My Asset&quot;),
    .create = asset_browser_create,
};

// -- load plugin
TM_DLL_EXPORT void tm_load_plugin(struct tm_api_registry_api *reg, bool load)
{
    tm_the_truth_api = reg-&gt;get(TM_THE_TRUTH_API_NAME);
    tm_add_or_remove_implementation(reg, load, TM_THE_TRUTH_CREATE_TYPES_INTERFACE_NAME, create_truth_types);
    tm_add_or_remove_implementation(reg, load, TM_ASSET_BROWSER_CREATE_ASSET_INTERFACE_NAME, &amp;asset_browser_create_my_asset);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-a-custom-asset-part-2"><a class="header" href="#create-a-custom-asset-part-2">Create a custom asset part 2</a></h1>
<p>This walkthrough shows you how to add a custom asset to the Engine. You should have basic knowledge about how to write a custom plugin. If not, you might want to check this <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/extending_the_machinery/the_plugin_system.html">Guide</a>. The goal for this walkthrough is to write a text file asset.</p>
<p>This part will cover the following topics:</p>
<ul>
<li>How to store data in a buffer that is associated with the asset file</li>
<li>How to add a custom UI to be associated with the asset.</li>
</ul>
<p>When you have finished this part in the <a href="https://ourmachinery.github.io/themachinery-books/tutorials/the_truth/custom_asset/part3.html">next one</a>, we will show you how to write your importer.</p>
<blockquote>
<p>You can find the whole source code in its git repo: <a href="https://github.com/simon-ourmachinery/example-text-file-asset">example-text-file-asset</a></p>
</blockquote>
<p><strong>Table of Content</strong></p>
<ul>
<li><a href="the_truth/custom_asset/part2.html#extending-the-asset-the-truth-type">Extending the asset The Truth Type</a></li>
<li><a href="the_truth/custom_asset/part2.html#text-file-asset">Text file asset</a></li>
<li><a href="the_truth/custom_asset/part2.html#load-a-text-file">Load a text file</a>
<ul>
<li><a href="the_truth/custom_asset/part2.html#custom-ui">Custom UI</a></li>
</ul>
</li>
<li><a href="the_truth/custom_asset/part2.html#what-is-next">What is next?</a></li>
<li><a href="the_truth/custom_asset/part2.html#full-example-source-code">Full example source code</a></li>
</ul>
<h2 id="extending-the-asset-the-truth-type"><a class="header" href="#extending-the-asset-the-truth-type">Extending the asset The Truth Type</a></h2>
<p>The asset type we created is nice but it cannot do much. The Machinery can save anything to file that it can store in the Truth. This thought brings us back to the part: <strong>“What kind of asset do we want to create?”.</strong> </p>
<p>Let us go back to the basic definition of the type <code>my_asset</code>. We defined the type without any properties.</p>
<p>The current implementation looks as follows:</p>
<pre><code class="language-c">// -- create truth type
static void create_truth_types(struct tm_the_truth_o *tt)
{
    const tm_tt_type_t type = tm_the_truth_api-&gt;create_object_type(tt, TM_TT_TYPE__MY_ASSET, 0, 0);
    tm_the_truth_api-&gt;set_aspect(tt, type, TM_TT_ASPECT__FILE_EXTENSION, &quot;my_asset&quot;);
}
</code></pre>
<p>To make this more useful, what we can do is add some properties to the type. We can do this via an array of the type <a href="https://ourmachinery.com/apidoc/foundation/the_truth.h.html#structtm_the_truth_property_definition_t">tm_the_truth_property_definition_t</a>. In this array we can define all the properties we want. </p>
<h2 id="text-file-asset"><a class="header" href="#text-file-asset">Text file asset</a></h2>
<p>Now we are changing the <code>my_asset</code> to be able to store text in it. </p>
<p>First, we need to answer the question: <em>How is a text file defined?</em> </p>
<p>Well, a text file has three properties: </p>
<ol>
<li>It has a file name</li>
<li>A file path</li>
<li>data - A bunch of characters.</li>
</ol>
<p>Consequently, we are defining the <em>import path</em> property to “reimport” our text asset and the data property to store the imported text.</p>
<pre><code class="language-c">    static tm_the_truth_property_definition_t my_asset_properties[] = {
        { &quot;import_path&quot;, TM_THE_TRUTH_PROPERTY_TYPE_STRING },
        { &quot;data&quot;, TM_THE_TRUTH_PROPERTY_TYPE_BUFFER},
    };
</code></pre>
<blockquote>
<p><strong>Note:</strong> The type <a href="https://ourmachinery.com/apidoc/foundation/the_truth.h.html#structtm_the_truth_property_definition_t"><em>tm_the_truth_property_definition_t</em></a> has a lot more options. For example, is it possible to hide properties from the editor, etc. For more information, read the documentation <a href="https://ourmachinery.com/apidoc/foundation/the_truth.h.html#structtm_the_truth_property_definition_t"><em>here</em></a><em>.</em></p>
</blockquote>
<p>After we have thought about this, we need to provide the <code>create_object_type</code> function with the new information:</p>
<pre><code class="language-c">static void create_truth_types(struct tm_the_truth_o *tt)
{
    static tm_the_truth_property_definition_t my_asset_properties[] = {
        { &quot;import_path&quot;, TM_THE_TRUTH_PROPERTY_TYPE_STRING },
        { &quot;data&quot;, TM_THE_TRUTH_PROPERTY_TYPE_BUFFER},
    };
    const tm_tt_type_t type = tm_the_truth_api-&gt;create_object_type(tt, TM_TT_TYPE__MY_ASSET, my_asset_properties, 2);
    tm_the_truth_api-&gt;set_aspect(tt, type, TM_TT_ASPECT__FILE_EXTENSION, &quot;my_asset&quot;);
}
</code></pre>
<p>Now we should change the asset name to something more meaningful than <code>my_asset</code>. Lets call it <code>txt</code></p>
<p>The renaming has as a consequence that we need to change three places:</p>
<ul>
<li>Asset Name</li>
<li>Menu Name</li>
<li>File extension</li>
<li>The source file: <code>my_asset.c/h</code> -&gt; <code>txt.c/h</code></li>
</ul>
<p>This will change the code as follows:</p>
<pre><code class="language-c">//.. other code
static void create_truth_types(struct tm_the_truth_o *tt)
{
//... the other code
    tm_the_truth_api-&gt;set_aspect(tt, type, TM_TT_ASPECT__FILE_EXTENSION, &quot;txt&quot;);
}
// .. other code
static tm_asset_browser_create_asset_i asset_browser_create_my_asset = {
    .menu_name = TM_LOCALIZE_LATER(&quot;New Text File&quot;),
    .asset_name = TM_LOCALIZE_LATER(&quot;New Text File&quot;),
    .create = asset_browser_create,
};
</code></pre>
<p>Let's have a look at how it looks in the editor:</p>
<p><img src="https://paper-attachments.dropbox.com/s_892FB4725BEE1D4E7D7CCEA6A89558987964DFF4B0524E03B4E0F6FFCF6E0FED_1609926443262_image.png" alt="creating a new asset" /></p>
<h2 id="load-a-text-file"><a class="header" href="#load-a-text-file">Load a text file</a></h2>
<p>After creating a new asset, the asset looks as following in the editor:</p>
<p><img src="https://paper-attachments.dropbox.com/s_892FB4725BEE1D4E7D7CCEA6A89558987964DFF4B0524E03B4E0F6FFCF6E0FED_1609926772154_image.png" alt="" /></p>
<p>This asset file is still not quite how we want it because we have not loaded a text file yet. Therefore let us load a file next. At first, we will do it by <em>hand</em> via loading a file whenever we are changing the path, and then later on (in the next chapter) we are writing our importer. It will allow us to drag and drop files into the Engine as well or use the <em>Import Menu.</em></p>
<h3 id="custom-ui"><a class="header" href="#custom-ui">Custom UI</a></h3>
<p>To archive our first manual loading, we need to add a custom UI associated with our type. We can do this via the properties aspect <a href="https://ourmachinery.com/apidoc/plugins/editor_views/properties.h.html#tm_tt_aspect__properties">TM_TT_ASPECT__PROPERTIES</a>. It means we need to go back to the <code>create_truth_types</code> function and add a new Aspect and a new object associated with this Aspect.</p>
<p>The Aspect expects a <a href="https://ourmachinery.com/apidoc/plugins/editor_views/properties.h.html#structtm_properties_aspect_i">tm_properties_aspect_i</a> object. When defining the object, we are focused only on is the custom_ui field. </p>
<blockquote>
<p>Note: This struct has many different fields which are not interesting to us now. (If you want more information on them, check out the <a href="https://ourmachinery.com/apidoc/plugins/editor_views/properties.h.html#structtm_properties_aspect_i">documentation</a>.</p>
</blockquote>
<p>The <code>custom_ui</code> expected s function pointer of the type <code>float (*custom_ui)(struct tm_properties_ui_args_t *args, tm_rect_t item_rect, tm_tt_id_t object, uint32_t indent)</code>.</p>
<p>Let us quickly go over this:</p>
<p><em>Function Arguments:</em></p>
<table><thead><tr><th><strong>Argument</strong></th><th><strong>Data Type</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>1 (<code>args</code>)</td><td><a href="https://ourmachinery.com/apidoc/plugins/editor_views/properties.h.html#structtm_properties_ui_args_t">tm_properties_ui_args_t</a></td><td>A bundled type of important information. For example this is the way you would retrieve your ui instance as well as your uistyle instance. For more information check the <a href="https://ourmachinery.com/apidoc/plugins/editor_views/properties.h.html#structtm_properties_ui_args_t">documentation</a>.</td></tr>
<tr><td>2 (<code>item_rect</code>)</td><td><a href="https://ourmachinery.com/apidoc/foundation/api_types.h.html#structtm_rect_t">tm_rect_t</a></td><td>The ui rectangular of the current item. This can be manipulated in x,y as well as w and h as long as the correct y value is being returned.</td></tr>
<tr><td>3 (<code>object</code>)</td><td><a href="https://ourmachinery.com/apidoc/foundation/api_types.h.html#structtm_tt_id_t">tm_tt_id_t</a></td><td>The truth object id of the current object. Can be used to read information of.</td></tr>
<tr><td>4 (<code>indent</code>)</td><td><code>uint32_t</code></td><td>Used for intention.</td></tr>
</tbody></table>
<p><em>Return values</em></p>
<table><thead><tr><th><strong>Type</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>float</td><td>This is the being used as the next y value of the following element.</td></tr>
</tbody></table>
<p>We need to define a static instance of the <a href="https://ourmachinery.com/apidoc/plugins/editor_views/properties.h.html#structtm_properties_aspect_i">tm_properties_aspect_i*</a> and a custom UI function.</p>
<pre><code class="language-c">//.. other code
static float properties__custom_ui(struct tm_properties_ui_args_t *args, tm_rect_t item_rect, tm_tt_id_t object, uint32_t indent)
{
// -- code
}
//.. other code    
static tm_properties_aspect_i properties_aspect = {
        .custom_ui = properties__custom_ui,
    };
// .. other code
</code></pre>
<p>Now the properties aspect needs to know about the existence of our custom UI. It follows the same principle as the properties:</p>
<pre><code class="language-c">//.. other code
static void create_truth_types(struct tm_the_truth_o *tt)
{
//... the other code
    tm_the_truth_api-&gt;set_aspect(tt, type, TM_TT_ASPECT__PROPERTIES, &amp;properties_aspect);
}
//... the other code
</code></pre>
<p>In the editor, the change is imminently visible. The UI is gone because we have chosen to provide our custom UI.</p>
<p><img src="https://paper-attachments.dropbox.com/s_892FB4725BEE1D4E7D7CCEA6A89558987964DFF4B0524E03B4E0F6FFCF6E0FED_1609928409366_image.png" alt="" /></p>
<p>It is time to add the imported file property back to the UI panel. The first step is to think about what our property shall represent:
When we defined it, we described it as type <a href="https://ourmachinery.com/apidoc/foundation/the_truth.h.html#enumtm_the_truth_property_type">TM_THE_TRUTH_PROPERTY_TYPE_STRING</a>. 
It is essential to know because the <a href="https://ourmachinery.com/apidoc/plugins/editor_views/properties.h.html#properties.h">properties header file</a> has the <a href="https://ourmachinery.com/apidoc/plugins/editor_views/properties.h.html#structtm_properties_view_api">properties view API</a>, which has many built-in functions for default behavior.</p>
<p>One of the things we can find in there is the <a href="https://ourmachinery.com/apidoc/plugins/editor_views/properties.h.html#structtm_properties_view_api.ui_open_path()">ui_open_path</a> which sounds perfect for the import path. The buffer (data) does not need to be displayed yet. Before using any Properties-View API functions, we need to request the API in our load plugin function.</p>
<pre><code class="language-c">// -- api's
static struct tm_properties_view_api *tm_properties_view_api;
//.. other code 
// -- load plugin
TM_DLL_EXPORT void tm_load_plugin(struct tm_api_registry_api *reg, bool load)
{
//.. other code 
    tm_properties_view_api = reg-&gt;get(TM_PROPERTIES_VIEW_API_NAME);
//.. other code 
} 
</code></pre>
<p>Now we can use and implement the path opening function. Let us look at its <a href="https://ourmachinery.com/apidoc/plugins/editor_views/properties.h.html#structtm_properties_view_api.ui_open_path()">signature</a> first:</p>
<p><code>float (*ui_open_path)(struct tm_properties_ui_args_t *args, tm_rect_t item_rect, const char *name, const char *tooltip, tm_tt_id_t object, uint32_t property, const char *extensions, const char *description, bool *picked)</code></p>
<p><em>Function Arguments:</em></p>
<table><thead><tr><th><strong>Argument</strong></th><th><strong>Data Type</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>1 (<code>args</code>)</td><td><a href="https://ourmachinery.com/apidoc/plugins/editor_views/properties.h.html#structtm_properties_ui_args_t">tm_properties_ui_args_t</a></td><td>A bundled type of important information. For example this is the way you would retrieve your UI instance as well as your <code>uistyle</code> instance. For more information check the <a href="https://ourmachinery.com/apidoc/plugins/editor_views/properties.h.html#structtm_properties_ui_args_t">documentation</a>.</td></tr>
<tr><td>2 (<code>item_rect</code>)</td><td><a href="https://ourmachinery.com/apidoc/foundation/api_types.h.html#structtm_rect_t">tm_rect_t</a></td><td>The UI rectangular of the current item. This can be manipulated in x,y as well as w and h as long as the correct y value is being returned.</td></tr>
<tr><td>3 (<code>n</code>ame)</td><td><code>const char*</code></td><td>This is the name the Properties tab will display as the title in front of the text field.</td></tr>
<tr><td>4 (<code>t</code>ooltip)</td><td><code>const char*</code></td><td>Extra information if needed. (Optional)</td></tr>
<tr><td>5 (object)</td><td><a href="https://ourmachinery.com/apidoc/foundation/api_types.h.html#structtm_tt_id_t">tm_tt_id_t</a></td><td>The truth object id of the current object. Can be used to read information of.</td></tr>
<tr><td>6 (property)</td><td><code>uint32_t</code></td><td>Property index</td></tr>
<tr><td>7 (<code>extensions</code>)</td><td><code>const char*</code></td><td>List of potential file extension supported by the open dialog</td></tr>
<tr><td>8 (<code>description</code>)</td><td><code>const char*</code></td><td>List of descriptions for the potential file extensions</td></tr>
<tr><td>9 (picked)</td><td><code>bool*</code></td><td>Out pointer indicating if a file has been picked or not. (optional)</td></tr>
</tbody></table>
<p><em>Return values</em></p>
<table><thead><tr><th><strong>Type</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>float</td><td>This is the being used as the next y value of the following element.</td></tr>
</tbody></table>
<p>To implement the function all that's needed to remember is what index the property had.</p>
<pre><code class="language-c">    static tm_the_truth_property_definition_t my_asset_properties[] = {
        { &quot;import_path&quot;, TM_THE_TRUTH_PROPERTY_TYPE_STRING },
        { &quot;data&quot;, TM_THE_TRUTH_PROPERTY_TYPE_BUFFER},
    };
</code></pre>
<p>The index is 0 there for we are no ready to implement the function:</p>
<pre><code class="language-c">//custom ui
static float properties__custom_ui(struct tm_properties_ui_args_t *args, tm_rect_t item_rect, tm_tt_id_t object, uint32_t indent)
{
    // -- code
    bool picked = false;
    item_rect.y = tm_properties_view_api-&gt;ui_open_path(args, item_rect, &quot;Imported Path&quot;, &quot;Path that the text file was imported from.&quot;, object, 0, &quot;txt&quot;, &quot;text files&quot;, &amp;picked);
    if (picked)
    {
        // import...
    }
    return item_rect.y;
}
</code></pre>
<p>Remembering all of those indices is quite cucumbersome! Therefore, it is better to define an enum in our header file. Define an <code>enum</code> for each property <code>TM_TT_PROP__[NAME_OF_TYPE]__[NAME_OF_PROPERTY]</code></p>
<pre><code class="language-c">#pragma once
#include &lt;foundation/api_types.h&gt;
//... more code
#define TM_TT_TYPE__MY_ASSET &quot;tm_my_asset&quot;
#define TM_TT_TYPE_HASH__MY_ASSET TM_STATIC_HASH(&quot;tm_my_asset&quot;, 0x1e12ba1f91b99960ULL)

enum {
    TM_TT_PROP__MY_ASSET__FILE,
    TM_TT_PROP__MY_ASSET__DATA,
}
</code></pre>
<p>(<code>txt.h</code>)</p>
<p>When we compiled this we can test it in the engine, just by adding a new text file click on the Import Path:</p>
<p><img src="https://paper-attachments.dropbox.com/s_892FB4725BEE1D4E7D7CCEA6A89558987964DFF4B0524E03B4E0F6FFCF6E0FED_1609931496164_image.png" alt="" /></p>
<p>The next step is using the OS API to load a file from the disc and store it in the buffer. This process works after the same principle as adding the properties view API. </p>
<p>The OS API (<a href="https://ourmachinery.com/apidoc/foundation/os.h.html#structtm_os_api">tm_os_api</a>) lives in the <a href="https://ourmachinery.com/apidoc/foundation/os.h.html#os.h">os.h</a> and has a member called <a href="https://ourmachinery.com/apidoc/foundation/os.h.html#structtm_os_file_io_api">file_io</a>, allowing access to the <a href="https://ourmachinery.com/apidoc/foundation/os.h.html#structtm_os_file_io_api">tm_os_file_io_api</a>. With this API, we can read a file. The following example code shows how reading the file and storing it in a buffer could look like in this case. </p>
<pre><code class="language-c">//other includes
#include &lt;foundation/os.h&gt;
#include &lt;foundation/buffer.h&gt;
//.. other code
//custom ui
static float properties__custom_ui(struct tm_properties_ui_args_t *args, tm_rect_t item_rect, tm_tt_id_t object, uint32_t indent)
{
    tm_the_truth_o *tt = args-&gt;tt;
    bool picked = false;
    item_rect.y = tm_properties_view_api-&gt;ui_open_path(args, item_rect, TM_LOCALIZE_LATER(&quot;Import Path&quot;), TM_LOCALIZE_LATER(&quot;Path that the text file was imported from.&quot;), object, TM_TT_PROP__MY_ASSET__FILE, &quot;txt&quot;, &quot;text files&quot;, &amp;picked);
    if (picked)
    {
        const char *file = tm_the_truth_api-&gt;get_string(tt, tm_tt_read(tt, object), TM_TT_PROP__MY_ASSET__FILE);

        tm_file_stat_t stat = tm_os_api-&gt;file_system-&gt;stat(file);

        tm_buffers_i *buffers = tm_the_truth_api-&gt;buffers(tt);
        void *buffer = buffers-&gt;allocate(buffers-&gt;inst, stat.size, false);

        tm_file_o f = tm_os_api-&gt;file_io-&gt;open_input(file);
        tm_os_api-&gt;file_io-&gt;read(f, buffer, stat.size);
        tm_os_api-&gt;file_io-&gt;close(f);

        const uint32_t buffer_id = buffers-&gt;add(buffers-&gt;inst, buffer, stat.size, 0);
        tm_the_truth_object_o *asset_obj = tm_the_truth_api-&gt;write(tt, object);
        tm_the_truth_api-&gt;set_buffer(tt, asset_obj, TM_TT_PROP__MY_ASSET__DATA, buffer_id); // 1 = data property index.
        tm_the_truth_api-&gt;commit(tt, asset_obj, TM_TT_NO_UNDO_SCOPE);
    }
    return item_rect.y;
}
</code></pre>
<p>First, we need to read out the file path from our The Truth object. After that, we can create the buffer we want to add to our <em>data</em> property (index 1 or <code>TM_TT_PROP___MY_ASSET__DATA</code>). 
The buffers live in the <a href="https://ourmachinery.com/apidoc/foundation/buffer.h.html#buffer.h">buffer.h</a>. We create the buffer via The Truth, and it also owns the memory. We are using the <a href="https://ourmachinery.com/apidoc/foundation/os.h.html#structtm_os_file_system_api">file_system API</a> to get the size of the text file. We need to know how big the file is to understand how big the buffer should be. </p>
<blockquote>
<p>Note: We should also check if the file exists. It has been left out because we just picked the file. </p>
</blockquote>
<p>Then we are reading the file from the disc and store its content in the allocated buffer. The next step is to add the buffer to the Truth buffers via the <a href="https://ourmachinery.com/apidoc/foundation/buffer.h.html#structtm_buffers_i.add()">buffers-&gt;add(buffers-&gt;inst, buffer, stat.size, 0);</a> call. It adds a buffer containing the specified data of size. It returns an ID identifying the new buffer. For more information, read <a href="https://ourmachinery.com/apidoc/foundation/buffer.h.html#structtm_buffers_i.add()">here</a>.</p>
<p>Now we need to ask the Truth to give us a writeable object. Objects from the Truth are immutable in their default state and can only be made mutable by asking explicitly for a writable object.
This happens via the <a href="https://ourmachinery.com/apidoc/foundation/the_truth.h.html#structtm_the_truth_api.write()">tm_the_truth_object_o *asset_obj = tm_the_truth_api-&gt;write(tt, object);</a> call.</p>
<p>With the writeable object, we can set the buffer, and then we can commit the changes to the Truth itself.</p>
<p>This iteration is the first, but the issue with it is that we cannot import or drag and drop a .txt file into the Engine. We will tackle this issue in the <a href="the_truth/custom_asset/part2.html#">next part</a>.</p>
<h2 id="what-is-next-1"><a class="header" href="#what-is-next-1">What is next?</a></h2>
<p>The next part will refactor the current code and show you how to make your code and asset more useful by showing you how to program an importer.</p>
<p><a href="the_truth/custom_asset/part2.html#">Part 3</a></p>
<h2 id="full-example-source-code"><a class="header" href="#full-example-source-code">Full example source code</a></h2>
<p><code>txt.h</code></p>
<pre><code class="language-c">#pragma once
#include &lt;foundation/api_types.h&gt;
//... more code
#define TM_TT_TYPE__MY_ASSET &quot;tm_my_asset&quot;
#define TM_TT_TYPE_HASH__MY_ASSET TM_STATIC_HASH(&quot;tm_my_asset&quot;, 0x1e12ba1f91b99960ULL)

enum {
    TM_TT_PROP__MY_ASSET__FILE,
    TM_TT_PROP__MY_ASSET__DATA,
};
</code></pre>
<p><code>txt.c</code></p>
<pre><code class="language-c">// -- api's
static struct tm_the_truth_api *tm_the_truth_api;
static struct tm_properties_view_api *tm_properties_view_api;
static struct tm_os_api *tm_os_api;
// -- inlcudes
#include &lt;foundation/api_registry.h&gt;
#include &lt;foundation/the_truth.h&gt;
#include &lt;foundation/undo.h&gt;
#include &lt;foundation/the_truth_assets.h&gt;
#include &lt;foundation/localizer.h&gt;
#include &lt;foundation/macros.h&gt;
#include &lt;foundation/os.h&gt;
#include &lt;foundation/buffer.h&gt;

#include &lt;plugins/editor_views/asset_browser.h&gt;
#include &lt;plugins/editor_views/properties.h&gt;

#include &quot;txt.h&quot;

//custom ui
static float properties__custom_ui(struct tm_properties_ui_args_t *args, tm_rect_t item_rect, tm_tt_id_t object, uint32_t indent)
{
    tm_the_truth_o *tt = args-&gt;tt;
    bool picked = false;
    item_rect.y = tm_properties_view_api-&gt;ui_open_path(args, item_rect, TM_LOCALIZE_LATER(&quot;Import Path&quot;), TM_LOCALIZE_LATER(&quot;Path that the text file was imported from.&quot;), object, TM_TT_PROP__MY_ASSET__FILE, &quot;txt&quot;, &quot;text files&quot;, &amp;picked);
    if (picked)
    {
        const char *file = tm_the_truth_api-&gt;get_string(tt, tm_tt_read(tt, object), TM_TT_PROP__MY_ASSET__FILE);
        tm_file_stat_t stat = tm_os_api-&gt;file_system-&gt;stat(file);
        tm_buffers_i *buffers = tm_the_truth_api-&gt;buffers(tt);
        void *buffer = buffers-&gt;allocate(buffers-&gt;inst, stat.size, false);
        tm_file_o f = tm_os_api-&gt;file_io-&gt;open_input(file);
        tm_os_api-&gt;file_io-&gt;read(f, buffer, stat.size);
        tm_os_api-&gt;file_io-&gt;close(f);
        const uint32_t buffer_id = buffers-&gt;add(buffers-&gt;inst, buffer, stat.size, 0);
        tm_the_truth_object_o *asset_obj = tm_the_truth_api-&gt;write(tt, object);
        tm_the_truth_api-&gt;set_buffer(tt, asset_obj, TM_TT_PROP__MY_ASSET__DATA, buffer_id);
        tm_the_truth_api-&gt;commit(tt, asset_obj, TM_TT_NO_UNDO_SCOPE);
    }
    return item_rect.y;
}
// -- create truth type
static void create_truth_types(struct tm_the_truth_o *tt)
{
    static tm_the_truth_property_definition_t my_asset_properties[] = {
        {&quot;import_path&quot;, TM_THE_TRUTH_PROPERTY_TYPE_STRING},
        {&quot;data&quot;, TM_THE_TRUTH_PROPERTY_TYPE_BUFFER},
    };
    const tm_tt_type_t type = tm_the_truth_api-&gt;create_object_type(tt, TM_TT_TYPE__MY_ASSET, my_asset_properties, TM_ARRAY_COUNT(my_asset_properties));
    tm_the_truth_api-&gt;set_aspect(tt, type, TM_TT_ASPECT__FILE_EXTENSION, &quot;txt&quot;);
    static tm_properties_aspect_i properties_aspect = {
        .custom_ui = properties__custom_ui,
    };
    tm_the_truth_api-&gt;set_aspect(tt, type, TM_TT_ASPECT__PROPERTIES, &amp;properties_aspect);
}
// -- asset browser regsiter interface
static tm_tt_id_t asset_browser_create(struct tm_asset_browser_create_asset_o *inst, tm_the_truth_o *tt, tm_tt_undo_scope_t undo_scope)
{
    const tm_tt_type_t type = tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__MY_ASSET);
    return tm_the_truth_api-&gt;create_object_of_type(tt, type, undo_scope);
}
static tm_asset_browser_create_asset_i asset_browser_create_my_asset = {
    .menu_name = TM_LOCALIZE_LATER(&quot;New Text File&quot;),
    .asset_name = TM_LOCALIZE_LATER(&quot;New Text File&quot;),
    .create = asset_browser_create,
};
// -- load plugin
TM_DLL_EXPORT void tm_load_plugin(struct tm_api_registry_api *reg, bool load)
{
    tm_the_truth_api = reg-&gt;get(TM_THE_TRUTH_API_NAME);
    tm_properties_view_api = reg-&gt;get(TM_PROPERTIES_VIEW_API_NAME);
    tm_os_api = reg-&gt;get(TM_OS_API_NAME);
    tm_add_or_remove_implementation(reg, load, TM_THE_TRUTH_CREATE_TYPES_INTERFACE_NAME, create_truth_types);
    tm_add_or_remove_implementation(reg, load, TM_ASSET_BROWSER_CREATE_ASSET_INTERFACE_NAME, &amp;asset_browser_create_my_asset);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-a-custom-asset-part-3"><a class="header" href="#create-a-custom-asset-part-3">Create a custom asset part 3</a></h1>
<p>This walkthrough shows you how to add a custom asset to the Engine. You should have basic knowledge about how to write a custom plugin. If not, you might want to check this <a href="https://ourmachinery.github.io/themachinery-books/the_machinery_book/extending_the_machinery/the_plugin_system.html">Guide</a>. The goal for this walkthrough is to write a text file asset.</p>
<p>This part will cover the following topics:</p>
<ul>
<li>How to write an importer</li>
</ul>
<blockquote>
<p>You can find the whole source code in its git repo: <a href="https://github.com/simon-ourmachinery/example-text-file-asset">example-text-file-asset</a></p>
</blockquote>
<p><strong>Table of Content</strong></p>
<ul>
<li><a href="the_truth/custom_asset/part3.html#custom-importer-for-text-files">Custom importer for text files</a></li>
<li><a href="the_truth/custom_asset/part3.html#import-task-set-up">Import Task set up</a></li>
<li><a href="the_truth/custom_asset/part3.html#import-task-implementation">Import task implementation</a></li>
<li><a href="the_truth/custom_asset/part3.html#enabling-reimport">Enabling reimport</a></li>
<li><a href="the_truth/custom_asset/part3.html#refactor-the-custom-ui-import-functionality">Refactor the Custom UI import functionality</a></li>
<li><a href="the_truth/custom_asset/part3.html#the-end">The end</a></li>
</ul>
<h2 id="custom-importer-for-text-files"><a class="header" href="#custom-importer-for-text-files">Custom importer for text files</a></h2>
<p>In this part, we are adding the ability to import a text file into the Engine. To implement an importer, we need the following APIs:</p>
<table><thead><tr><th><strong>Name</strong></th><th><strong>header file</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>tm_asset_io_api</td><td>foundation/asset_io.h</td><td>This api provides us with the interface for the actual importer.</td></tr>
<tr><td>tm_temp_allocator_api</td><td>foundation/temp_allocator.h</td><td>Provides a easy way to allocate temporary memory.</td></tr>
<tr><td>tm_allocator_api</td><td>foundation/allocator.h</td><td>Allows us access to different kind of allocators. For example to the system allocator. We need this one later when we rewrite our reimport.</td></tr>
<tr><td>tm_path_api</td><td>foundation/path.h</td><td>Allows us to split a path.</td></tr>
<tr><td>tm_api_registry_api</td><td>foundation/api_registry.h</td><td>Allows us to retrive a API from the registry.</td></tr>
<tr><td>tm_task_system_api</td><td>foundation/task_system.h</td><td>Allowes us to spawm tasks</td></tr>
</tbody></table>
<p>After we have included all the needed header files and retrieved all the APIs from the registry, we can start to write an importer.</p>
<blockquote>
<p>Note: <a href="https://ourmachinery.com/apidoc/foundation/api_registry.h.html#structtm_api_registry_api">tm_api_registry_api</a> can be retrived from the reg parameter in the <code>tm_load_plugin</code> function. <code>tm_global_api_registry = reg;</code></p>
</blockquote>
<p>The Machinery has a generic interface for asset importers. It requires a bunch of functions to be able to work as intended. The struct we need to implement is called <a href="https://ourmachinery.com/apidoc/foundation/asset_io.h.html#structtm_asset_io_import">tm_asset_io_i</a>. It requires us to set the following members:</p>
<table><thead><tr><th>Member</th><th>Description</th></tr></thead><tbody>
<tr><td>enabled</td><td>A function ptr that returns a bool. If the return value is true the importer is active.</td></tr>
<tr><td>can_import</td><td>A function ptr that returns <code>true</code> if this asset IO interface can import archives with the file extension <code>extension</code>. This can be achieved by comparing the file extesions.<br><br>Optional, if not implemented, nothing can be imported.</td></tr>
<tr><td>can_reimport</td><td>A function ptr that returns <code>true</code> if this asset IO interface can re-import the specified truth asset (of type <code>TM_TT_TYPE_ASSET</code>). Optional, if not implemented, nothing can be re-importe</td></tr>
<tr><td>importer_extensions_string</td><td>A function ptr that shall append the correct file extention string to the list of possible file extenstions</td></tr>
<tr><td>importer_description_string</td><td>A function ptr that shall append the correct file extention descriptions string to the list of possible file extenstions descriptions.</td></tr>
<tr><td>import_asset</td><td>The actual function that starts a import task. If non-zero, the return value is the ID of the background task from <a href="https://ourmachinery.com/apidoc/foundation/task_system.h.html#structtm_task_system_api">tm_task_system_api</a> that does the import.</td></tr>
</tbody></table>
<p>All these members expect a function pointer. Therefore, we need to provide the functionality.</p>
<p>To implement the first functions, we need to do the following steps:</p>
<pre><code class="language-c">//... other includes
#include &lt;foundation/carray_print.inl&gt;
#include &lt;foundation/string.inl&gt;
#include &lt;foundation/localizer.h&gt;
//... other code
static bool asset_io__enabled(struct tm_asset_io_o *inst)
{
    return true;
}
static bool asset_io__can_import(struct tm_asset_io_o *inst, const char *extension)
{
    return tm_strcmp_ignore_case(extension, &quot;txt&quot;) == 0;
}
static bool asset_io__can_reimport(struct tm_asset_io_o *inst, struct tm_the_truth_o *tt, tm_tt_id_t asset)
{
    const tm_tt_id_t object = tm_the_truth_api-&gt;get_subobject(tt, tm_tt_read(tt, asset), TM_TT_PROP__ASSET__OBJECT);
    return tm_tt_type(object).u64 == tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__MY_ASSET).u64;
}
static void asset_io__importer_extensions_string(struct tm_asset_io_o *inst, char **output, struct tm_temp_allocator_i *ta, const char *separator)
{
    tm_carray_temp_printf(output, ta, &quot;txt&quot;);
}
static void asset_io__importer_description_string(struct tm_asset_io_o *inst, char **output, struct tm_temp_allocator_i *ta, const char *separator)
{
    tm_carray_temp_printf(output, ta, &quot;.txt&quot;);
}
</code></pre>
<p>Let us go through them:</p>
<ul>
<li>The <code>enabled</code> function returns true because we want the importer to work. </li>
<li>The <code>asset_io__can_import</code> will compare the given extension with the one we want to support.</li>
</ul>
<blockquote>
<p>Note: <a href="https://ourmachinery.com/apidoc/foundation/string.inl.html#tm_strcmp_ignore_case()">tm_strcmp_ignore_case</a> requires a localizer. That is why we need the localizer API and the localizer header file. It is not needed if the importer shall be case-sensitive.</p>
</blockquote>
<ul>
<li>The <code>asset_io__can_reimport</code> compares the object type of the given object with the object of our type. </li>
</ul>
<blockquote>
<p><a href="https://ourmachinery.com/apidoc/foundation/the_truth_assets.h.html#enumtm_tt_prop__asset">TM_TT_PROP__ASSET__OBJECT</a> is the property of the <a href="https://ourmachinery.com/apidoc/foundation/the_truth_assets.h.html#tm_tt_type__asset">TM_TT_TYPE__ASSET</a> type which holds the object associated with the asset.</p>
</blockquote>
<p>The last two functions will append the file extension <code>.txt</code> to the file extensions and description. Note that the argument output is a <a href="https://ourmachinery.com/apidoc/foundation/carray.inl.html#carray.inl">carray</a>. That is why we can use the <a href="https://ourmachinery.com/apidoc/foundation/carray_print.inl.html#tm_carray_temp_printf()">tm_carray_temp_printf</a> function.</p>
<blockquote>
<p>Note: The <code>carray_print.h</code> requires the <a href="https://ourmachinery.com/apidoc/foundation/sprintf.h.html#structtm_sprintf_api">tm_sprintf_api</a>. Therefore, we need to include the right header here.</p>
</blockquote>
<h2 id="import-task-set-up"><a class="header" href="#import-task-set-up">Import Task set up</a></h2>
<p>The importer function <code>asset_io__import_asset</code> can spawn a task with the task system and pass through the needed information. We need to create a data structure to hold all our data.</p>
<p><em>What data does our task need?</em> </p>
<p>This task needs to know where to find the file. Moreover it needs to access some essential types such as the Truth and allocator. The struct could look like this:</p>
<pre><code class="language-c">struct task__import_txt
{
    uint64_t bytes;
    struct tm_asset_io_import args;
    char file[8];
};
</code></pre>
<p>The <code>asset_io</code> header has a nice utility struct predefined the <a href="https://ourmachinery.com/apidoc/foundation/asset_io.h.html#structtm_asset_io_import">tm_asset_io_import</a>. When an asset is being imported the caller of the  <code>asset_io__import_asset()</code> will hand through all the needed details: </p>
<ul>
<li>The right Truth object</li>
<li>the correct allocator. </li>
</ul>
<p>The function itself looks like this:</p>
<pre><code class="language-c">// .. other code
static uint64_t asset_io__import_asset(struct tm_asset_io_o *inst, const char *file, const struct tm_asset_io_import *args)
{
    const uint64_t bytes = sizeof(struct task__import_txt) + strlen(file);
    struct task__import_txt *task = tm_alloc(args-&gt;allocator, bytes);
    *task = (struct task__import_txt){
        .bytes = bytes,
        .args = *args,
    };
    strcpy(task-&gt;file, file);
    return task_system-&gt;run_task(task__import_txt, task, &quot;Import Text File&quot;);
}
</code></pre>
<blockquote>
<p><strong>Important</strong>: The task is the memory owner and needs to clean it up at the end of the execution!</p>
</blockquote>
<p>This line <code>task_system-&gt;run_task(task__import_txt, task, &quot;Import Text File&quot;);</code> will run a task and return its id. The actual task is the function <code>task__import_txt()</code>. </p>
<blockquote>
<p>Info: For more information on the task system check the <a href="https://ourmachinery.com/apidoc/foundation/task_system.h.html#structtm_task_system_api.run_task()">documentation</a>.</p>
</blockquote>
<h2 id="import-task-implementation"><a class="header" href="#import-task-implementation">Import task implementation</a></h2>
<p>The import task has the function to import data and clean up afterward.</p>
<p>It may look like this:</p>
<pre><code class="language-c">static void task__import_txt(void *data, uint64_t task_id)
{
// all our work
}
</code></pre>
<p>The data <code>ptr</code> needs to be cast into our defined data type: <code>task__import_txt</code>. You could use the task id to update its progress. We do not need to do it in this example.</p>
<blockquote>
<p>For more information on how to update the status of a task. It will be shown in the editor check out the <a href="https://ourmachinery.com/apidoc/foundation/progress_report.h.html#structtm_progress_report_api">documentation</a>.</p>
</blockquote>
<p>We are left with the following steps:</p>
<ul>
<li>Implement the actual importing (similar to the previous chapter).</li>
<li>Implement the reimport.</li>
</ul>
<p>First, we need to retrieve the basic information from the task data:</p>
<pre><code class="language-c">static void task__import_txt(void *data, uint64_t task_id)
{
    struct task__import_txt *task = (struct task__import_txt *)data;
    const struct tm_asset_io_import *args = &amp;task-&gt;args;
    const char *txt_file = task-&gt;file;
    tm_the_truth_o *tt = args-&gt;tt;
//.. more
}
</code></pre>
<p>After that, we implement the same code as in the previous chapter. We need to open the file, allocate a buffer and add the buffer to the object, either a new one (import) or an existing one (reimport).</p>
<p><strong>An important note is to do this time error checking</strong>: </p>
<ul>
<li>Does the file exist? </li>
<li>Does the file size match with the read file? </li>
</ul>
<p>To ask those questions is vital because we are in the async territory. In case of an error, we want to inform the user. Therefore, we need to get the logging API (<code>tm_logger_api = reg-&gt;get(TM_LOGGER_API_NAME);</code>) as well. You can find it in the <code>foundation/log.h</code> file.</p>
<p>The subsequent step is to check if the file exists. You can do this through the filesystem API:</p>
<pre><code class="language-c">static void task__import_txt(void *data, uint64_t task_id)
{
    struct task__import_txt *task = (struct task__import_txt *)data;
    const struct tm_asset_io_import *args = &amp;task-&gt;args;
    const char *txt_file = task-&gt;file;
    tm_the_truth_o *tt = args-&gt;tt;
    tm_file_stat_t stat = tm_os_api-&gt;file_system-&gt;stat(txt_file);
    if (stat.exists)
    {
    // .. code
    else
    {
        tm_logger_api-&gt;printf(TM_LOG_TYPE_INFO, &quot;import txt:cound not find %s \n&quot;, txt_file);
    }
}
</code></pre>
<p>Now we combine all the knowledge from this chapter and the previous chapter. We need to create a new asset via code for the import, and for the reimport, we need to update an existing file. 
Before we do all of this, let us first read the file and create the buffer.</p>
<pre><code class="language-c">static void task__import_txt(void *data, uint64_t task_id)
{
    struct task__import_txt *task = (struct task__import_txt *)data;
    const struct tm_asset_io_import *args = &amp;task-&gt;args;
    const char *txt_file = task-&gt;file;
    tm_the_truth_o *tt = args-&gt;tt;
    tm_file_stat_t stat = tm_os_api-&gt;file_system-&gt;stat(txt_file);
    if (stat.exists)
    {
        tm_buffers_i *buffers = tm_the_truth_api-&gt;buffers(tt);
        void *buffer = buffers-&gt;allocate(buffers-&gt;inst, stat.size, false);
        tm_file_o f = tm_os_api-&gt;file_io-&gt;open_input(txt_file);
        const int64_t read = tm_os_api-&gt;file_io-&gt;read(f, buffer, stat.size);
        tm_os_api-&gt;file_io-&gt;close(f);
// ..code
    else
    {
        tm_logger_api-&gt;printf(TM_LOG_TYPE_INFO, &quot;import txt:cound not find %s \n&quot;, txt_file);
    }
}
</code></pre>
<p>After this, we should ensure that the file size matches the size of the read data.</p>
<pre><code class="language-c">static void task__import_txt(void *data, uint64_t task_id)
{
    struct task__import_txt *task = (struct task__import_txt *)data;
    const struct tm_asset_io_import *args = &amp;task-&gt;args;
    const char *txt_file = task-&gt;file;
    tm_the_truth_o *tt = args-&gt;tt;
    tm_file_stat_t stat = tm_os_api-&gt;file_system-&gt;stat(txt_file);
    if (stat.exists)
    {
        tm_buffers_i *buffers = tm_the_truth_api-&gt;buffers(tt);
        void *buffer = buffers-&gt;allocate(buffers-&gt;inst, stat.size, false);
        tm_file_o f = tm_os_api-&gt;file_io-&gt;open_input(txt_file);
        const int64_t read = tm_os_api-&gt;file_io-&gt;read(f, buffer, stat.size);
        tm_os_api-&gt;file_io-&gt;close(f);
        if (read == (int64_t)stat.size)
        {
        // ..code
        }
        else
        {
            tm_logger_api-&gt;printf(TM_LOG_TYPE_INFO, &quot;import txt:cound not read %s\n&quot;, txt_file);
        }
    else
    {
        tm_logger_api-&gt;printf(TM_LOG_TYPE_INFO, &quot;import txt:cound not find %s \n&quot;, txt_file);
    }
}
</code></pre>
<p>With this out of the way, we can use our knowledge from the [last part](#): </p>
<ul>
<li>How to add an asset via code.</li>
</ul>
<p>The first step was to create the new object and add the data to it.</p>
<pre><code class="language-c">const uint32_t buffer_id = buffers-&gt;add(buffers-&gt;inst, buffer, stat.size, 0);
const tm_tt_type_t plugin_asset_type = tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__MY_ASSET);
const tm_tt_id_t asset_id = tm_the_truth_api-&gt;create_object_of_type(tt, plugin_asset_type, TM_TT_NO_UNDO_SCOPE);
tm_the_truth_object_o *asset_obj = tm_the_truth_api-&gt;write(tt, asset_id);
tm_the_truth_api-&gt;set_buffer(tt, asset_obj, TM_TT_PROP__MY_ASSET__DATA, buffer_id);
tm_the_truth_api-&gt;set_string(tt, asset_obj, TM_TT_PROP__MY_ASSET__FILE, txt_file);
 tm_the_truth_api-&gt;commit(tt, asset_obj, args-&gt;undo_scope);
</code></pre>
<p>After that, we are using the <a href="https://ourmachinery.com/apidoc/plugins/editor_views/asset_browser.h.html#structtm_asset_browser_add_asset_api">tm_asset_browser_add_asset_api</a> to add the asset to the asset browser. </p>
<pre><code class="language-c">tm_asset_browser_add_asset_api *add_asset = tm_global_api_registry-&gt;get(TM_ASSET_BROWSER_ADD_ASSET_API_NAME);
</code></pre>
<p>We are getting the API first, because we do not need it anywhere else than in this case. Then we need to extract the file name of the imported file. You can do this with the <em>path API</em>'s <code> tm_path_api-&gt;base()</code> function. Be aware this function requires a <a href="https://ourmachinery.com/apidoc/foundation/api_types.h.html#structtm_str_t">tm_str_t</a> which you an create from a normal c string (<code>const char*</code>) via <code>tm_str()</code>. To access the underlaying c string again just call <code>.data</code> on the <a href="https://ourmachinery.com/apidoc/foundation/api_types.h.html#structtm_str_t">tm_str_t</a>.</p>
<blockquote>
<p>Used to represent a string slice with pointer and length.</p>
<p>This lets you reason about parts of a string, which you are not able to do with standard NULL-terminated strings.</p>
<p><a href="https://ourmachinery.com/apidoc/foundation/api_types.h.html#structtm_str_t">documentation</a></p>
</blockquote>
<p>After this step we need to get the current folder. Therefore we are asking the <a href="https://ourmachinery.com/apidoc/plugins/editor_views/asset_browser.h.html#structtm_asset_browser_add_asset_api">tm_asset_browser_add_asset_api</a> what the current folder is. Then we decide if want to select the file. At the end we are calling add function of the <code>tm_asset_browser_add_asset_api-&gt;add()</code>. </p>
<blockquote>
<p><strong>Note:</strong> We do not have any asset labels for our current asset therefore we do not pass them to the add function, otherwise the last 2 arguments would be different than <code>0</code> and <code>0</code>.</p>
</blockquote>
<pre><code class="language-c">                const char *asset_name = tm_path_api-&gt;base(tm_str(txt_file)).data;
                tm_asset_browser_add_asset_api *add_asset = tm_global_api_registry-&gt;get(TM_ASSET_BROWSER_ADD_ASSET_API_NAME);
                const tm_tt_id_t current_dir = add_asset-&gt;current_directory(add_asset-&gt;inst, args-&gt;ui);
                const bool should_select = args-&gt;asset_browser.u64 &amp;&amp; tm_the_truth_api-&gt;version(tt, args-&gt;asset_browser) == args-&gt;asset_browser_version_at_start;
                // we do not have any asset label therefore we do not need to pass them thats why the last
                // 2 arguments are 0 and 0!
                add_asset-&gt;add(add_asset-&gt;inst, current_dir, asset_id, asset_name, args-&gt;undo_scope, should_select, args-&gt;ui,0,0);
</code></pre>
<p>That's it for the import.  Before we move on, we need to clean up! No Allocation without deallocation!</p>
<pre><code class="language-c">    tm_free(args-&gt;allocator, task, task-&gt;bytes);
</code></pre>
<blockquote>
<p>Info:  If you don't do this, the Engine will inform you that there is a memory leak in the logs/terminal.</p>
</blockquote>
<p>Now bringing it all together:</p>
<pre><code class="language-c">static void task__import_txt(void *data, uint64_t task_id)
{
    struct task__import_txt *task = (struct task__import_txt *)data;
    const struct tm_asset_io_import *args = &amp;task-&gt;args;
    const char *txt_file = task-&gt;file;
    tm_the_truth_o *tt = args-&gt;tt;
    tm_file_stat_t stat = tm_os_api-&gt;file_system-&gt;stat(txt_file);
    if (stat.exists)
    {
        tm_buffers_i *buffers = tm_the_truth_api-&gt;buffers(tt);
        void *buffer = buffers-&gt;allocate(buffers-&gt;inst, stat.size, false);
        tm_file_o f = tm_os_api-&gt;file_io-&gt;open_input(txt_file);
        const int64_t read = tm_os_api-&gt;file_io-&gt;read(f, buffer, stat.size);
        tm_os_api-&gt;file_io-&gt;close(f);
        if (read == (int64_t)stat.size)
        {
const uint32_t buffer_id = buffers-&gt;add(buffers-&gt;inst, buffer, stat.size, 0);
const tm_tt_type_t plugin_asset_type = tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__MY_ASSET);
const tm_tt_id_t asset_id = tm_the_truth_api-&gt;create_object_of_type(tt, plugin_asset_type, TM_TT_NO_UNDO_SCOPE);
tm_the_truth_object_o *asset_obj = tm_the_truth_api-&gt;write(tt, asset_id);
tm_the_truth_api-&gt;set_buffer(tt, asset_obj, TM_TT_PROP__MY_ASSET__DATA, buffer_id);
tm_the_truth_api-&gt;set_string(tt, asset_obj, TM_TT_PROP__MY_ASSET__FILE, txt_file);
 tm_the_truth_api-&gt;commit(tt, asset_obj, args-&gt;undo_scope);
                tm_the_truth_api-&gt;commit(tt, asset_obj, args-&gt;undo_scope);
                const char *asset_name = tm_path_api-&gt;base(tm_str(txt_file)).data;
                tm_asset_browser_add_asset_api *add_asset = tm_global_api_registry-&gt;get(TM_ASSET_BROWSER_ADD_ASSET_API_NAME);
                const tm_tt_id_t current_dir = add_asset-&gt;current_directory(add_asset-&gt;inst, args-&gt;ui);
                const bool should_select = args-&gt;asset_browser.u64 &amp;&amp; tm_the_truth_api-&gt;version(tt, args-&gt;asset_browser) == args-&gt;asset_browser_version_at_start;
                // we do not have any asset label therefore we do not need to pass them thats why the last
                // 2 arguments are 0 and 0!
                add_asset-&gt;add(add_asset-&gt;inst, current_dir, asset_id, asset_name, args-&gt;undo_scope, should_select, args-&gt;ui,0,0);
        }
        else
        {
            tm_logger_api-&gt;printf(TM_LOG_TYPE_INFO, &quot;import txt:cound not read %s\n&quot;, txt_file);
        }
    }
    else
    {
        tm_logger_api-&gt;printf(TM_LOG_TYPE_INFO, &quot;import txt:cound not find %s \n&quot;, txt_file);
    }
    tm_free(args-&gt;allocator, task, task-&gt;bytes);
}
</code></pre>
<h2 id="enabling-reimport"><a class="header" href="#enabling-reimport">Enabling reimport</a></h2>
<p>The previous import task would never be able to reimport an asset. Let us fix this quickly!
The <a href="https://ourmachinery.com/apidoc/foundation/asset_io.h.html#structtm_asset_io_import">tm_asset_io_import</a> has a field called <code>reimport_into</code> of type <a href="https://ourmachinery.com/apidoc/foundation/api_types.h.html#structtm_tt_id_t">tm_tt_id_t</a>, which we did not set. If the current context is an import, otherwise a valid the truth id. It enables us to check if the current context is an import or reimport. To achieve this, we need to update the <code>reimport_into</code> object with the newly created object asset_obj, and you can do this via The Truth API function <code>retarget_write.</code> It takes an object and updates it with the new content. Commit the change and destroy the temporary object (asset_obj).</p>
<pre><code class="language-c">            if (args-&gt;reimport_into.u64)
            {
                tm_the_truth_api-&gt;retarget_write(tt, asset_obj, args-&gt;reimport_into);
                tm_the_truth_api-&gt;commit(tt, asset_obj, args-&gt;undo_scope);
                tm_the_truth_api-&gt;destroy_object(tt, asset_id, args-&gt;undo_scope);
            }
</code></pre>
<p>This changes the source code as following:</p>
<pre><code class="language-c">static void task__import_txt(void *data, uint64_t task_id)
{
    struct task__import_txt *task = (struct task__import_txt *)data;
    const struct tm_asset_io_import *args = &amp;task-&gt;args;
    const char *txt_file = task-&gt;file;
    tm_the_truth_o *tt = args-&gt;tt;
    tm_file_stat_t stat = tm_os_api-&gt;file_system-&gt;stat(txt_file);
    if (stat.exists)
    {
        tm_buffers_i *buffers = tm_the_truth_api-&gt;buffers(tt);
        void *buffer = buffers-&gt;allocate(buffers-&gt;inst, stat.size, false);
        tm_file_o f = tm_os_api-&gt;file_io-&gt;open_input(txt_file);
        const int64_t read = tm_os_api-&gt;file_io-&gt;read(f, buffer, stat.size);
        tm_os_api-&gt;file_io-&gt;close(f);
        if (read == (int64_t)stat.size)
        {
            const uint32_t buffer_id = buffers-&gt;add(buffers-&gt;inst, buffer, stat.size, 0);
            const uint64_t plugin_asset_type = tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__MY_ASSET);
            const tm_tt_id_t asset_id = tm_the_truth_api-&gt;create_object_of_type(tt, plugin_asset_type, TM_TT_NO_UNDO_SCOPE);
            tm_the_truth_object_o *asset_obj = tm_the_truth_api-&gt;write(tt, asset_id);
            tm_the_truth_api-&gt;set_buffer(tt, asset_obj, 1, buffer_id);
            tm_the_truth_api-&gt;set_string(tt, asset_obj, 0, txt_file);
            if (args-&gt;reimport_into.u64)
            {
                tm_the_truth_api-&gt;retarget_write(tt, asset_obj, args-&gt;reimport_into);
                tm_the_truth_api-&gt;commit(tt, asset_obj, args-&gt;undo_scope);
                tm_the_truth_api-&gt;destroy_object(tt, asset_id, args-&gt;undo_scope);
            }
            else
            {
                tm_the_truth_api-&gt;commit(tt, asset_obj, args-&gt;undo_scope);
                TM_INIT_TEMP_ALLOCATOR(ta);
                const char *ext;
                const char *name = tm_path_api-&gt;split(txt_file, &amp;ext);
                const char *asset_name = tm_temp_allocator_api-&gt;printf(ta, &quot;%.*s&quot;, ext - name, name);
                tm_asset_browser_add_asset_api *add_asset = tm_global_api_registry-&gt;get(TM_ASSET_BROWSER_ADD_ASSET_API_NAME);
                const tm_tt_id_t current_dir = add_asset-&gt;current_directory(add_asset-&gt;inst, args-&gt;ui);
                const bool should_select = args-&gt;asset_browser.u64 &amp;&amp; tm_the_truth_api-&gt;version(tt, args-&gt;asset_browser) == args-&gt;asset_browser_version_at_start;
                // we do not have any asset label therefore we do not need to pass them thats why the last
                // 2 arguments are 0 and 0!
                add_asset-&gt;add(add_asset-&gt;inst, current_dir, asset_id, asset_name, args-&gt;undo_scope, should_select, args-&gt;ui,0,0);
                TM_SHUTDOWN_TEMP_ALLOCATOR(ta);
            }
        }
        else
        {
            tm_logger_api-&gt;printf(TM_LOG_TYPE_INFO, &quot;import txt:cound not read %s\n&quot;, txt_file);
        }
    }
    else
    {
        tm_logger_api-&gt;printf(TM_LOG_TYPE_INFO, &quot;import txt:cound not find %s \n&quot;, txt_file);
    }
    tm_free(args-&gt;allocator, task, task-&gt;bytes);
}
</code></pre>
<h2 id="refactor-the-custom-ui-import-functionality"><a class="header" href="#refactor-the-custom-ui-import-functionality">Refactor the Custom UI import functionality</a></h2>
<p>The last step before this part is over is to refactor the initial import of the file when we change the property in its custom UI. The current code does everything async. Besides, if we would leave this, we would have code duplication, which we want to avoid, for better-maintained reasons.</p>
<p>You might argue that it is the same process as just reimporting an asset when we change the path. That's correct!</p>
<p>We can reuse our Import-Task. Before we can launch a task, we need to ensure we have the right setup!
We can check the documentation of <a href="https://ourmachinery.com/apidoc/foundation/asset_io.h.html#structtm_asset_io_import">tm_asset_io_import</a> to ensure we do not forget anything important. </p>
<p>After we have done that, we will find that the reimport task needs besides the file name:</p>
<ul>
<li>the allocator</li>
<li>the current Truth</li>
<li>the object to import reimport into</li>
</ul>
<p>Now we can write our reimport task code. The code itself looks like this:</p>
<pre><code class="language-c">            tm_allocator_i *allocator = tm_allocator_api-&gt;system;
            const uint64_t bytes = sizeof(struct task__import_txt) + strlen(file);
            struct task__import_txt *task = tm_alloc(allocator, bytes);
            *task = (struct task__import_txt){
                .bytes = bytes,
                .args = {
                    .allocator = allocator,
                    .tt = tt,
                    .reimport_into = object}};
            strcpy(task-&gt;file, file);
            task_system-&gt;run_task(task__import_txt, task, &quot;Import Text File&quot;);
</code></pre>
<p>First, we ask for the system allocator (This one has the same lifetime as the program is running). Then, we allocate our task, including bytes for the string. Remember the struct structure:</p>
<pre><code class="language-c">// -- struct definitions
struct task__import_txt
{
    uint64_t bytes;
    struct tm_asset_io_import args;
    char file[8];
};
// .. other code
</code></pre>
<p>After that, we initialize our struct and its members with the needed data. Moreover, we copy the chars of the file name into our struct + extra bytes, and then we ask the task system to run the task.</p>
<p>This, combined with the custom UI functions, should look similar to this:</p>
<pre><code class="language-c">//custom ui
static float properties__custom_ui(struct tm_properties_ui_args_t *args, tm_rect_t item_rect, tm_tt_id_t object, uint32_t indent)
{
    tm_the_truth_o *tt = args-&gt;tt;
    bool picked = false;
    item_rect.y = tm_properties_view_api-&gt;ui_open_path(args, item_rect, TM_LOCALIZE_LATER(&quot;Import Path&quot;), TM_LOCALIZE_LATER(&quot;Path that the text file was imported from.&quot;), object, TM_TT_PROP__MY_ASSET__FILE, &quot;txt&quot;, &quot;text files&quot;, &amp;picked);
    if (picked)
    {
        const char *file = tm_the_truth_api-&gt;get_string(tt, tm_tt_read(tt, object), TM_TT_PROP__MY_ASSET__FILE);
        {
            tm_allocator_i *allocator = tm_allocator_api-&gt;system;
            const uint64_t bytes = sizeof(struct task__import_txt) + strlen(file);
            struct task__import_txt *task = tm_alloc(allocator, bytes);
            *task = (struct task__import_txt){
                .bytes = bytes,
                .args = {
                    .allocator = allocator,
                    .tt = tt,
                    .reimport_into = object}};
            strcpy(task-&gt;file, file);
            task_system-&gt;run_task(task__import_txt, task, &quot;Import Text File&quot;);
        }
    }
    return item_rect.y;
}
</code></pre>
<p><em>(For more information on the structure of these functions, please check the previous part)</em></p>
<ul>
<li><a href="the_truth/custom_asset/part3.html#">Part 1</a></li>
<li><a href="the_truth/custom_asset/part3.html#">Part 2</a></li>
</ul>
<h2 id="the-end"><a class="header" href="#the-end">The end</a></h2>
<p>It is the end of this walkthrough. You might have gained a better understanding:</p>
<ul>
<li>Of the Truth </li>
<li>How to create an asset</li>
<li>How to import assets into the Engine</li>
<li>How to provide a custom UI. </li>
</ul>
<p>If you wanted to see a more complex example of an importer, you could check the assimp importer example <code>samples\plugins\assimp</code>.</p>
<p>All the source code is available on GitHub in the <a href="https://github.com/simon-ourmachinery/example-text-file-asset"><strong>example-text-file-asset</strong></a> repo.</p>
<p><strong>Full Source Code</strong></p>
<p><code>txt.h</code></p>
<pre><code class="language-c">#pragma once
#include &lt;foundation/api_types.h&gt;
//... more code
#define TM_TT_TYPE__MY_ASSET &quot;tm_my_asset&quot;
#define TM_TT_TYPE_HASH__MY_ASSET TM_STATIC_HASH(&quot;tm_my_asset&quot;, 0x1e12ba1f91b99960ULL)

enum {
    TM_TT_PROP__MY_ASSET__FILE,
    TM_TT_PROP__MY_ASSET__DATA,
};
</code></pre>
<p><code>txt.c</code></p>
<pre><code class="language-c">// -- api's
static struct tm_api_registry_api *tm_global_api_registry;
static struct tm_the_truth_api *tm_the_truth_api;
static struct tm_properties_view_api *tm_properties_view_api;
static struct tm_os_api *tm_os_api;
static struct tm_path_api *tm_path_api;
static struct tm_temp_allocator_api *tm_temp_allocator_api;
static struct tm_logger_api *tm_logger_api;
static struct tm_localizer_api *tm_localizer_api;
static struct tm_asset_io_api *tm_asset_io_api;
static struct tm_task_system_api *task_system;
static struct tm_allocator_api *tm_allocator_api;
static struct tm_sprintf_api *tm_sprintf_api;

// -- inlcudes

#include &lt;foundation/api_registry.h&gt;
#include &lt;foundation/asset_io.h&gt;
#include &lt;foundation/buffer.h&gt;
#include &lt;foundation/carray_print.inl&gt;
#include &lt;foundation/localizer.h&gt;
#include &lt;foundation/log.h&gt;
#include &lt;foundation/macros.h&gt;
#include &lt;foundation/os.h&gt;
#include &lt;foundation/path.h&gt;
#include &lt;foundation/sprintf.h&gt;
#include &lt;foundation/string.inl&gt;
#include &lt;foundation/task_system.h&gt;
#include &lt;foundation/temp_allocator.h&gt;
#include &lt;foundation/the_truth.h&gt;
#include &lt;foundation/the_truth_assets.h&gt;
#include &lt;foundation/undo.h&gt;

#include &lt;plugins/editor_views/asset_browser.h&gt;
#include &lt;plugins/editor_views/properties.h&gt;

#include &quot;txt.h&quot;
// -- struct definitions
struct task__import_txt
{
    uint64_t bytes;
    struct tm_asset_io_import args;
    char file[8];
};
/////
// -- functions:
////
// --- importer
static void task__import_txt(void *data, uint64_t task_id)
{
    struct task__import_txt *task = (struct task__import_txt *)data;
    const struct tm_asset_io_import *args = &amp;task-&gt;args;
    const char *txt_file = task-&gt;file;
    tm_the_truth_o *tt = args-&gt;tt;
    tm_file_stat_t stat = tm_os_api-&gt;file_system-&gt;stat(txt_file);
    if (stat.exists) {
        tm_buffers_i *buffers = tm_the_truth_api-&gt;buffers(tt);
        void *buffer = buffers-&gt;allocate(buffers-&gt;inst, stat.size, false);
        tm_file_o f = tm_os_api-&gt;file_io-&gt;open_input(txt_file);
        const int64_t read = tm_os_api-&gt;file_io-&gt;read(f, buffer, stat.size);
        tm_os_api-&gt;file_io-&gt;close(f);
        if (read == (int64_t)stat.size) {
            const uint32_t buffer_id = buffers-&gt;add(buffers-&gt;inst, buffer, stat.size, 0);
            const tm_tt_type_t plugin_asset_type = tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__MY_ASSET);
            const tm_tt_id_t asset_id = tm_the_truth_api-&gt;create_object_of_type(tt, plugin_asset_type, TM_TT_NO_UNDO_SCOPE);
            tm_the_truth_object_o *asset_obj = tm_the_truth_api-&gt;write(tt, asset_id);
            tm_the_truth_api-&gt;set_buffer(tt, asset_obj, TM_TT_PROP__MY_ASSET__DATA, buffer_id);
            tm_the_truth_api-&gt;set_string(tt, asset_obj, TM_TT_PROP__MY_ASSET__FILE, txt_file);
            if (args-&gt;reimport_into.u64) {
                tm_the_truth_api-&gt;retarget_write(tt, asset_obj, args-&gt;reimport_into);
                tm_the_truth_api-&gt;commit(tt, asset_obj, args-&gt;undo_scope);
                tm_the_truth_api-&gt;destroy_object(tt, asset_id, args-&gt;undo_scope);
            } else {
                tm_the_truth_api-&gt;commit(tt, asset_obj, args-&gt;undo_scope);
                const char *asset_name = tm_path_api-&gt;base(tm_str(txt_file)).data;
                struct tm_asset_browser_add_asset_api *add_asset = tm_global_api_registry-&gt;get(TM_ASSET_BROWSER_ADD_ASSET_API_NAME);
                const tm_tt_id_t current_dir = add_asset-&gt;current_directory(add_asset-&gt;inst, args-&gt;ui);
                const bool should_select = args-&gt;asset_browser.u64 &amp;&amp; tm_the_truth_api-&gt;version(tt, args-&gt;asset_browser) == args-&gt;asset_browser_version_at_start;
                add_asset-&gt;add(add_asset-&gt;inst, current_dir, asset_id, asset_name, args-&gt;undo_scope, should_select, args-&gt;ui, 0, 0);
            }
        } else {
            tm_logger_api-&gt;printf(TM_LOG_TYPE_INFO, &quot;import txt:cound not read %s\n&quot;, txt_file);
        }
    } else {
        tm_logger_api-&gt;printf(TM_LOG_TYPE_INFO, &quot;import txt:cound not find %s \n&quot;, txt_file);
    }
    tm_free(args-&gt;allocator, task, task-&gt;bytes);
}

static bool asset_io__enabled(struct tm_asset_io_o *inst)
{
    return true;
}
static bool asset_io__can_import(struct tm_asset_io_o *inst, const char *extension)
{
    return tm_strcmp_ignore_case(extension, &quot;txt&quot;) == 0;
}
static bool asset_io__can_reimport(struct tm_asset_io_o *inst, struct tm_the_truth_o *tt, tm_tt_id_t asset)
{
    const tm_tt_id_t object = tm_the_truth_api-&gt;get_subobject(tt, tm_tt_read(tt, asset), TM_TT_PROP__ASSET__OBJECT);
    return object.type == tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__MY_ASSET).u64;
}
static void asset_io__importer_extensions_string(struct tm_asset_io_o *inst, char **output, struct tm_temp_allocator_i *ta, const char *separator)
{
    tm_carray_temp_printf(output, ta, &quot;txt&quot;);
}
static void asset_io__importer_description_string(struct tm_asset_io_o *inst, char **output, struct tm_temp_allocator_i *ta, const char *separator)
{
    tm_carray_temp_printf(output, ta, &quot;.txt&quot;);
}
static uint64_t asset_io__import_asset(struct tm_asset_io_o *inst, const char *file, const struct tm_asset_io_import *args)
{
    const uint64_t bytes = sizeof(struct task__import_txt) + strlen(file);
    struct task__import_txt *task = tm_alloc(args-&gt;allocator, bytes);
    *task = (struct task__import_txt){
        .bytes = bytes,
        .args = *args,
    };
    strcpy(task-&gt;file, file);
    return task_system-&gt;run_task(task__import_txt, task, &quot;Import Text File&quot;);
}
static struct tm_asset_io_i txt_asset_io = {
    .enabled = asset_io__enabled,
    .can_import = asset_io__can_import,
    .can_reimport = asset_io__can_reimport,
    .importer_extensions_string = asset_io__importer_extensions_string,
    .importer_description_string = asset_io__importer_description_string,
    .import_asset = asset_io__import_asset
};

// -- asset on its own

//custom ui
static float properties__custom_ui(struct tm_properties_ui_args_t *args, tm_rect_t item_rect, tm_tt_id_t object, uint32_t indent)
{
    tm_the_truth_o *tt = args-&gt;tt;
    bool picked = false;
    item_rect.y = tm_properties_view_api-&gt;ui_open_path(args, item_rect, TM_LOCALIZE_LATER(&quot;Import Path&quot;), TM_LOCALIZE_LATER(&quot;Path that the text file was imported from.&quot;), object, TM_TT_PROP__MY_ASSET__FILE, &quot;txt&quot;, &quot;text files&quot;, &amp;picked);
    if (picked) {
        const char *file = tm_the_truth_api-&gt;get_string(tt, tm_tt_read(tt, object), TM_TT_PROP__MY_ASSET__FILE);
        {
            tm_allocator_i *allocator = tm_allocator_api-&gt;system;
            const uint64_t bytes = sizeof(struct task__import_txt) + strlen(file);
            struct task__import_txt *task = tm_alloc(allocator, bytes);
            *task = (struct task__import_txt){
                .bytes = bytes,
                .args = {
                    .allocator = allocator,
                    .tt = tt,
                    .reimport_into = object }
            };
            strcpy(task-&gt;file, file);
            task_system-&gt;run_task(task__import_txt, task, &quot;Import Text File&quot;);
        }
    }
    return item_rect.y;
}

// -- create truth type
static void create_truth_types(struct tm_the_truth_o *tt)
{
    static tm_the_truth_property_definition_t my_asset_properties[] = {
        { &quot;import_path&quot;, TM_THE_TRUTH_PROPERTY_TYPE_STRING },
        { &quot;data&quot;, TM_THE_TRUTH_PROPERTY_TYPE_BUFFER },
    };
    const tm_tt_type_t type = tm_the_truth_api-&gt;create_object_type(tt, TM_TT_TYPE__MY_ASSET, my_asset_properties, TM_ARRAY_COUNT(my_asset_properties));
    tm_the_truth_api-&gt;set_aspect(tt, type, TM_TT_ASPECT__FILE_EXTENSION, &quot;txt&quot;);
    static tm_properties_aspect_i properties_aspect = {
        .custom_ui = properties__custom_ui,
    };
    tm_the_truth_api-&gt;set_aspect(tt, type, TM_TT_ASPECT__PROPERTIES, &amp;properties_aspect);
}

// -- asset browser regsiter interface
static tm_tt_id_t asset_browser_create(struct tm_asset_browser_create_asset_o *inst, tm_the_truth_o *tt, tm_tt_undo_scope_t undo_scope)
{
    const tm_tt_type_t type = tm_the_truth_api-&gt;object_type_from_name_hash(tt, TM_TT_TYPE_HASH__MY_ASSET);
    return tm_the_truth_api-&gt;create_object_of_type(tt, type, undo_scope);
}
static tm_asset_browser_create_asset_i asset_browser_create_my_asset = {
    .menu_name = TM_LOCALIZE_LATER(&quot;New Text File&quot;),
    .asset_name = TM_LOCALIZE_LATER(&quot;New Text File&quot;),
    .create = asset_browser_create,
};

// -- load plugin
TM_DLL_EXPORT void tm_load_plugin(struct tm_api_registry_api *reg, bool load)
{
    tm_the_truth_api = reg-&gt;get(TM_THE_TRUTH_API_NAME);
    tm_properties_view_api = reg-&gt;get(TM_PROPERTIES_VIEW_API_NAME);
    tm_os_api = reg-&gt;get(TM_OS_API_NAME);
    tm_path_api = reg-&gt;get(TM_PATH_API_NAME);
    tm_temp_allocator_api = reg-&gt;get(TM_TEMP_ALLOCATOR_API_NAME);
    tm_allocator_api = reg-&gt;get(TM_ALLOCATOR_API_NAME);
    tm_logger_api = reg-&gt;get(TM_LOGGER_API_NAME);
    tm_localizer_api = reg-&gt;get(TM_LOCALIZER_API_NAME);
    tm_asset_io_api = reg-&gt;get(TM_ASSET_IO_API_NAME);
    task_system = reg-&gt;get(TM_TASK_SYSTEM_API_NAME);
    tm_sprintf_api = reg-&gt;get(TM_SPRINTF_API_NAME);
    tm_global_api_registry = reg;
    if (load)
        tm_asset_io_api-&gt;add_asset_io(&amp;txt_asset_io);
    else
        tm_asset_io_api-&gt;remove_asset_io(&amp;txt_asset_io);
    tm_add_or_remove_implementation(reg, load, TM_THE_TRUTH_CREATE_TYPES_INTERFACE_NAME, create_truth_types);
    tm_add_or_remove_implementation(reg, load, TM_ASSET_BROWSER_CREATE_ASSET_INTERFACE_NAME, &amp;asset_browser_create_my_asset);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ui"><a class="header" href="#ui">UI</a></h1>
<p>The Machinery's <a href="https://ourmachinery.com/apidoc/plugins/ui">UI system</a>, is a Immediate Mode GUI (IMGUI). Besides the information you can find here or in our API Documentation there are several Blog Posts you should check out:</p>
<ul>
<li><a href="https://ourmachinery.com/post/one-draw-call-ui/">One Draw Call UI</a></li>
<li><a href="https://ourmachinery.com/post/ui-rendering-using-primitive-buffers/">UI rendering using Primitive Buffers</a></li>
<li><a href="https://ourmachinery.com/post/implementing-drag-and-drop-in-an-imgui/">Implementing drag-and-drop in an IMGUI</a></li>
<li><a href="https://ourmachinery.com/post/localization-in-the-machinerys-ui/">Localization in The Machinery’s UI</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-custom-ui-controls"><a class="header" href="#build-custom-ui-controls">Build Custom UI Controls</a></h1>
<p>These walkthroughs we will teach you how to extend The Machinery's <a href="https://ourmachinery.com/apidoc/plugins/ui">UI system</a>.</p>
<p>In following following parts 1 - 3 we will cover the following topics:</p>
<ul>
<li><a href="https://ourmachinery.github.io/themachinery-books/tutorials//ui/build_custom_ui_controls/part1.html">Create a custom circular button</a></li>
<li><a href="ui/build_custom_ui_controls/index.html#">Add a texture to our custom control</a></li>
<li><a href="ui/build_custom_ui_controls/index.html#">Setup a UI Renderer</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-custom-ui-controls-part-i"><a class="header" href="#build-custom-ui-controls-part-i">Build Custom UI Controls, Part I</a></h1>
<p>Hi, we are starting a 3-part tutorial series about The Machinery UI system. In Part I, we’ll talk about the basics and create a custom circular button. In Part II, we’ll create a custom button with textures support. To show the results of the first two parts, we’ll be using a simple custom tab, so in Part III, we’ll see how to set up your UI and render it on screen.</p>
<p>During this tutorial, you’ll implement the <code>tm_ui_custom_controls</code> plugin, which will contain the <code>tm_ui_custom_controls_api</code> for draw custom controls in UI and <code>tm_ui_custom_controls_tab</code> custom tab in order to visualize results in a separate tab.</p>
<p><strong>Table of Content</strong></p>
<ul>
<li><a href="ui/build_custom_ui_controls/part1.html#environment-setup">Environment setup</a></li>
<li><a href="ui/build_custom_ui_controls/part1.html#circular-custom-button">Circular Custom Button:</a></li>
<li><a href="ui/build_custom_ui_controls/part1.html#drawing-text">Drawing text</a></li>
</ul>
<h2 id="environment-setup"><a class="header" href="#environment-setup">Environment setup</a></h2>
<p>During this tutorial, you’ll build the <code>tm_ui_custom_controls</code> plugin, which will contain the <code>tm_ui_custom_controls_api</code> for draw custom controls and <code>tm_ui_custom_controls_tab</code> custom tab in order to visualize results in a separate tab.</p>
<blockquote>
<p>The source code is hosted on <a href="https://github.com/raphael-ourmachinery/tm-custom-control-tutorial">https://github.com/raphael-ourmachinery/tm-custom-control-tutorial</a>, copy the contents of <code>skel/</code> folder to a separate directory, the final result will be available in <code>part1/</code> folder. </p>
</blockquote>
<p>Below is a list of files of our project:</p>
<ul>
<li><code>skel/libs.json</code>: specify premake5 binaries that will be downloaded from The Machinery server;</li>
<li><code>skel/(premake5.lua/build.bat/build.sh)</code>: build scripts that use <code>tmbuild.exe</code> to build our shared library. Note that we are targeting <code>TM_SDK_DIR/bin/plugins</code>, so our plugin will be automatically loaded by the engine. You’ll need to set the <code>TM_SDK_DIR</code> environment variable pointing to The Machinery directory. </li>
<li><code>skel/src/custom_tab.(c/h)</code>: this is a minimal version of the custom tab sample, which makes it easier to see our custom button;</li>
<li><code>skel/src/ui_custom_controls_loader.(c/h)</code>: load the necessary APIs, it contains the definition of <code>tm_load_plugin()</code> needed our plugin be loaded by the plugins system;</li>
<li><code>skel/src/ui_custom_controls.(c/h)</code>: implementation of our circular button, later you can extend the API with your custom controls too.</li>
</ul>
<h2 id="circular-custom-button"><a class="header" href="#circular-custom-button">Circular Custom Button:</a></h2>
<p>The Machinery uses an immediate-mode UI. You can read more about it on <a href="https://ourmachinery.com/post/one-draw-call-ui/">One Draw Call UI</a> blog post. To draw 2D shapes, we’ll be using the <a href="https://ourmachinery.com/apidoc/plugins/ui/draw2d.h.html#structtm_draw2d_api"><code>tm_draw2d_api</code></a> implemented in <a href="https://ourmachinery.com/apidoc/plugins/ui/draw2d.h.html"><code>draw2d.h</code></a>, which supplies functions to draw basic 2D shapes. As we are implementing a circular button, we’ll we need to draw a circle using the following function:</p>
<pre><code>tm_draw2d_api→fill_circle(tm_draw2d_vbuffer_t *vbuffer, tm_draw2d_ibuffer_t *ibuffer, const tm_draw2d_style_t *style, tm_vec2_t pos, float radius)
</code></pre>
<p>You can note this function takes a vertex and an index buffer as arguments. In the following tutorials, we’ll learn more about it, but for now, you only need to know is that <a href="https://ourmachinery.com/apidoc/plugins/ui/draw2d.h.html#structtm_draw2d_api"><code>tm_draw2d_api</code></a> will fill them, and we need to call <a href="https://ourmachinery.com/apidoc/plugins/ui/ui.h.html#structtm_ui_api.buffers()"><code>tm_ui_api-&gt;buffers()</code></a> to get the buffers. Later the engine will use <a href="https://ourmachinery.com/apidoc/plugins/ui/ui_renderer.h.html#structtm_ui_renderer_api">tm_ui_renderer_api</a> to draw the UI using one draw call.</p>
<p>Let’s add some more information <code>tm_ui_circular_button_t</code> and use it on <code>circular_button()</code>:</p>
<ul>
<li>ui_custom_controls.h:</li>
</ul>
<pre><code class="language-C">    ...
    
    typedef struct tm_ui_circular_button_t
    {
        uint64_t id;
    
        tm_vec2_t center;
        float radius;
        tm_color_srgb_t background_color;
    } tm_ui_circular_button_t;
    
    ...
</code></pre>
<ul>
<li>ui_custom_controls.c:</li>
</ul>
<pre><code class="language-C">    ...
    
    bool circular_button(struct tm_ui_o *ui, const struct tm_ui_style_t *uistyle, const tm_ui_circular_button_t *c)
    {
        // tm_ui_buffer_t contains information needed when creating a custom control
        tm_ui_buffers_t uib = tm_ui_api-&gt;buffers(ui);
    
        // convert tm_ui_style_t to tm_draw2d_style_t
        tm_draw2d_style_t style;
        tm_ui_api-&gt;to_draw_style(ui, &amp;style, uistyle);
        style.color = c-&gt;background_color;
    
        tm_draw2d_api-&gt;fill_circle(uib.vbuffer, uib.ibuffers[uistyle-&gt;buffer], &amp;style, c-&gt;center, c-&gt;radius);
    
        return false;
    }
    
    ...
</code></pre>
<p>For control interaction logic, we'll need interfaces from <a href="https://ourmachinery.com/apidoc/plugins/ui/ui_custom.h.html#ui_custom.h">ui_custom.h</a>, actually all editor's UI is implemented using them.  <a href="https://ourmachinery.com/apidoc/plugins/ui/ui.h.html#structtm_ui_buffers_t">tm_ui_buffers_t</a> that we got earlier has two important members, <a href="https://ourmachinery.com/apidoc/plugins/ui/ui_custom.h.html#structtm_ui_activation_t">tm_ui_activation_t</a> one keeps the information about activation and hovering state of UI controls, and <a href="https://ourmachinery.com/apidoc/plugins/ui/ui_custom.h.html#structtm_ui_input_state_t">tm_ui_input_state_t</a> maintains the input state. The table below lists some important concepts of our UI system. You can read it at once, or skip for now and return when necessary:</p>
<table><thead><tr><th><strong>Concept</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>ID</td><td>Each control in the UI has a unique 64-bit identifier. Since controls are not explicitly created and destroyed, the ID is the only thing that identifies a control from one frame to the next.<br><br>You create a new ID by calling <a href="https://ourmachinery.com/apidoc/plugins/ui/ui.h.html#structtm_ui_api.make_id()"><code>tm_ui_api-&gt;make_id()</code></a>. IDs are assigned sequentially by the UI. You have to be a bit careful with this if you have controls that sometimes are visible and sometimes not, such as <em>context menus</em>. If you only generate the ID for the context menu when it is visible, it will change the numbering of the subsequent controls depending on whether the menu is visible or not. Since controls are identified by their IDs, this can lead to controls being misidentified.<br><br>A good strategy is to generate the IDs for all the controls that you <em>might</em> show upfront, so that the ID assignment is stable.<br><br>Note: We may change this in the future if we can find a more stable way of assigning IDs.</td></tr>
<tr><td>Hover</td><td>The UI system keeps track of which control the mouse pointer is <em>hovering</em> over, by storing its ID in a <em>hover</em> variable.<br><br>You never set the <em>hover</em> variable directly. Instead, in your control’s update, you check if the mouse is over your control with <a href="https://ourmachinery.com/apidoc/plugins/ui/ui.h.html#structtm_ui_api.is_hovering()"><code>tm_ui_api-&gt;is_hovering()</code></a>, and if it is you set <code>next_hover</code> to its ID. At the end of the frame, the UI assigns the value of <code>next_hover</code> to the <code>hover</code> variable.<br><br>The reason for this two-step process is that multiple controls or objects might be drawn on top of each other in the same area of the UI. The last object drawn will be on top and we want the <em>hover</em> variable to reflect whatever the user sees on the screen.</td></tr>
<tr><td>Overlay</td><td>The UI is actually drawn in two layers, one <em>Base</em> and one <em>Overlay</em> layer. The controls in the overlay layer are drawn on top of the controls in the <em>Base</em> layer, even if they are drawn earlier in the draw order. We use the Overlay layer for things like drop-down menus that should appear on top of other controls.<br><br>If an earlier control set <em>next_hover</em> to a control in the Overlay layer, this shouldn’t be changed by a later control in the base layer, because the Overlay layer control will appear on top of that one. We use a variable <code>next_hover_in_overlay</code> to keep track of if the current <code>next_hover</code> value represents an ID in the Overlay layer. In this case, it shouldn’t be changed by base layer controls.<br><br>In practice, the Overlay layer is implemented by keeping track of two index buffers in the drawing system, one for the base layer and one for the overlay layer. (Note that the two layers still share a single vertex buffer.) At the end of drawing, we merge the two buffers into one, by simply concatenating the Overlay buffer at the end of the base Buffer, thus making sure the overlay controls are drawn later, on top of the base control. With this approach, we can still draw everything with a single draw call.<br><br>Note that as a consequence of how we render our UI — we only have a single Vulkan context and everything is drawn with the same draw call — drop-down menus and other pop-up controls cannot extrude past the edges of the system window — everything is drawn with the system window rect.</td></tr>
<tr><td>Active</td><td>Similar to <em>Hover</em>, <em>Active</em> is a variable that keeps track of the currently active control, i.e. the control the user is currently interacting with.<br><br>We need to keep track of the active control for two reasons. First, we often want to draw the active control in a special way, such as showing a highlight and a caret in an active text box.<br><br>Second, the active control typically needs to keep track of some extra state. For example, an active slider needs to keep track of the slider’s initial position so that it can pop back to that if the user drags the mouse outside the slider.<br><br>The UI system uses a single large <code>char[]</code> buffer to keep track of the current active control’s state. This buffer is shared by all controls. Since there can only be one active control at a time, only one control will be using this buffer at a time. When a new control becomes active the buffer is zeroed (this should be a valid initial state for the active data).<br><br>Typically a control becomes active if the user presses the left mouse button while the control is being <em>hovered</em>. In this case, the control will call <a href="https://ourmachinery.com/apidoc/plugins/ui/ui.h.html#structtm_ui_api.set_active()"><code>tm_ui_api-&gt;set_active()</code></a>. Though there are other ways a control can become active too, such as by tabbing. To implement tab focus, you need to call <a href="https://ourmachinery.com/apidoc/plugins/ui/ui.h.html#structtm_ui_api.focus_on_tab()"><code>tm_ui_api-&gt;focus_on_tab()</code></a> in the control’s code.</td></tr>
<tr><td>Clipping</td><td>The drawing system has support for <em>Clipping</em> <em>Rects.</em> This is mostly useful when you need to clip text to a control’s rect. You create a new clipping rect by calling <a href="https://ourmachinery.com/apidoc/plugins/ui/draw2d.h.html#structtm_draw2d_api.add_clip_rect()"><code>tm_draw2d_api-&gt;add_clip_rect()</code></a> or <a href="https://ourmachinery.com/apidoc/plugins/ui/draw2d.h.html#structtm_draw2d_api.add_sub_clip_rect()"><code>tm_draw2d_api-&gt;add_sub_clip_rect()</code></a>. This gives you a clipping ID that can be passed as part of the Draw or UI style.</td></tr>
<tr><td>Responder scopes</td><td><em>Responder Scopes</em> are used to control which controls can respond to keyboard input. Typically, when a control is <em>Active</em>, it, and all its parent controls can respond to keyboard input. For example, if the control is inside a scrollview, the scrollview will respond to scroll keypresses, while the tab that hosts the scrollview may respond to commands such as Ctrl+F.<br><br>Being an immediate GUI system, <em>The Machinery</em> doesn’t have an explicit concept of “child” and “parent” controls. Instead we use the concept of <em>Responder Scopes</em>. A parent control first calls <a href="https://ourmachinery.com/apidoc/plugins/ui/ui.h.html#structtm_ui_api.begin_responder_scope()"><code>begin_responder_scope()</code></a>, then draws all its child controls and finally calls <a href="https://ourmachinery.com/apidoc/plugins/ui/ui.h.html#structtm_ui_api.end_responder_scope()"><code>end_responder_scope()</code></a>. This establishes a parent-child relationship for the purpose of keyboard interaction.<br><br>When a control becomes <em>Active</em>, the current set of Responder Scopes is saved as the <em>Responder Chain</em>. This is the list of controls that can respond to a keyboard action. To test if your control should act on keyboard input, you can call <a href="https://ourmachinery.com/apidoc/plugins/ui/ui.h.html#structtm_ui_api.in_responder_chain()"><code>in_responder_chain()</code></a>.<br><br>Note: We currently don’t have any mechanism to check if other controls in the Responder Chain have “consumed” keyboard input, so if you have multiple controls in the same chain that respond to the same keyboard command, you may run into trouble.</td></tr>
</tbody></table>
<p>Bellow, we have a higher-level view of the steps needed to implement our interaction logic:</p>
<ol>
<li>Create a id with <a href="https://ourmachinery.com/apidoc/plugins/ui/ui.h.html#structtm_ui_api.make_id()"><code>tm_ui_api→make_id()</code></a>;</li>
<li>Check if the button is already active with <a href="https://ourmachinery.com/apidoc/plugins/ui/ui.h.html#structtm_ui_api.is_active()"><code>tm_ui_api→is_active()</code></a>, it will return a pointer for a 16Kb buffer that you can use to keep custom data needed while the button is active;</li>
<li>Check if the mouse is hovering the button, and set activation <code>next_hover</code> variable according. At the end of the frame, the UI system will set hover to our control id case no other control changed next_hover after us;</li>
<li>Case the hover variable contains our control id and mouse is pressed, set it as the active one, which is done which <a href="https://ourmachinery.com/apidoc/plugins/render_graph/render_graph.h.html#structtm_render_graph_setup_api.set_active()"><code>tm_ui_api→set_active()</code></a>, a pointer to the 16Kb buffer will be returned so you can cast it to control custom data, note that we need to pass a hash to the function identifying this data;</li>
<li>Case our button is active and mouse was released, the control is considered clicked, and we call <a href="https://ourmachinery.com/apidoc/plugins/ui/ui.h.html#structtm_ui_api.clear_active()"><code>tm_ui_api→clear_active()</code></a> to deactivate him;</li>
<li>Now we can check if the mouse is hovering our control and use either the active or hovering color depending on we are the active control or not;</li>
</ol>
<p>With this in mind, the complete code will be the following:</p>
<ul>
<li>ui_custom_controls.h:</li>
</ul>
<pre><code class="language-C">    ...
    typedef struct tm_ui_circular_button_data_t {
        const char *name;
        uint32_t frames_active;
    } tm_ui_circular_button_data_t;
    
    typedef struct tm_ui_circular_button_t
    {
        uint64_t id;
    
        tm_vec2_t center;
        float radius;
        tm_color_srgb_t background_color;
        tm_color_srgb_t hover_color;
        tm_color_srgb_t clicked_color;
    
        const char *text;
        const struct tm_color_srgb_t text_color;
    } tm_ui_circular_button_t;
    ...
</code></pre>
<ul>
<li>ui_custom_controls.c:</li>
</ul>
<pre><code class="language-C">    ...
    
    bool circular_button(struct tm_ui_o *ui, const struct tm_ui_style_t *uistyle, const tm_ui_circular_button_t *c)
    {
        // Step 1
        // tm_ui_buffer_t contains information needed when creating a custom control
        tm_ui_buffers_t uib = tm_ui_api-&gt;buffers(ui);
        const uint64_t id = c-&gt;id ? c-&gt;id : tm_ui_api-&gt;make_id(ui);
        
        // Step 2
        // is_active will return a pointer for user defined data up to 16KB
        tm_ui_circular_button_data_t *active = (tm_ui_circular_button_data_t *)tm_ui_api-&gt;is_active(ui, id, TM_UI_ACTIVE_DATA__CIRCULAR_BUTTON);
        if (active) {
            TM_LOG(&quot;active data -&gt; name: %s, frames_active: %u\n&quot;, active-&gt;name, active-&gt;frames_active);
            active-&gt;frames_active++;
        }
    
        // convert tm_ui_style_t to tm_draw2d_style_t
        tm_draw2d_style_t style;
        tm_ui_api-&gt;to_draw_style(ui, &amp;style, uistyle);
        style.color = c-&gt;background_color;
        
        // Step 3
        bool clicked = false;
        bool inside = tm_vec2_in_circle(uib.input-&gt;mouse_pos, c-&gt;center, c-&gt;radius);
        if (inside)
            uib.activation-&gt;next_hover = id;
        
        // Step 4
        if (uib.activation-&gt;hover == id &amp;&amp; uib.input-&gt;left_mouse_pressed) {
            active = tm_ui_api-&gt;set_active(ui, id, TM_UI_ACTIVE_DATA__CIRCULAR_BUTTON);
            if (active)
                *active = (tm_ui_circular_button_data_t){ .name = &quot;circular_button&quot;, .frames_active = 0 };
            tm_ui_api-&gt;set_responder_chain(ui, 0);
        }
        
        // Step 5
        if (active &amp;&amp; uib.input-&gt;left_mouse_released) {
            clicked = inside;
            tm_ui_api-&gt;clear_active(ui);
        }
        
        // Step 6
        if (inside) {
            if (active)
                style.color = c-&gt;clicked_color;
            else if (uib.activation-&gt;hover == id)
                style.color = c-&gt;hover_color;
        }
    
        tm_ui_api-&gt;reserve_draw_memory(ui);
        tm_draw2d_api-&gt;fill_circle(uib.vbuffer, uib.ibuffers[uistyle-&gt;buffer], &amp;style, c-&gt;center, c-&gt;radius);
    
        return clicked;
    }
    
    ...
</code></pre>
<h2 id="drawing-text"><a class="header" href="#drawing-text">Drawing text</a></h2>
<p>The last thing we need is to draw some text inside our button. You'll need to call <a href="https://ourmachinery.com/apidoc/plugins/ui/draw2d.h.html#structtm_draw2d_api.draw_glyphs()"><code>tm_draw2d_api→draw_glyphs()</code></a> to fill UI buffers with text information. It takes as one of its arguments an array of glyphs indices that point to the corresponding <a href="https://ourmachinery.com/apidoc/plugins/ui/draw2d.h.html#structtm_font_glyph_t">tm_font_glyph_t</a> glyph inside the <a href="https://ourmachinery.com/apidoc/plugins/ui/draw2d.h.html#structtm_font_t">tm_font_t</a> structure. To get this information, we first need to convert the desired text to an array of codepoints using <a href="https://ourmachinery.com/apidoc/foundation/unicode.h.html#structtm_unicode_api.utf8_decode_n()"><code>tm_unicode_api→utf8_decode_n()</code></a> and pass them to <a href="https://ourmachinery.com/apidoc/plugins/ui/draw2d.h.html#structtm_font_api.glyphs()"><code>tm_font_api→glyphs()</code></a> . Thus, add the following lines to the source code:</p>
<p>With this in mind, the complete code will be the following:</p>
<ul>
<li>ui_custom_controls.h:</li>
</ul>
<pre><code class="language-C">    ...
    
    typedef struct tm_ui_circular_button_t
    {
       ...
        uint32_t icon;
        const char *text;
        const struct tm_color_srgb_t text_color;
    } tm_ui_circular_button_t;
    ...
</code></pre>
<ul>
<li>ui_custom_controls.c:</li>
</ul>
<pre><code class="language-C">    ...
    
    bool circular_button(struct tm_ui_o *ui, const struct tm_ui_style_t *uistyle, const tm_ui_circular_button_t *c)
    {
        ...
        // Inscribe a quad in button circle
        const float side = c-&gt;radius * sqrtf(2);
        tm_rect_t text_rect = tm_rect_center_dim(c-&gt;center, (tm_vec2_t){ side, side });
    
        tm_ui_api-&gt;reserve_draw_memory(ui);
        style.clip = tm_draw2d_api-&gt;add_sub_clip_rect(uib.vbuffer, style.clip, text_rect);
    
        // Get glyphs from our text
        uint16_t glyphs[128];
        uint32_t n = 0;
        {
            uint32_t codepoints[128];
            n = tm_unicode_api-&gt;utf8_decode_n(codepoints, 128, tm_or(c-&gt;text, &quot;&quot;));
            tm_font_api-&gt;glyphs(style.font-&gt;info, glyphs, codepoints, 128);
        }
        tm_vec2_t text_pos = {
            .x = c-&gt;center.x - side / 2.f,
            .y = middle_baseline(text_rect.y, text_rect.h, style.font-&gt;info, 1.f),
        };
        style.color = c-&gt;text_color;
        tm_draw2d_api-&gt;draw_glyphs(uib.vbuffer, uib.ibuffers[uistyle-&gt;buffer], &amp;style, text_pos, glyphs, n);
    
        return clicked;
    }
    
    ...
</code></pre>
<p>We now have a custom button implementation that can be used across your projects. Please extend it and show us your results.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
